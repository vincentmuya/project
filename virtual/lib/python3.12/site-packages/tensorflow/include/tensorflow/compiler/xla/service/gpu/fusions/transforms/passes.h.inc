/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#define GEN_PASS_DECL_CONVERTPURECALLOPSPASS
#define GEN_PASS_DECL_ERASEDEADFUNCTIONSPASS
#define GEN_PASS_DECL_EXPANDFLOATOPSPASS
#define GEN_PASS_DECL_FLATTENTENSORSPASS
#define GEN_PASS_DECL_LOWERTENSORSPASS
#define GEN_PASS_DECL_LOWERTOLLVMPASS
#define GEN_PASS_DECL_LOWERXLAGPULOOPSTOSCFPASS
#define GEN_PASS_DECL_LOWERXLAGPUTOSCFPASS
#define GEN_PASS_DECL_MERGEPOINTERSTOSAMESLICEPASS
#define GEN_PASS_DECL_OPTIMIZELOOPSPASS
#define GEN_PASS_DECL_PEELLOOPSPASS
#define GEN_PASS_DECL_PROPAGATESLICEINDICESPASS
#define GEN_PASS_DECL_REWRITEREDUCTIONSPASS
#define GEN_PASS_DECL_SIMPLIFYAFFINEPASS
#define GEN_PASS_DECL_SIMPLIFYARITHPASS
#define GEN_PASS_DECL_UNSWITCHLOOPSPASS
#define GEN_PASS_DECL_VECTORIZELOADSANDSTORESPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ConvertFloatNvidiaPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#undef GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#endif // GEN_PASS_DECL_CONVERTFLOATNVIDIAPASS
#ifdef GEN_PASS_DEF_CONVERTFLOATNVIDIAPASS
namespace impl {

template <typename DerivedT>
class ConvertFloatNvidiaPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertFloatNvidiaPassBase;

  ConvertFloatNvidiaPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFloatNvidiaPassBase(const ConvertFloatNvidiaPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertFloatNvidiaPassBase& operator=(const ConvertFloatNvidiaPassBase &) = delete;
  ConvertFloatNvidiaPassBase(ConvertFloatNvidiaPassBase &&) = delete;
  ConvertFloatNvidiaPassBase& operator=(ConvertFloatNvidiaPassBase &&) = delete;
  ~ConvertFloatNvidiaPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-float-nvidia");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-float-nvidia"; }

  ::llvm::StringRef getDescription() const override { return "Convert floating point types using NVidia intrinsics."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFloatNvidiaPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFloatNvidiaPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFloatNvidiaPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTFLOATNVIDIAPASS
#endif // GEN_PASS_DEF_CONVERTFLOATNVIDIAPASS

//===----------------------------------------------------------------------===//
// ConvertPureCallOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_CONVERTPURECALLOPSPASS
#undef GEN_PASS_DECL_CONVERTPURECALLOPSPASS
#endif // GEN_PASS_DECL_CONVERTPURECALLOPSPASS
#ifdef GEN_PASS_DEF_CONVERTPURECALLOPSPASS
namespace impl {

template <typename DerivedT>
class ConvertPureCallOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertPureCallOpsPassBase;

  ConvertPureCallOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertPureCallOpsPassBase(const ConvertPureCallOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ConvertPureCallOpsPassBase& operator=(const ConvertPureCallOpsPassBase &) = delete;
  ConvertPureCallOpsPassBase(ConvertPureCallOpsPassBase &&) = delete;
  ConvertPureCallOpsPassBase& operator=(ConvertPureCallOpsPassBase &&) = delete;
  ~ConvertPureCallOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-pure-call-ops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-pure-call-ops"; }

  ::llvm::StringRef getDescription() const override { return "Converts xla_gpu.pure_call to func.call"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertPureCallOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertPureCallOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertPureCallOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_CONVERTPURECALLOPSPASS
#endif // GEN_PASS_DEF_CONVERTPURECALLOPSPASS

//===----------------------------------------------------------------------===//
// EraseDeadFunctionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_ERASEDEADFUNCTIONSPASS
#undef GEN_PASS_DECL_ERASEDEADFUNCTIONSPASS
#endif // GEN_PASS_DECL_ERASEDEADFUNCTIONSPASS
#ifdef GEN_PASS_DEF_ERASEDEADFUNCTIONSPASS
namespace impl {

template <typename DerivedT>
class EraseDeadFunctionsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = EraseDeadFunctionsPassBase;

  EraseDeadFunctionsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  EraseDeadFunctionsPassBase(const EraseDeadFunctionsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  EraseDeadFunctionsPassBase& operator=(const EraseDeadFunctionsPassBase &) = delete;
  EraseDeadFunctionsPassBase(EraseDeadFunctionsPassBase &&) = delete;
  EraseDeadFunctionsPassBase& operator=(EraseDeadFunctionsPassBase &&) = delete;
  ~EraseDeadFunctionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-erase-dead-functions");
  }
  ::llvm::StringRef getArgument() const override { return "xla-erase-dead-functions"; }

  ::llvm::StringRef getDescription() const override { return "Deletes unused functions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EraseDeadFunctionsPass");
  }
  ::llvm::StringRef getName() const override { return "EraseDeadFunctionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EraseDeadFunctionsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_ERASEDEADFUNCTIONSPASS
#endif // GEN_PASS_DEF_ERASEDEADFUNCTIONSPASS

//===----------------------------------------------------------------------===//
// ExpandFloatOpsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXPANDFLOATOPSPASS
#undef GEN_PASS_DECL_EXPANDFLOATOPSPASS
#endif // GEN_PASS_DECL_EXPANDFLOATOPSPASS
#ifdef GEN_PASS_DEF_EXPANDFLOATOPSPASS
namespace impl {

template <typename DerivedT>
class ExpandFloatOpsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExpandFloatOpsPassBase;

  ExpandFloatOpsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandFloatOpsPassBase(const ExpandFloatOpsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ExpandFloatOpsPassBase& operator=(const ExpandFloatOpsPassBase &) = delete;
  ExpandFloatOpsPassBase(ExpandFloatOpsPassBase &&) = delete;
  ExpandFloatOpsPassBase& operator=(ExpandFloatOpsPassBase &&) = delete;
  ~ExpandFloatOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-expand-float-ops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-expand-float-ops"; }

  ::llvm::StringRef getDescription() const override { return "Expands float ops that are not natively supported."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandFloatOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandFloatOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
    registry.insert<mlir::mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandFloatOpsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_EXPANDFLOATOPSPASS
#endif // GEN_PASS_DEF_EXPANDFLOATOPSPASS

//===----------------------------------------------------------------------===//
// FlattenTensorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_FLATTENTENSORSPASS
#undef GEN_PASS_DECL_FLATTENTENSORSPASS
#endif // GEN_PASS_DECL_FLATTENTENSORSPASS
#ifdef GEN_PASS_DEF_FLATTENTENSORSPASS
namespace impl {

template <typename DerivedT>
class FlattenTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = FlattenTensorsPassBase;

  FlattenTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FlattenTensorsPassBase(const FlattenTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  FlattenTensorsPassBase& operator=(const FlattenTensorsPassBase &) = delete;
  FlattenTensorsPassBase(FlattenTensorsPassBase &&) = delete;
  FlattenTensorsPassBase& operator=(FlattenTensorsPassBase &&) = delete;
  ~FlattenTensorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-flatten-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-flatten-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Flatten tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FlattenTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "FlattenTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FlattenTensorsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_FLATTENTENSORSPASS
#endif // GEN_PASS_DEF_FLATTENTENSORSPASS

//===----------------------------------------------------------------------===//
// LowerTensorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERTENSORSPASS
struct LowerTensorsPassOptions {
  bool is_amd_gpu_ = false;
  std::string gpu_arch_;
};
#undef GEN_PASS_DECL_LOWERTENSORSPASS
#endif // GEN_PASS_DECL_LOWERTENSORSPASS
#ifdef GEN_PASS_DEF_LOWERTENSORSPASS
namespace impl {

template <typename DerivedT>
class LowerTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerTensorsPassBase;

  LowerTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerTensorsPassBase(const LowerTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerTensorsPassBase& operator=(const LowerTensorsPassBase &) = delete;
  LowerTensorsPassBase(LowerTensorsPassBase &&) = delete;
  LowerTensorsPassBase& operator=(LowerTensorsPassBase &&) = delete;
  ~LowerTensorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Lowers tensors to llvm pointers and loads/stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "LowerTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerTensorsPassBase<DerivedT>)

  LowerTensorsPassBase(const LowerTensorsPassOptions &options) : LowerTensorsPassBase() {
    is_amd_gpu_ = options.is_amd_gpu_;
    gpu_arch_ = options.gpu_arch_;
  }
protected:
  ::mlir::Pass::Option<bool> is_amd_gpu_{*this, "is_amd_gpu", ::llvm::cl::desc("True if AMD GPU."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<std::string> gpu_arch_{*this, "gpu_arch", ::llvm::cl::desc("CUDA or ROCm compute capability.")};
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERTENSORSPASS
#endif // GEN_PASS_DEF_LOWERTENSORSPASS

//===----------------------------------------------------------------------===//
// LowerToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERTOLLVMPASS
struct LowerToLLVMPassOptions {
  bool is_amd_gpu_ = false;
};
std::unique_ptr<::mlir::Pass> createLowerToLLVMPass();
std::unique_ptr<::mlir::Pass> createLowerToLLVMPass(const LowerToLLVMPassOptions &options);
#undef GEN_PASS_DECL_LOWERTOLLVMPASS
#endif // GEN_PASS_DECL_LOWERTOLLVMPASS
#ifdef GEN_PASS_DEF_LOWERTOLLVMPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createLowerToLLVMPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createLowerToLLVMPass(const LowerToLLVMPassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class LowerToLLVMPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerToLLVMPassBase;

  LowerToLLVMPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerToLLVMPassBase(const LowerToLLVMPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerToLLVMPassBase& operator=(const LowerToLLVMPassBase &) = delete;
  LowerToLLVMPassBase(LowerToLLVMPassBase &&) = delete;
  LowerToLLVMPassBase& operator=(LowerToLLVMPassBase &&) = delete;
  ~LowerToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lowers to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "LowerToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerToLLVMPassBase<DerivedT>)

  LowerToLLVMPassBase(const LowerToLLVMPassOptions &options) : LowerToLLVMPassBase() {
    is_amd_gpu_ = options.is_amd_gpu_;
  }
protected:
  ::mlir::Pass::Option<bool> is_amd_gpu_{*this, "is_amd_gpu", ::llvm::cl::desc("True if AMD GPU."), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createLowerToLLVMPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createLowerToLLVMPass(const LowerToLLVMPassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createLowerToLLVMPass() {
  return impl::createLowerToLLVMPass();
}

std::unique_ptr<::mlir::Pass> createLowerToLLVMPass(const LowerToLLVMPassOptions &options) {
  return impl::createLowerToLLVMPass(options);
}
#undef GEN_PASS_DEF_LOWERTOLLVMPASS
#endif // GEN_PASS_DEF_LOWERTOLLVMPASS

//===----------------------------------------------------------------------===//
// LowerXlaGpuLoopsToScfPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERXLAGPULOOPSTOSCFPASS
#undef GEN_PASS_DECL_LOWERXLAGPULOOPSTOSCFPASS
#endif // GEN_PASS_DECL_LOWERXLAGPULOOPSTOSCFPASS
#ifdef GEN_PASS_DEF_LOWERXLAGPULOOPSTOSCFPASS
namespace impl {

template <typename DerivedT>
class LowerXlaGpuLoopsToScfPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerXlaGpuLoopsToScfPassBase;

  LowerXlaGpuLoopsToScfPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerXlaGpuLoopsToScfPassBase(const LowerXlaGpuLoopsToScfPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LowerXlaGpuLoopsToScfPassBase& operator=(const LowerXlaGpuLoopsToScfPassBase &) = delete;
  LowerXlaGpuLoopsToScfPassBase(LowerXlaGpuLoopsToScfPassBase &&) = delete;
  LowerXlaGpuLoopsToScfPassBase& operator=(LowerXlaGpuLoopsToScfPassBase &&) = delete;
  ~LowerXlaGpuLoopsToScfPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-xla-gpu-loops-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-xla-gpu-loops-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lowers xla_gpu.loop to SCF."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerXlaGpuLoopsToScfPass");
  }
  ::llvm::StringRef getName() const override { return "LowerXlaGpuLoopsToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerXlaGpuLoopsToScfPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERXLAGPULOOPSTOSCFPASS
#endif // GEN_PASS_DEF_LOWERXLAGPULOOPSTOSCFPASS

//===----------------------------------------------------------------------===//
// LowerXlaGpuToScfPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERXLAGPUTOSCFPASS
#undef GEN_PASS_DECL_LOWERXLAGPUTOSCFPASS
#endif // GEN_PASS_DECL_LOWERXLAGPUTOSCFPASS
#ifdef GEN_PASS_DEF_LOWERXLAGPUTOSCFPASS
namespace impl {

template <typename DerivedT>
class LowerXlaGpuToScfPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerXlaGpuToScfPassBase;

  LowerXlaGpuToScfPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerXlaGpuToScfPassBase(const LowerXlaGpuToScfPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LowerXlaGpuToScfPassBase& operator=(const LowerXlaGpuToScfPassBase &) = delete;
  LowerXlaGpuToScfPassBase(LowerXlaGpuToScfPassBase &&) = delete;
  LowerXlaGpuToScfPassBase& operator=(LowerXlaGpuToScfPassBase &&) = delete;
  ~LowerXlaGpuToScfPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-xla-gpu-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-xla-gpu-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lowers xla_gpu to SCF."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerXlaGpuToScfPass");
  }
  ::llvm::StringRef getName() const override { return "LowerXlaGpuToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerXlaGpuToScfPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERXLAGPUTOSCFPASS
#endif // GEN_PASS_DEF_LOWERXLAGPUTOSCFPASS

//===----------------------------------------------------------------------===//
// MergePointersToSameSlicePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MERGEPOINTERSTOSAMESLICEPASS
#undef GEN_PASS_DECL_MERGEPOINTERSTOSAMESLICEPASS
#endif // GEN_PASS_DECL_MERGEPOINTERSTOSAMESLICEPASS
#ifdef GEN_PASS_DEF_MERGEPOINTERSTOSAMESLICEPASS
namespace impl {

template <typename DerivedT>
class MergePointersToSameSlicePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = MergePointersToSameSlicePassBase;

  MergePointersToSameSlicePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergePointersToSameSlicePassBase(const MergePointersToSameSlicePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  MergePointersToSameSlicePassBase& operator=(const MergePointersToSameSlicePassBase &) = delete;
  MergePointersToSameSlicePassBase(MergePointersToSameSlicePassBase &&) = delete;
  MergePointersToSameSlicePassBase& operator=(MergePointersToSameSlicePassBase &&) = delete;
  ~MergePointersToSameSlicePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-merge-pointers");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-merge-pointers"; }

  ::llvm::StringRef getDescription() const override { return "Merges pointers that share slices."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergePointersToSameSlicePass");
  }
  ::llvm::StringRef getName() const override { return "MergePointersToSameSlicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergePointersToSameSlicePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MERGEPOINTERSTOSAMESLICEPASS
#endif // GEN_PASS_DEF_MERGEPOINTERSTOSAMESLICEPASS

//===----------------------------------------------------------------------===//
// OptimizeLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_OPTIMIZELOOPSPASS
#undef GEN_PASS_DECL_OPTIMIZELOOPSPASS
#endif // GEN_PASS_DECL_OPTIMIZELOOPSPASS
#ifdef GEN_PASS_DEF_OPTIMIZELOOPSPASS
namespace impl {

template <typename DerivedT>
class OptimizeLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OptimizeLoopsPassBase;

  OptimizeLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeLoopsPassBase(const OptimizeLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  OptimizeLoopsPassBase& operator=(const OptimizeLoopsPassBase &) = delete;
  OptimizeLoopsPassBase(OptimizeLoopsPassBase &&) = delete;
  OptimizeLoopsPassBase& operator=(OptimizeLoopsPassBase &&) = delete;
  ~OptimizeLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-optimize-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-optimize-loops"; }

  ::llvm::StringRef getDescription() const override { return "Unrolls and pipelines loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_OPTIMIZELOOPSPASS
#endif // GEN_PASS_DEF_OPTIMIZELOOPSPASS

//===----------------------------------------------------------------------===//
// PeelLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PEELLOOPSPASS
#undef GEN_PASS_DECL_PEELLOOPSPASS
#endif // GEN_PASS_DECL_PEELLOOPSPASS
#ifdef GEN_PASS_DEF_PEELLOOPSPASS
namespace impl {

template <typename DerivedT>
class PeelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PeelLoopsPassBase;

  PeelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PeelLoopsPassBase(const PeelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PeelLoopsPassBase& operator=(const PeelLoopsPassBase &) = delete;
  PeelLoopsPassBase(PeelLoopsPassBase &&) = delete;
  PeelLoopsPassBase& operator=(PeelLoopsPassBase &&) = delete;
  ~PeelLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-peel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-peel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Peels xla_gpu.loop."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PeelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "PeelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PeelLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PEELLOOPSPASS
#endif // GEN_PASS_DEF_PEELLOOPSPASS

//===----------------------------------------------------------------------===//
// PropagateSliceIndicesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROPAGATESLICEINDICESPASS
#undef GEN_PASS_DECL_PROPAGATESLICEINDICESPASS
#endif // GEN_PASS_DECL_PROPAGATESLICEINDICESPASS
#ifdef GEN_PASS_DEF_PROPAGATESLICEINDICESPASS
namespace impl {

template <typename DerivedT>
class PropagateSliceIndicesPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = PropagateSliceIndicesPassBase;

  PropagateSliceIndicesPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateSliceIndicesPassBase(const PropagateSliceIndicesPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  PropagateSliceIndicesPassBase& operator=(const PropagateSliceIndicesPassBase &) = delete;
  PropagateSliceIndicesPassBase(PropagateSliceIndicesPassBase &&) = delete;
  PropagateSliceIndicesPassBase& operator=(PropagateSliceIndicesPassBase &&) = delete;
  ~PropagateSliceIndicesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-propagate-slice-indices");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-propagate-slice-indices"; }

  ::llvm::StringRef getDescription() const override { return "Propagates slice indices from the entry function to all callees."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateSliceIndicesPass");
  }
  ::llvm::StringRef getName() const override { return "PropagateSliceIndicesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateSliceIndicesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROPAGATESLICEINDICESPASS
#endif // GEN_PASS_DEF_PROPAGATESLICEINDICESPASS

//===----------------------------------------------------------------------===//
// RewriteReductionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_REWRITEREDUCTIONSPASS
#undef GEN_PASS_DECL_REWRITEREDUCTIONSPASS
#endif // GEN_PASS_DECL_REWRITEREDUCTIONSPASS
#ifdef GEN_PASS_DEF_REWRITEREDUCTIONSPASS
namespace impl {

template <typename DerivedT>
class RewriteReductionsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteReductionsPassBase;

  RewriteReductionsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteReductionsPassBase(const RewriteReductionsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  RewriteReductionsPassBase& operator=(const RewriteReductionsPassBase &) = delete;
  RewriteReductionsPassBase(RewriteReductionsPassBase &&) = delete;
  RewriteReductionsPassBase& operator=(RewriteReductionsPassBase &&) = delete;
  ~RewriteReductionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-rewrite-reductions");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-rewrite-reductions"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites reductions to pieces that can efficiently be emitted."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteReductionsPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteReductionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteReductionsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_REWRITEREDUCTIONSPASS
#endif // GEN_PASS_DEF_REWRITEREDUCTIONSPASS

//===----------------------------------------------------------------------===//
// SimplifyAffinePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLIFYAFFINEPASS
#undef GEN_PASS_DECL_SIMPLIFYAFFINEPASS
#endif // GEN_PASS_DECL_SIMPLIFYAFFINEPASS
#ifdef GEN_PASS_DEF_SIMPLIFYAFFINEPASS
namespace impl {

template <typename DerivedT>
class SimplifyAffinePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyAffinePassBase;

  SimplifyAffinePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyAffinePassBase(const SimplifyAffinePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  SimplifyAffinePassBase& operator=(const SimplifyAffinePassBase &) = delete;
  SimplifyAffinePassBase(SimplifyAffinePassBase &&) = delete;
  SimplifyAffinePassBase& operator=(SimplifyAffinePassBase &&) = delete;
  ~SimplifyAffinePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-simplify-affine");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-simplify-affine"; }

  ::llvm::StringRef getDescription() const override { return "Simplifies affine.apply using XLA's range-aware simplifier."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyAffinePass");
  }
  ::llvm::StringRef getName() const override { return "SimplifyAffinePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::affine::AffineDialect>();
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyAffinePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLIFYAFFINEPASS
#endif // GEN_PASS_DEF_SIMPLIFYAFFINEPASS

//===----------------------------------------------------------------------===//
// SimplifyArithPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLIFYARITHPASS
#undef GEN_PASS_DECL_SIMPLIFYARITHPASS
#endif // GEN_PASS_DECL_SIMPLIFYARITHPASS
#ifdef GEN_PASS_DEF_SIMPLIFYARITHPASS
namespace impl {

template <typename DerivedT>
class SimplifyArithPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SimplifyArithPassBase;

  SimplifyArithPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyArithPassBase(const SimplifyArithPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  SimplifyArithPassBase& operator=(const SimplifyArithPassBase &) = delete;
  SimplifyArithPassBase(SimplifyArithPassBase &&) = delete;
  SimplifyArithPassBase& operator=(SimplifyArithPassBase &&) = delete;
  ~SimplifyArithPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-simplify-arith");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-simplify-arith"; }

  ::llvm::StringRef getDescription() const override { return "Simplifies arith using XLA's range-aware simplifier."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyArithPass");
  }
  ::llvm::StringRef getName() const override { return "SimplifyArithPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyArithPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLIFYARITHPASS
#endif // GEN_PASS_DEF_SIMPLIFYARITHPASS

//===----------------------------------------------------------------------===//
// UnswitchLoopsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_UNSWITCHLOOPSPASS
#undef GEN_PASS_DECL_UNSWITCHLOOPSPASS
#endif // GEN_PASS_DECL_UNSWITCHLOOPSPASS
#ifdef GEN_PASS_DEF_UNSWITCHLOOPSPASS
namespace impl {

template <typename DerivedT>
class UnswitchLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = UnswitchLoopsPassBase;

  UnswitchLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  UnswitchLoopsPassBase(const UnswitchLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  UnswitchLoopsPassBase& operator=(const UnswitchLoopsPassBase &) = delete;
  UnswitchLoopsPassBase(UnswitchLoopsPassBase &&) = delete;
  UnswitchLoopsPassBase& operator=(UnswitchLoopsPassBase &&) = delete;
  ~UnswitchLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-unswitch-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-unswitch-loops"; }

  ::llvm::StringRef getDescription() const override { return "Swaps scf.if and scf.for."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnswitchLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "UnswitchLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnswitchLoopsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_UNSWITCHLOOPSPASS
#endif // GEN_PASS_DEF_UNSWITCHLOOPSPASS

//===----------------------------------------------------------------------===//
// VectorizeLoadsAndStoresPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_VECTORIZELOADSANDSTORESPASS
#undef GEN_PASS_DECL_VECTORIZELOADSANDSTORESPASS
#endif // GEN_PASS_DECL_VECTORIZELOADSANDSTORESPASS
#ifdef GEN_PASS_DEF_VECTORIZELOADSANDSTORESPASS
namespace impl {

template <typename DerivedT>
class VectorizeLoadsAndStoresPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeLoadsAndStoresPassBase;

  VectorizeLoadsAndStoresPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeLoadsAndStoresPassBase(const VectorizeLoadsAndStoresPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  VectorizeLoadsAndStoresPassBase& operator=(const VectorizeLoadsAndStoresPassBase &) = delete;
  VectorizeLoadsAndStoresPassBase(VectorizeLoadsAndStoresPassBase &&) = delete;
  VectorizeLoadsAndStoresPassBase& operator=(VectorizeLoadsAndStoresPassBase &&) = delete;
  ~VectorizeLoadsAndStoresPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-vectorize-loads-stores");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-vectorize-loads-stores"; }

  ::llvm::StringRef getDescription() const override { return "Vectorizes loads and stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeLoadsAndStoresPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeLoadsAndStoresPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeLoadsAndStoresPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_VECTORIZELOADSANDSTORESPASS
#endif // GEN_PASS_DEF_VECTORIZELOADSANDSTORESPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ConvertFloatNvidiaPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertFloatNvidiaPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertFloatNvidiaPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertFloatNvidiaPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertFloatNvidiaPass();
  });
}

//===----------------------------------------------------------------------===//
// ConvertPureCallOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerConvertPureCallOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertPureCallOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerConvertPureCallOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateConvertPureCallOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// EraseDeadFunctionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerEraseDeadFunctionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateEraseDeadFunctionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerEraseDeadFunctionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateEraseDeadFunctionsPass();
  });
}

//===----------------------------------------------------------------------===//
// ExpandFloatOpsPass Registration
//===----------------------------------------------------------------------===//

inline void registerExpandFloatOpsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExpandFloatOpsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExpandFloatOpsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateExpandFloatOpsPass();
  });
}

//===----------------------------------------------------------------------===//
// FlattenTensorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerFlattenTensorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFlattenTensorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerFlattenTensorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateFlattenTensorsPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerTensorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerTensorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerTensorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerTensorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerTensorsPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createLowerToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerXlaGpuLoopsToScfPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerXlaGpuLoopsToScfPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXlaGpuLoopsToScfPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerXlaGpuLoopsToScfPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXlaGpuLoopsToScfPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerXlaGpuToScfPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerXlaGpuToScfPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXlaGpuToScfPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerXlaGpuToScfPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerXlaGpuToScfPass();
  });
}

//===----------------------------------------------------------------------===//
// MergePointersToSameSlicePass Registration
//===----------------------------------------------------------------------===//

inline void registerMergePointersToSameSlicePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateMergePointersToSameSlicePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMergePointersToSameSlicePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateMergePointersToSameSlicePass();
  });
}

//===----------------------------------------------------------------------===//
// OptimizeLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerOptimizeLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateOptimizeLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerOptimizeLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateOptimizeLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// PeelLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPeelLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePeelLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPeelLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePeelLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// PropagateSliceIndicesPass Registration
//===----------------------------------------------------------------------===//

inline void registerPropagateSliceIndicesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePropagateSliceIndicesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPropagateSliceIndicesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePropagateSliceIndicesPass();
  });
}

//===----------------------------------------------------------------------===//
// RewriteReductionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerRewriteReductionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRewriteReductionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerRewriteReductionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateRewriteReductionsPass();
  });
}

//===----------------------------------------------------------------------===//
// SimplifyAffinePass Registration
//===----------------------------------------------------------------------===//

inline void registerSimplifyAffinePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateSimplifyAffinePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimplifyAffinePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateSimplifyAffinePass();
  });
}

//===----------------------------------------------------------------------===//
// SimplifyArithPass Registration
//===----------------------------------------------------------------------===//

inline void registerSimplifyArithPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateSimplifyArithPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimplifyArithPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateSimplifyArithPass();
  });
}

//===----------------------------------------------------------------------===//
// UnswitchLoopsPass Registration
//===----------------------------------------------------------------------===//

inline void registerUnswitchLoopsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateUnswitchLoopsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerUnswitchLoopsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateUnswitchLoopsPass();
  });
}

//===----------------------------------------------------------------------===//
// VectorizeLoadsAndStoresPass Registration
//===----------------------------------------------------------------------===//

inline void registerVectorizeLoadsAndStoresPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateVectorizeLoadsAndStoresPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerVectorizeLoadsAndStoresPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateVectorizeLoadsAndStoresPass();
  });
}

//===----------------------------------------------------------------------===//
// GpuFusionTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerGpuFusionTransformsPasses() {
  registerConvertFloatNvidiaPass();
  registerConvertPureCallOpsPass();
  registerEraseDeadFunctionsPass();
  registerExpandFloatOpsPass();
  registerFlattenTensorsPass();
  registerLowerTensorsPass();
  registerLowerToLLVMPass();
  registerLowerXlaGpuLoopsToScfPass();
  registerLowerXlaGpuToScfPass();
  registerMergePointersToSameSlicePass();
  registerOptimizeLoopsPass();
  registerPeelLoopsPass();
  registerPropagateSliceIndicesPass();
  registerRewriteReductionsPass();
  registerSimplifyAffinePass();
  registerSimplifyArithPass();
  registerUnswitchLoopsPass();
  registerVectorizeLoadsAndStoresPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ConvertFloatNvidiaPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ConvertFloatNvidiaPassBase;

  ConvertFloatNvidiaPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertFloatNvidiaPassBase(const ConvertFloatNvidiaPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ConvertFloatNvidiaPassBase& operator=(const ConvertFloatNvidiaPassBase &) = delete;
  ConvertFloatNvidiaPassBase(ConvertFloatNvidiaPassBase &&) = delete;
  ConvertFloatNvidiaPassBase& operator=(ConvertFloatNvidiaPassBase &&) = delete;
  ~ConvertFloatNvidiaPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-float-nvidia");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-float-nvidia"; }

  ::llvm::StringRef getDescription() const override { return "Convert floating point types using NVidia intrinsics."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertFloatNvidiaPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertFloatNvidiaPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::arith::ArithDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertFloatNvidiaPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ConvertPureCallOpsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = ConvertPureCallOpsPassBase;

  ConvertPureCallOpsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  ConvertPureCallOpsPassBase(const ConvertPureCallOpsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  ConvertPureCallOpsPassBase& operator=(const ConvertPureCallOpsPassBase &) = delete;
  ConvertPureCallOpsPassBase(ConvertPureCallOpsPassBase &&) = delete;
  ConvertPureCallOpsPassBase& operator=(ConvertPureCallOpsPassBase &&) = delete;
  ~ConvertPureCallOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-convert-pure-call-ops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-convert-pure-call-ops"; }

  ::llvm::StringRef getDescription() const override { return "Converts xla_gpu.pure_call to func.call"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ConvertPureCallOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ConvertPureCallOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ConvertPureCallOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class EraseDeadFunctionsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = EraseDeadFunctionsPassBase;

  EraseDeadFunctionsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  EraseDeadFunctionsPassBase(const EraseDeadFunctionsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  EraseDeadFunctionsPassBase& operator=(const EraseDeadFunctionsPassBase &) = delete;
  EraseDeadFunctionsPassBase(EraseDeadFunctionsPassBase &&) = delete;
  EraseDeadFunctionsPassBase& operator=(EraseDeadFunctionsPassBase &&) = delete;
  ~EraseDeadFunctionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-erase-dead-functions");
  }
  ::llvm::StringRef getArgument() const override { return "xla-erase-dead-functions"; }

  ::llvm::StringRef getDescription() const override { return "Deletes unused functions"; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("EraseDeadFunctionsPass");
  }
  ::llvm::StringRef getName() const override { return "EraseDeadFunctionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(EraseDeadFunctionsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class ExpandFloatOpsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExpandFloatOpsPassBase;

  ExpandFloatOpsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandFloatOpsPassBase(const ExpandFloatOpsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  ExpandFloatOpsPassBase& operator=(const ExpandFloatOpsPassBase &) = delete;
  ExpandFloatOpsPassBase(ExpandFloatOpsPassBase &&) = delete;
  ExpandFloatOpsPassBase& operator=(ExpandFloatOpsPassBase &&) = delete;
  ~ExpandFloatOpsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-expand-float-ops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-expand-float-ops"; }

  ::llvm::StringRef getDescription() const override { return "Expands float ops that are not natively supported."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandFloatOpsPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandFloatOpsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::math::MathDialect>();
    registry.insert<mlir::mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandFloatOpsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class FlattenTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = FlattenTensorsPassBase;

  FlattenTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  FlattenTensorsPassBase(const FlattenTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  FlattenTensorsPassBase& operator=(const FlattenTensorsPassBase &) = delete;
  FlattenTensorsPassBase(FlattenTensorsPassBase &&) = delete;
  FlattenTensorsPassBase& operator=(FlattenTensorsPassBase &&) = delete;
  ~FlattenTensorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-flatten-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-flatten-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Flatten tensors."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("FlattenTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "FlattenTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(FlattenTensorsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerTensorsPassBase;

  LowerTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerTensorsPassBase(const LowerTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerTensorsPassBase& operator=(const LowerTensorsPassBase &) = delete;
  LowerTensorsPassBase(LowerTensorsPassBase &&) = delete;
  LowerTensorsPassBase& operator=(LowerTensorsPassBase &&) = delete;
  ~LowerTensorsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Lowers tensors to llvm pointers and loads/stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "LowerTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerTensorsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> is_amd_gpu_{*this, "is_amd_gpu", ::llvm::cl::desc("True if AMD GPU."), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<std::string> gpu_arch_{*this, "gpu_arch", ::llvm::cl::desc("CUDA or ROCm compute capability.")};
};

template <typename DerivedT>
class LowerToLLVMPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerToLLVMPassBase;

  LowerToLLVMPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerToLLVMPassBase(const LowerToLLVMPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  LowerToLLVMPassBase& operator=(const LowerToLLVMPassBase &) = delete;
  LowerToLLVMPassBase(LowerToLLVMPassBase &&) = delete;
  LowerToLLVMPassBase& operator=(LowerToLLVMPassBase &&) = delete;
  ~LowerToLLVMPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lowers to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "LowerToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::NVVM::NVVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerToLLVMPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> is_amd_gpu_{*this, "is_amd_gpu", ::llvm::cl::desc("True if AMD GPU."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class LowerXlaGpuLoopsToScfPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerXlaGpuLoopsToScfPassBase;

  LowerXlaGpuLoopsToScfPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerXlaGpuLoopsToScfPassBase(const LowerXlaGpuLoopsToScfPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LowerXlaGpuLoopsToScfPassBase& operator=(const LowerXlaGpuLoopsToScfPassBase &) = delete;
  LowerXlaGpuLoopsToScfPassBase(LowerXlaGpuLoopsToScfPassBase &&) = delete;
  LowerXlaGpuLoopsToScfPassBase& operator=(LowerXlaGpuLoopsToScfPassBase &&) = delete;
  ~LowerXlaGpuLoopsToScfPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-xla-gpu-loops-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-xla-gpu-loops-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lowers xla_gpu.loop to SCF."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerXlaGpuLoopsToScfPass");
  }
  ::llvm::StringRef getName() const override { return "LowerXlaGpuLoopsToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerXlaGpuLoopsToScfPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerXlaGpuToScfPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = LowerXlaGpuToScfPassBase;

  LowerXlaGpuToScfPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerXlaGpuToScfPassBase(const LowerXlaGpuToScfPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  LowerXlaGpuToScfPassBase& operator=(const LowerXlaGpuToScfPassBase &) = delete;
  LowerXlaGpuToScfPassBase(LowerXlaGpuToScfPassBase &&) = delete;
  LowerXlaGpuToScfPassBase& operator=(LowerXlaGpuToScfPassBase &&) = delete;
  ~LowerXlaGpuToScfPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-xla-gpu-to-scf");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-xla-gpu-to-scf"; }

  ::llvm::StringRef getDescription() const override { return "Lowers xla_gpu to SCF."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerXlaGpuToScfPass");
  }
  ::llvm::StringRef getName() const override { return "LowerXlaGpuToScfPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::scf::SCFDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerXlaGpuToScfPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MergePointersToSameSlicePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = MergePointersToSameSlicePassBase;

  MergePointersToSameSlicePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergePointersToSameSlicePassBase(const MergePointersToSameSlicePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  MergePointersToSameSlicePassBase& operator=(const MergePointersToSameSlicePassBase &) = delete;
  MergePointersToSameSlicePassBase(MergePointersToSameSlicePassBase &&) = delete;
  MergePointersToSameSlicePassBase& operator=(MergePointersToSameSlicePassBase &&) = delete;
  ~MergePointersToSameSlicePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-merge-pointers");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-merge-pointers"; }

  ::llvm::StringRef getDescription() const override { return "Merges pointers that share slices."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergePointersToSameSlicePass");
  }
  ::llvm::StringRef getName() const override { return "MergePointersToSameSlicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergePointersToSameSlicePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class OptimizeLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = OptimizeLoopsPassBase;

  OptimizeLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  OptimizeLoopsPassBase(const OptimizeLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  OptimizeLoopsPassBase& operator=(const OptimizeLoopsPassBase &) = delete;
  OptimizeLoopsPassBase(OptimizeLoopsPassBase &&) = delete;
  OptimizeLoopsPassBase& operator=(OptimizeLoopsPassBase &&) = delete;
  ~OptimizeLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-optimize-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-optimize-loops"; }

  ::llvm::StringRef getDescription() const override { return "Unrolls and pipelines loops."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("OptimizeLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "OptimizeLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(OptimizeLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PeelLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = PeelLoopsPassBase;

  PeelLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  PeelLoopsPassBase(const PeelLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  PeelLoopsPassBase& operator=(const PeelLoopsPassBase &) = delete;
  PeelLoopsPassBase(PeelLoopsPassBase &&) = delete;
  PeelLoopsPassBase& operator=(PeelLoopsPassBase &&) = delete;
  ~PeelLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-peel-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-peel-loops"; }

  ::llvm::StringRef getDescription() const override { return "Peels xla_gpu.loop."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PeelLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "PeelLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PeelLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PropagateSliceIndicesPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = PropagateSliceIndicesPassBase;

  PropagateSliceIndicesPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateSliceIndicesPassBase(const PropagateSliceIndicesPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  PropagateSliceIndicesPassBase& operator=(const PropagateSliceIndicesPassBase &) = delete;
  PropagateSliceIndicesPassBase(PropagateSliceIndicesPassBase &&) = delete;
  PropagateSliceIndicesPassBase& operator=(PropagateSliceIndicesPassBase &&) = delete;
  ~PropagateSliceIndicesPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-propagate-slice-indices");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-propagate-slice-indices"; }

  ::llvm::StringRef getDescription() const override { return "Propagates slice indices from the entry function to all callees."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateSliceIndicesPass");
  }
  ::llvm::StringRef getName() const override { return "PropagateSliceIndicesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateSliceIndicesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class RewriteReductionsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = RewriteReductionsPassBase;

  RewriteReductionsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  RewriteReductionsPassBase(const RewriteReductionsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  RewriteReductionsPassBase& operator=(const RewriteReductionsPassBase &) = delete;
  RewriteReductionsPassBase(RewriteReductionsPassBase &&) = delete;
  RewriteReductionsPassBase& operator=(RewriteReductionsPassBase &&) = delete;
  ~RewriteReductionsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-rewrite-reductions");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-rewrite-reductions"; }

  ::llvm::StringRef getDescription() const override { return "Rewrites reductions to pieces that can efficiently be emitted."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("RewriteReductionsPass");
  }
  ::llvm::StringRef getName() const override { return "RewriteReductionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(RewriteReductionsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SimplifyAffinePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyAffinePassBase;

  SimplifyAffinePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyAffinePassBase(const SimplifyAffinePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}
  SimplifyAffinePassBase& operator=(const SimplifyAffinePassBase &) = delete;
  SimplifyAffinePassBase(SimplifyAffinePassBase &&) = delete;
  SimplifyAffinePassBase& operator=(SimplifyAffinePassBase &&) = delete;
  ~SimplifyAffinePassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-simplify-affine");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-simplify-affine"; }

  ::llvm::StringRef getDescription() const override { return "Simplifies affine.apply using XLA's range-aware simplifier."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyAffinePass");
  }
  ::llvm::StringRef getName() const override { return "SimplifyAffinePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::affine::AffineDialect>();
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyAffinePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SimplifyArithPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = SimplifyArithPassBase;

  SimplifyArithPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyArithPassBase(const SimplifyArithPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  SimplifyArithPassBase& operator=(const SimplifyArithPassBase &) = delete;
  SimplifyArithPassBase(SimplifyArithPassBase &&) = delete;
  SimplifyArithPassBase& operator=(SimplifyArithPassBase &&) = delete;
  ~SimplifyArithPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-simplify-arith");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-simplify-arith"; }

  ::llvm::StringRef getDescription() const override { return "Simplifies arith using XLA's range-aware simplifier."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyArithPass");
  }
  ::llvm::StringRef getName() const override { return "SimplifyArithPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyArithPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class UnswitchLoopsPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = UnswitchLoopsPassBase;

  UnswitchLoopsPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  UnswitchLoopsPassBase(const UnswitchLoopsPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  UnswitchLoopsPassBase& operator=(const UnswitchLoopsPassBase &) = delete;
  UnswitchLoopsPassBase(UnswitchLoopsPassBase &&) = delete;
  UnswitchLoopsPassBase& operator=(UnswitchLoopsPassBase &&) = delete;
  ~UnswitchLoopsPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-unswitch-loops");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-unswitch-loops"; }

  ::llvm::StringRef getDescription() const override { return "Swaps scf.if and scf.for."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("UnswitchLoopsPass");
  }
  ::llvm::StringRef getName() const override { return "UnswitchLoopsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(UnswitchLoopsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class VectorizeLoadsAndStoresPassBase : public ::mlir::OperationPass<mlir::func::FuncOp> {
public:
  using Base = VectorizeLoadsAndStoresPassBase;

  VectorizeLoadsAndStoresPassBase() : ::mlir::OperationPass<mlir::func::FuncOp>(::mlir::TypeID::get<DerivedT>()) {}
  VectorizeLoadsAndStoresPassBase(const VectorizeLoadsAndStoresPassBase &other) : ::mlir::OperationPass<mlir::func::FuncOp>(other) {}
  VectorizeLoadsAndStoresPassBase& operator=(const VectorizeLoadsAndStoresPassBase &) = delete;
  VectorizeLoadsAndStoresPassBase(VectorizeLoadsAndStoresPassBase &&) = delete;
  VectorizeLoadsAndStoresPassBase& operator=(VectorizeLoadsAndStoresPassBase &&) = delete;
  ~VectorizeLoadsAndStoresPassBase() = default;

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-vectorize-loads-stores");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-vectorize-loads-stores"; }

  ::llvm::StringRef getDescription() const override { return "Vectorizes loads and stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("VectorizeLoadsAndStoresPass");
  }
  ::llvm::StringRef getName() const override { return "VectorizeLoadsAndStoresPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::vector::VectorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(VectorizeLoadsAndStoresPassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES

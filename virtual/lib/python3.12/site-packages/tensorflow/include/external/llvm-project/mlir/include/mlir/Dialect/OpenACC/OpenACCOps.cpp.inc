/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Definitions                                                             *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: OpenACCOps.td                                                        *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

#ifdef GET_OP_LIST
#undef GET_OP_LIST

::mlir::acc::AtomicCaptureOp,
::mlir::acc::AtomicReadOp,
::mlir::acc::AtomicUpdateOp,
::mlir::acc::AtomicWriteOp,
::mlir::acc::AttachOp,
::mlir::acc::CacheOp,
::mlir::acc::CopyinOp,
::mlir::acc::CopyoutOp,
::mlir::acc::CreateOp,
::mlir::acc::DataBoundsOp,
::mlir::acc::DataOp,
::mlir::acc::DeclareDeviceResidentOp,
::mlir::acc::DeclareEnterOp,
::mlir::acc::DeclareExitOp,
::mlir::acc::DeclareLinkOp,
::mlir::acc::DeclareOp,
::mlir::acc::DeleteOp,
::mlir::acc::DetachOp,
::mlir::acc::DevicePtrOp,
::mlir::acc::EnterDataOp,
::mlir::acc::ExitDataOp,
::mlir::acc::FirstprivateOp,
::mlir::acc::FirstprivateRecipeOp,
::mlir::acc::GetDevicePtrOp,
::mlir::acc::GlobalConstructorOp,
::mlir::acc::GlobalDestructorOp,
::mlir::acc::HostDataOp,
::mlir::acc::InitOp,
::mlir::acc::KernelsOp,
::mlir::acc::LoopOp,
::mlir::acc::NoCreateOp,
::mlir::acc::ParallelOp,
::mlir::acc::PresentOp,
::mlir::acc::PrivateOp,
::mlir::acc::PrivateRecipeOp,
::mlir::acc::ReductionOp,
::mlir::acc::ReductionRecipeOp,
::mlir::acc::RoutineOp,
::mlir::acc::SerialOp,
::mlir::acc::SetOp,
::mlir::acc::ShutdownOp,
::mlir::acc::TerminatorOp,
::mlir::acc::UpdateDeviceOp,
::mlir::acc::UpdateHostOp,
::mlir::acc::UpdateOp,
::mlir::acc::UseDeviceOp,
::mlir::acc::WaitOp,
::mlir::acc::YieldOp
#endif  // GET_OP_LIST

#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES


//===----------------------------------------------------------------------===//
// Local Utility Method Definitions
//===----------------------------------------------------------------------===//

namespace mlir {
namespace acc {

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps1(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::acc::PointerLikeType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be pointer-like type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps2(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be any type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps3(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::acc::PointerLikeType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be PointerLikeType instance, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps4(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::acc::DataBoundsType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be variadic of Type for representing acc data clause bounds information, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps5(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((::llvm::isa<::mlir::IntegerType>(type))) || ((::llvm::isa<::mlir::IndexType>(type))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be variadic of integer or index, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps6(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!(((::llvm::isa<::mlir::IntegerType>(type))) || ((::llvm::isa<::mlir::IndexType>(type))))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be integer or index, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps7(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::acc::DataBoundsType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be Type for representing acc data clause bounds information, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps8(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((type.isSignlessInteger(1)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be 1-bit signless integer, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps9(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::acc::PointerLikeType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be variadic of PointerLikeType instance, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps10(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((::llvm::isa<::mlir::acc::DeclareTokenType>(type)))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be declare token type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_type_constraint_OpenACCOps11(
    ::mlir::Operation *op, ::mlir::Type type, ::llvm::StringRef valueKind,
    unsigned valueIndex) {
  if (!((true))) {
    return op->emitOpError(valueKind) << " #" << valueIndex
        << " must be variadic of any type, but got " << type;
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps1(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::TypeAttr>(attr))) && ((::llvm::isa<::mlir::Type>(::llvm::cast<::mlir::TypeAttr>(attr).getValue()))) && ((true))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: any type attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps1(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps1(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps2(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: device type array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps2(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps2(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps3(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::acc::DataClauseAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: data clauses supported by OpenACC";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps3(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps3(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps4(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::BoolAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: bool attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps4(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps4(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps5(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::StringAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: string attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps5(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps5(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps6(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: i32 dense array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps6(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps6(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps7(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::BoolAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: 1-bit boolean array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps7(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps7(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps8(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::acc::ClauseDefaultValueAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: DefaultValue Clause";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps8(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps8(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps9(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::UnitAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: unit attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps9(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps9(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps10(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: Device type attributes";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps10(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps10(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps11(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::DenseBoolArrayAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: i1 dense array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps11(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps11(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps12(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && (((::llvm::isa<::mlir::IntegerAttr>(attr))) && ((::llvm::cast<::mlir::IntegerAttr>(attr).getType().isSignlessInteger(64)))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: 64-bit integer array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps12(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps12(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps13(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::GangArgTypeAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: gang arg type array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps13(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps13(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps14(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::SymbolRefAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: symbol ref array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps14(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps14(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps15(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::acc::CombinedConstructsTypeAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: Differentiate between combined constructs";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps15(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps15(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps16(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::acc::ReductionOperatorAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: built-in reduction operations supported by OpenACC";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps16(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps16(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps17(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !(((::llvm::isa<::mlir::ArrayAttr>(attr))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(attr), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::StringAttr>(attr))); }))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: string array attribute";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps17(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps17(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps18(
    ::mlir::Attribute attr, ::llvm::StringRef attrName, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  if (attr && !((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))))
    return emitError() << "attribute '" << attrName
        << "' failed to satisfy constraint: built-in device type supported by OpenACC";
  return ::mlir::success();
}
static ::llvm::LogicalResult __mlir_ods_local_attr_constraint_OpenACCOps18(
    ::mlir::Operation *op, ::mlir::Attribute attr, ::llvm::StringRef attrName) {
  return __mlir_ods_local_attr_constraint_OpenACCOps18(attr, attrName, [op]() {
    return op->emitOpError();
  });
}

static ::llvm::LogicalResult __mlir_ods_local_region_constraint_OpenACCOps1(
    ::mlir::Operation *op, ::mlir::Region &region, ::llvm::StringRef regionName,
    unsigned regionIndex) {
  if (!((::llvm::hasNItems(region, 1)))) {
    return op->emitOpError("region #") << regionIndex
        << (regionName.empty() ? " " : " ('" + regionName + "') ")
        << "failed to verify constraint: region with 1 blocks";
  }
  return ::mlir::success();
}

static ::llvm::LogicalResult __mlir_ods_local_region_constraint_OpenACCOps2(
    ::mlir::Operation *op, ::mlir::Region &region, ::llvm::StringRef regionName,
    unsigned regionIndex) {
  if (!((true))) {
    return op->emitOpError("region #") << regionIndex
        << (regionName.empty() ? " " : " ('" + regionName + "') ")
        << "failed to verify constraint: any region";
  }
  return ::mlir::success();
}
} // namespace acc
} // namespace mlir
namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AtomicCaptureOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
AtomicCaptureOpAdaptor::AtomicCaptureOpAdaptor(AtomicCaptureOp op) : AtomicCaptureOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AtomicCaptureOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AtomicCaptureOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
  (void)odsState.addRegion();
}

void AtomicCaptureOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicCaptureOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult AtomicCaptureOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps1(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult AtomicCaptureOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult AtomicCaptureOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();

  ensureTerminator(*regionRegion, parser.getBuilder(), result.location);
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
  return ::mlir::success();
}

void AtomicCaptureOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';

  {
    bool printTerminator = true;
    if (auto *term = getRegion().empty() ? nullptr : getRegion().begin()->getTerminator()) {
      printTerminator = !term->getAttrDictionary().empty() ||
                        term->getNumOperands() != 0 ||
                        term->getNumResults() != 0;
    }
    _odsPrinter.printRegion(getRegion(), /*printEntryBlockArgs=*/true,
      /*printBlockTerminators=*/printTerminator);
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::AtomicCaptureOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AtomicReadOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
AtomicReadOpGenericAdaptorBase::AtomicReadOpGenericAdaptorBase(AtomicReadOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::mlir::Type AtomicReadOpGenericAdaptorBase::getElementType() {
  auto attr = getElementTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

} // namespace detail
AtomicReadOpAdaptor::AtomicReadOpAdaptor(AtomicReadOp op) : AtomicReadOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AtomicReadOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_element_type = getProperties().element_type; (void)tblgen_element_type;
  if (!tblgen_element_type) return emitError(loc, "'acc.atomic.read' op ""requires attribute 'element_type'");

  if (tblgen_element_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_element_type))) && ((::llvm::isa<::mlir::Type>(::llvm::cast<::mlir::TypeAttr>(tblgen_element_type).getValue()))) && ((true))))
    return emitError(loc, "'acc.atomic.read' op ""attribute 'element_type' failed to satisfy constraint: any type attribute");
  return ::mlir::success();
}

::llvm::LogicalResult AtomicReadOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.element_type;
       auto attr = dict.get("element_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `element_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute AtomicReadOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.element_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("element_type",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AtomicReadOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.element_type.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> AtomicReadOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "element_type")
      return prop.element_type;
  return std::nullopt;
}

void AtomicReadOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "element_type") {
       prop.element_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.element_type)>>(value);
       return;
    }
}

void AtomicReadOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.element_type) attrs.append("element_type", prop.element_type);
}

::llvm::LogicalResult AtomicReadOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getElementTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps1(attr, "element_type", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AtomicReadOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.element_type)))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicReadOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.element_type);
}

::mlir::Type AtomicReadOp::getElementType() {
  auto attr = getElementTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

void AtomicReadOp::setElementType(::mlir::Type attrValue) {
  getProperties().element_type = ::mlir::TypeAttr::get(attrValue);
}

void AtomicReadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value v, ::mlir::TypeAttr element_type) {
  odsState.addOperands(x);
  odsState.addOperands(v);
  odsState.getOrAddProperties<Properties>().element_type = element_type;
}

void AtomicReadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value v, ::mlir::TypeAttr element_type) {
  odsState.addOperands(x);
  odsState.addOperands(v);
  odsState.getOrAddProperties<Properties>().element_type = element_type;
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicReadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value v, ::mlir::Type element_type) {
  odsState.addOperands(x);
  odsState.addOperands(v);
  odsState.getOrAddProperties<Properties>().element_type = ::mlir::TypeAttr::get(element_type);
}

void AtomicReadOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value v, ::mlir::Type element_type) {
  odsState.addOperands(x);
  odsState.addOperands(v);
  odsState.getOrAddProperties<Properties>().element_type = ::mlir::TypeAttr::get(element_type);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicReadOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AtomicReadOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult AtomicReadOp::verifyInvariantsImpl() {
  auto tblgen_element_type = getProperties().element_type; (void)tblgen_element_type;
  if (!tblgen_element_type) return emitOpError("requires attribute 'element_type'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps1(*this, tblgen_element_type, "element_type")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  if (!((((*this->getODSOperands(0).begin()).getType()) == ((*this->getODSOperands(1).begin()).getType()) && ((*this->getODSOperands(1).begin()).getType()) == ((*this->getODSOperands(0).begin()).getType()))))
    return emitOpError("failed to verify that all of {x, v} have same type");
  return ::mlir::success();
}

::llvm::LogicalResult AtomicReadOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult AtomicReadOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand vRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> vOperands(&vRawOperand, 1);  ::llvm::SMLoc vOperandsLoc;
  (void)vOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand xRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> xOperands(&xRawOperand, 1);  ::llvm::SMLoc xOperandsLoc;
  (void)xOperandsLoc;
  ::mlir::Type xRawType{};
  ::llvm::ArrayRef<::mlir::Type> xTypes(&xRawType, 1);
  ::mlir::TypeAttr element_typeAttr;

  vOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(vRawOperand))
    return ::mlir::failure();
  if (parser.parseEqual())
    return ::mlir::failure();

  xOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(xRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    xRawType = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(element_typeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (element_typeAttr) result.getOrAddProperties<AtomicReadOp::Properties>().element_type = element_typeAttr;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.resolveOperands(xOperands, xTypes, xOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(vOperands, xTypes[0], vOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicReadOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getV();
  _odsPrinter << ' ' << "=";
  _odsPrinter << ' ';
  _odsPrinter << getX();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getX().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getElementTypeAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("element_type");
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::AtomicReadOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AtomicUpdateOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
AtomicUpdateOpAdaptor::AtomicUpdateOpAdaptor(AtomicUpdateOp op) : AtomicUpdateOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AtomicUpdateOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AtomicUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x) {
  odsState.addOperands(x);
  (void)odsState.addRegion();
}

void AtomicUpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x) {
  odsState.addOperands(x);
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicUpdateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult AtomicUpdateOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps1(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult AtomicUpdateOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

void AtomicUpdateOp::getCanonicalizationPatterns(::mlir::RewritePatternSet &results, ::mlir::MLIRContext *context) {
  results.add(canonicalize);
}

::mlir::ParseResult AtomicUpdateOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand xRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> xOperands(&xRawOperand, 1);  ::llvm::SMLoc xOperandsLoc;
  (void)xOperandsLoc;
  ::mlir::Type xRawType{};
  ::llvm::ArrayRef<::mlir::Type> xTypes(&xRawType, 1);
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();

  xOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(xRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    xRawType = type;
  }

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();

  ensureTerminator(*regionRegion, parser.getBuilder(), result.location);
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
  if (parser.resolveOperands(xOperands, xTypes, xOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicUpdateOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getX();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getX().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ' ';

  {
    bool printTerminator = true;
    if (auto *term = getRegion().empty() ? nullptr : getRegion().begin()->getTerminator()) {
      printTerminator = !term->getAttrDictionary().empty() ||
                        term->getNumOperands() != 0 ||
                        term->getNumResults() != 0;
    }
    _odsPrinter.printRegion(getRegion(), /*printEntryBlockArgs=*/true,
      /*printBlockTerminators=*/printTerminator);
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void AtomicUpdateOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Write::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::AtomicUpdateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AtomicWriteOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
AtomicWriteOpAdaptor::AtomicWriteOpAdaptor(AtomicWriteOp op) : AtomicWriteOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AtomicWriteOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void AtomicWriteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value x, ::mlir::Value expr) {
  odsState.addOperands(x);
  odsState.addOperands(expr);
}

void AtomicWriteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value x, ::mlir::Value expr) {
  odsState.addOperands(x);
  odsState.addOperands(expr);
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AtomicWriteOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult AtomicWriteOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps1(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps2(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AtomicWriteOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult AtomicWriteOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand xRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> xOperands(&xRawOperand, 1);  ::llvm::SMLoc xOperandsLoc;
  (void)xOperandsLoc;
  ::mlir::OpAsmParser::UnresolvedOperand exprRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> exprOperands(&exprRawOperand, 1);  ::llvm::SMLoc exprOperandsLoc;
  (void)exprOperandsLoc;
  ::mlir::Type xRawType{};
  ::llvm::ArrayRef<::mlir::Type> xTypes(&xRawType, 1);
  ::mlir::Type exprRawType{};
  ::llvm::ArrayRef<::mlir::Type> exprTypes(&exprRawType, 1);

  xOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(xRawOperand))
    return ::mlir::failure();
  if (parser.parseEqual())
    return ::mlir::failure();

  exprOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(exprRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    xRawType = type;
  }
  if (parser.parseComma())
    return ::mlir::failure();

  {
    ::mlir::Type type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    exprRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  if (parser.resolveOperands(xOperands, xTypes, xOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(exprOperands, exprTypes, exprOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AtomicWriteOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter << getX();
  _odsPrinter << ' ' << "=";
  _odsPrinter << ' ';
  _odsPrinter << getExpr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getX().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ",";
  _odsPrinter << ' ';
  {
    auto type = getExpr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::Type>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::AtomicWriteOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::AttachOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
AttachOpGenericAdaptorBase::AttachOpGenericAdaptorBase(AttachOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> AttachOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > AttachOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AttachOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr AttachOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause AttachOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr AttachOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool AttachOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr AttachOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool AttachOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > AttachOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
AttachOpAdaptor::AttachOpAdaptor(AttachOp op) : AttachOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult AttachOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.attach' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.attach' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.attach' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.attach' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.attach' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.attach' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> AttachOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange AttachOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange AttachOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange AttachOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult AttachOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute AttachOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code AttachOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> AttachOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void AttachOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void AttachOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult AttachOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult AttachOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void AttachOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > AttachOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > AttachOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause AttachOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool AttachOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool AttachOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > AttachOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void AttachOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void AttachOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void AttachOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void AttachOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void AttachOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void AttachOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AttachOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void AttachOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void AttachOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<AttachOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void AttachOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_attach);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult AttachOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult AttachOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult AttachOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<AttachOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<AttachOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void AttachOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_attach)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void AttachOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::AttachOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::CacheOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
CacheOpGenericAdaptorBase::CacheOpGenericAdaptorBase(CacheOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CacheOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > CacheOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CacheOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr CacheOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause CacheOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr CacheOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool CacheOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr CacheOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool CacheOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > CacheOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
CacheOpAdaptor::CacheOpAdaptor(CacheOp op) : CacheOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CacheOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.cache' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.cache' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.cache' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.cache' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.cache' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.cache' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CacheOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange CacheOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange CacheOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange CacheOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult CacheOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute CacheOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CacheOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> CacheOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void CacheOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void CacheOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult CacheOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CacheOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void CacheOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > CacheOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CacheOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause CacheOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool CacheOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool CacheOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > CacheOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void CacheOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void CacheOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void CacheOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void CacheOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void CacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void CacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void CacheOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CacheOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CacheOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void CacheOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_cache);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult CacheOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CacheOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult CacheOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<CacheOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<CacheOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CacheOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_cache)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void CacheOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::CacheOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::CopyinOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
CopyinOpGenericAdaptorBase::CopyinOpGenericAdaptorBase(CopyinOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CopyinOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > CopyinOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CopyinOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr CopyinOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause CopyinOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr CopyinOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool CopyinOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr CopyinOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool CopyinOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > CopyinOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
CopyinOpAdaptor::CopyinOpAdaptor(CopyinOp op) : CopyinOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CopyinOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.copyin' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.copyin' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.copyin' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.copyin' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.copyin' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.copyin' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CopyinOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange CopyinOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange CopyinOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange CopyinOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult CopyinOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute CopyinOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CopyinOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> CopyinOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void CopyinOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void CopyinOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult CopyinOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CopyinOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void CopyinOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > CopyinOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CopyinOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause CopyinOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool CopyinOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool CopyinOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > CopyinOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void CopyinOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void CopyinOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void CopyinOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void CopyinOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void CopyinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void CopyinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CopyinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void CopyinOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CopyinOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CopyinOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void CopyinOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_copyin);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult CopyinOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CopyinOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult CopyinOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<CopyinOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<CopyinOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CopyinOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_copyin)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void CopyinOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
  {
    auto valueRange = getODSResultIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Write::get(), getOperation()->getOpResult(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::CopyinOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::CopyoutOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
CopyoutOpGenericAdaptorBase::CopyoutOpGenericAdaptorBase(CopyoutOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CopyoutOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > CopyoutOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CopyoutOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr CopyoutOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause CopyoutOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr CopyoutOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool CopyoutOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr CopyoutOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool CopyoutOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > CopyoutOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
CopyoutOpAdaptor::CopyoutOpAdaptor(CopyoutOp op) : CopyoutOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CopyoutOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.copyout' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.copyout' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.copyout' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.copyout' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.copyout' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.copyout' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CopyoutOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange CopyoutOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange CopyoutOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult CopyoutOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute CopyoutOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CopyoutOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> CopyoutOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void CopyoutOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void CopyoutOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult CopyoutOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CopyoutOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void CopyoutOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > CopyoutOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CopyoutOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause CopyoutOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool CopyoutOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool CopyoutOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > CopyoutOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void CopyoutOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void CopyoutOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void CopyoutOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void CopyoutOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void CopyoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(varPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
}

void CopyoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(varPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CopyoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(varPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
}

void CopyoutOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(varPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CopyoutOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CopyoutOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void CopyoutOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_copyout);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult CopyoutOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CopyoutOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult CopyoutOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand accPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> accPtrOperands(&accPtrRawOperand, 1);  ::llvm::SMLoc accPtrOperandsLoc;
  (void)accPtrOperandsLoc;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  if (parser.parseKeyword("accPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  accPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(accPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("bounds"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (::mlir::succeeded(parser.parseOptionalKeyword("async"))) {
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<CopyoutOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<CopyoutOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  if (parser.resolveOperands(accPtrOperands, accPtrTypes, accPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CopyoutOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "accPtr";
  _odsPrinter << "(";
  _odsPrinter << getAccPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (!getBounds().empty()) {
    _odsPrinter << ' ' << "bounds";
    _odsPrinter << "(";
    _odsPrinter << getBounds();
    _odsPrinter << ")";
  }
  if (((!getAsyncOperands().empty()) || (!getAsyncOperands().empty()) || (getAsyncOperandsDeviceTypeAttr()))) {
    _odsPrinter << ' ' << "async";
    _odsPrinter << "(";
    printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
    _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_copyout)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void CopyoutOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
  {
    auto valueRange = getODSOperandIndexAndLength(1);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Write::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::CopyoutOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::CreateOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
CreateOpGenericAdaptorBase::CreateOpGenericAdaptorBase(CreateOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> CreateOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > CreateOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CreateOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr CreateOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause CreateOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr CreateOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool CreateOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr CreateOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool CreateOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > CreateOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
CreateOpAdaptor::CreateOpAdaptor(CreateOp op) : CreateOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult CreateOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.create' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.create' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.create' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.create' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.create' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.create' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> CreateOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange CreateOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange CreateOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange CreateOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult CreateOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute CreateOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code CreateOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> CreateOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void CreateOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void CreateOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult CreateOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult CreateOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void CreateOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > CreateOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > CreateOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause CreateOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool CreateOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool CreateOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > CreateOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void CreateOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void CreateOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void CreateOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void CreateOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void CreateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void CreateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void CreateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void CreateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<CreateOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void CreateOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_create);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult CreateOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult CreateOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult CreateOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<CreateOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<CreateOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void CreateOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_create)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void CreateOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSResultIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Write::get(), getOperation()->getOpResult(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::CreateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DataBoundsOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
DataBoundsOpGenericAdaptorBase::DataBoundsOpGenericAdaptorBase(DataBoundsOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> DataBoundsOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::BoolAttr DataBoundsOpGenericAdaptorBase::getStrideInBytesAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().strideInBytes);
  return attr;
}

bool DataBoundsOpGenericAdaptorBase::getStrideInBytes() {
  auto attr = getStrideInBytesAttr();
  return attr.getValue();
}

} // namespace detail
DataBoundsOpAdaptor::DataBoundsOpAdaptor(DataBoundsOp op) : DataBoundsOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DataBoundsOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_strideInBytes = getProperties().strideInBytes; (void)tblgen_strideInBytes;

  if (tblgen_strideInBytes && !((::llvm::isa<::mlir::BoolAttr>(tblgen_strideInBytes))))
    return emitError(loc, "'acc.bounds' op ""attribute 'strideInBytes' failed to satisfy constraint: bool attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DataBoundsOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange DataBoundsOp::getLowerboundMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DataBoundsOp::getUpperboundMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DataBoundsOp::getExtentMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DataBoundsOp::getStrideMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DataBoundsOp::getStartIdxMutable() {
  auto range = getODSOperandIndexAndLength(4);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(4u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult DataBoundsOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.strideInBytes;
       auto attr = dict.get("strideInBytes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `strideInBytes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute DataBoundsOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.strideInBytes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("strideInBytes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DataBoundsOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.strideInBytes.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> DataBoundsOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "strideInBytes")
      return prop.strideInBytes;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void DataBoundsOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "strideInBytes") {
       prop.strideInBytes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.strideInBytes)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void DataBoundsOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.strideInBytes) attrs.append("strideInBytes", prop.strideInBytes);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult DataBoundsOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getStrideInBytesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "strideInBytes", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DataBoundsOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.strideInBytes)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void DataBoundsOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.strideInBytes);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

bool DataBoundsOp::getStrideInBytes() {
  auto attr = getStrideInBytesAttr();
  return attr.getValue();
}

void DataBoundsOp::setStrideInBytes(bool attrValue) {
  getProperties().strideInBytes = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DataBoundsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, /*optional*/::mlir::Value lowerbound, /*optional*/::mlir::Value upperbound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, ::mlir::BoolAttr strideInBytes, /*optional*/::mlir::Value startIdx) {
  if (lowerbound)
    odsState.addOperands(lowerbound);
  if (upperbound)
    odsState.addOperands(upperbound);
  if (extent)
    odsState.addOperands(extent);
  if (stride)
    odsState.addOperands(stride);
  if (startIdx)
    odsState.addOperands(startIdx);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(lowerbound ? 1 : 0), (upperbound ? 1 : 0), (extent ? 1 : 0), (stride ? 1 : 0), (startIdx ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (strideInBytes) {
    odsState.getOrAddProperties<Properties>().strideInBytes = strideInBytes;
  }
  odsState.addTypes(result);
}

void DataBoundsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value lowerbound, /*optional*/::mlir::Value upperbound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, ::mlir::BoolAttr strideInBytes, /*optional*/::mlir::Value startIdx) {
  if (lowerbound)
    odsState.addOperands(lowerbound);
  if (upperbound)
    odsState.addOperands(upperbound);
  if (extent)
    odsState.addOperands(extent);
  if (stride)
    odsState.addOperands(stride);
  if (startIdx)
    odsState.addOperands(startIdx);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(lowerbound ? 1 : 0), (upperbound ? 1 : 0), (extent ? 1 : 0), (stride ? 1 : 0), (startIdx ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (strideInBytes) {
    odsState.getOrAddProperties<Properties>().strideInBytes = strideInBytes;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DataBoundsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type result, /*optional*/::mlir::Value lowerbound, /*optional*/::mlir::Value upperbound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, bool strideInBytes, /*optional*/::mlir::Value startIdx) {
  if (lowerbound)
    odsState.addOperands(lowerbound);
  if (upperbound)
    odsState.addOperands(upperbound);
  if (extent)
    odsState.addOperands(extent);
  if (stride)
    odsState.addOperands(stride);
  if (startIdx)
    odsState.addOperands(startIdx);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(lowerbound ? 1 : 0), (upperbound ? 1 : 0), (extent ? 1 : 0), (stride ? 1 : 0), (startIdx ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  odsState.getOrAddProperties<Properties>().strideInBytes = odsBuilder.getBoolAttr(strideInBytes);
  odsState.addTypes(result);
}

void DataBoundsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value lowerbound, /*optional*/::mlir::Value upperbound, /*optional*/::mlir::Value extent, /*optional*/::mlir::Value stride, bool strideInBytes, /*optional*/::mlir::Value startIdx) {
  if (lowerbound)
    odsState.addOperands(lowerbound);
  if (upperbound)
    odsState.addOperands(upperbound);
  if (extent)
    odsState.addOperands(extent);
  if (stride)
    odsState.addOperands(stride);
  if (startIdx)
    odsState.addOperands(startIdx);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(lowerbound ? 1 : 0), (upperbound ? 1 : 0), (extent ? 1 : 0), (stride ? 1 : 0), (startIdx ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  odsState.getOrAddProperties<Properties>().strideInBytes = odsBuilder.getBoolAttr(strideInBytes);
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DataBoundsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DataBoundsOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void DataBoundsOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.strideInBytes)
    properties.strideInBytes = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult DataBoundsOp::verifyInvariantsImpl() {
  auto tblgen_strideInBytes = getProperties().strideInBytes; (void)tblgen_strideInBytes;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_strideInBytes, "strideInBytes")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    if (valueGroup2.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup2.size();
    }

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    if (valueGroup3.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup3.size();
    }

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    if (valueGroup4.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup4.size();
    }

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps7(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DataBoundsOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DataBoundsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> lowerboundOperands;
  ::llvm::SMLoc lowerboundOperandsLoc;
  (void)lowerboundOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> lowerboundTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> upperboundOperands;
  ::llvm::SMLoc upperboundOperandsLoc;
  (void)upperboundOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> upperboundTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> extentOperands;
  ::llvm::SMLoc extentOperandsLoc;
  (void)extentOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> extentTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> strideOperands;
  ::llvm::SMLoc strideOperandsLoc;
  (void)strideOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> strideTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> startIdxOperands;
  ::llvm::SMLoc startIdxOperandsLoc;
  (void)startIdxOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> startIdxTypes;
  bool lowerboundClause = false;
  bool upperboundClause = false;
  bool extentClause = false;
  bool strideClause = false;
  bool startIdxClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("lowerbound"))) {

  if (lowerboundClause) {
    return parser.emitError(parser.getNameLoc())
          << "`lowerbound` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  lowerboundClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    lowerboundOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      lowerboundOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      lowerboundTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("upperbound"))) {

  if (upperboundClause) {
    return parser.emitError(parser.getNameLoc())
          << "`upperbound` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  upperboundClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    upperboundOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      upperboundOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      upperboundTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("extent"))) {

  if (extentClause) {
    return parser.emitError(parser.getNameLoc())
          << "`extent` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  extentClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    extentOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      extentOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      extentTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("stride"))) {

  if (strideClause) {
    return parser.emitError(parser.getNameLoc())
          << "`stride` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  strideClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    strideOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      strideOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      strideTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("startIdx"))) {

  if (startIdxClause) {
    return parser.emitError(parser.getNameLoc())
          << "`startIdx` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  startIdxClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    startIdxOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      startIdxOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      startIdxTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(lowerboundOperands.size()), static_cast<int32_t>(upperboundOperands.size()), static_cast<int32_t>(extentOperands.size()), static_cast<int32_t>(strideOperands.size()), static_cast<int32_t>(startIdxOperands.size())}), result.getOrAddProperties<DataBoundsOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(lowerboundOperands, lowerboundTypes, lowerboundOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(upperboundOperands, upperboundTypes, upperboundOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(extentOperands, extentTypes, extentOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(strideOperands, strideTypes, strideOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(startIdxOperands, startIdxTypes, startIdxOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DataBoundsOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getLowerbound()) {
  _odsPrinter << ' ' << "lowerbound";
  _odsPrinter << "(";
  if (::mlir::Value value = getLowerbound())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getLowerbound() ? ::llvm::ArrayRef<::mlir::Type>(getLowerbound().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getUpperbound()) {
  _odsPrinter << ' ' << "upperbound";
  _odsPrinter << "(";
  if (::mlir::Value value = getUpperbound())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getUpperbound() ? ::llvm::ArrayRef<::mlir::Type>(getUpperbound().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getExtent()) {
  _odsPrinter << ' ' << "extent";
  _odsPrinter << "(";
  if (::mlir::Value value = getExtent())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getExtent() ? ::llvm::ArrayRef<::mlir::Type>(getExtent().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getStride()) {
  _odsPrinter << ' ' << "stride";
  _odsPrinter << "(";
  if (::mlir::Value value = getStride())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getStride() ? ::llvm::ArrayRef<::mlir::Type>(getStride().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getStartIdx()) {
  _odsPrinter << ' ' << "startIdx";
  _odsPrinter << "(";
  if (::mlir::Value value = getStartIdx())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getStartIdx() ? ::llvm::ArrayRef<::mlir::Type>(getStartIdx().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStrideInBytesAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("strideInBytes");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void DataBoundsOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DataBoundsOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DataOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
DataOpGenericAdaptorBase::DataOpGenericAdaptorBase(DataOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> DataOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > DataOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DataOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> DataOpGenericAdaptorBase::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DataOpGenericAdaptorBase::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DataOpGenericAdaptorBase::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DataOpGenericAdaptorBase::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::mlir::acc::ClauseDefaultValue> DataOpGenericAdaptorBase::getDefaultAttr() {
  auto attr = getDefaultAttrAttr();
  return attr ? ::std::optional<::mlir::acc::ClauseDefaultValue>(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
DataOpAdaptor::DataOpAdaptor(DataOp op) : DataOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DataOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_defaultAttr = getProperties().defaultAttr; (void)tblgen_defaultAttr;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.data' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.data' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_waitOperandsSegments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_waitOperandsSegments))))
    return emitError(loc, "'acc.data' op ""attribute 'waitOperandsSegments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_waitOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.data' op ""attribute 'waitOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_hasWaitDevnum && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_hasWaitDevnum))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_hasWaitDevnum), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::BoolAttr>(attr))); }))))
    return emitError(loc, "'acc.data' op ""attribute 'hasWaitDevnum' failed to satisfy constraint: 1-bit boolean array attribute");

  if (tblgen_waitOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.data' op ""attribute 'waitOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_defaultAttr && !((::llvm::isa<::mlir::acc::ClauseDefaultValueAttr>(tblgen_defaultAttr))))
    return emitError(loc, "'acc.data' op ""attribute 'defaultAttr' failed to satisfy constraint: DefaultValue Clause");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DataOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange DataOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DataOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DataOp::getWaitOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DataOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult DataOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.defaultAttr;
       auto attr = dict.get("defaultAttr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `defaultAttr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.hasWaitDevnum;
       auto attr = dict.get("hasWaitDevnum");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `hasWaitDevnum` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOnly;
       auto attr = dict.get("waitOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsDeviceType;
       auto attr = dict.get("waitOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsSegments;
       auto attr = dict.get("waitOperandsSegments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsSegments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute DataOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.defaultAttr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("defaultAttr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.hasWaitDevnum;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("hasWaitDevnum",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsSegments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsSegments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DataOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.defaultAttr.getAsOpaquePointer()), 
    llvm::hash_value(prop.hasWaitDevnum.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsSegments.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> DataOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "defaultAttr")
      return prop.defaultAttr;

    if (name == "hasWaitDevnum")
      return prop.hasWaitDevnum;

    if (name == "waitOnly")
      return prop.waitOnly;

    if (name == "waitOperandsDeviceType")
      return prop.waitOperandsDeviceType;

    if (name == "waitOperandsSegments")
      return prop.waitOperandsSegments;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void DataOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "defaultAttr") {
       prop.defaultAttr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.defaultAttr)>>(value);
       return;
    }

    if (name == "hasWaitDevnum") {
       prop.hasWaitDevnum = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.hasWaitDevnum)>>(value);
       return;
    }

    if (name == "waitOnly") {
       prop.waitOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOnly)>>(value);
       return;
    }

    if (name == "waitOperandsDeviceType") {
       prop.waitOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsDeviceType)>>(value);
       return;
    }

    if (name == "waitOperandsSegments") {
       prop.waitOperandsSegments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsSegments)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void DataOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.defaultAttr) attrs.append("defaultAttr", prop.defaultAttr);

    if (prop.hasWaitDevnum) attrs.append("hasWaitDevnum", prop.hasWaitDevnum);

    if (prop.waitOnly) attrs.append("waitOnly", prop.waitOnly);

    if (prop.waitOperandsDeviceType) attrs.append("waitOperandsDeviceType", prop.waitOperandsDeviceType);

    if (prop.waitOperandsSegments) attrs.append("waitOperandsSegments", prop.waitOperandsSegments);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult DataOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDefaultAttrAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps8(attr, "defaultAttr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getHasWaitDevnumAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(attr, "hasWaitDevnum", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(attr, "waitOperandsSegments", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DataOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.defaultAttr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.hasWaitDevnum)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsSegments)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void DataOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.defaultAttr);

  writer.writeOptionalAttribute(prop.hasWaitDevnum);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.waitOnly);

  writer.writeOptionalAttribute(prop.waitOperandsDeviceType);

  writer.writeOptionalAttribute(prop.waitOperandsSegments);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > DataOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DataOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> DataOp::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DataOp::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DataOp::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DataOp::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::mlir::acc::ClauseDefaultValue> DataOp::getDefaultAttr() {
  auto attr = getDefaultAttrAttr();
  return attr ? ::std::optional<::mlir::acc::ClauseDefaultValue>(attr.getValue()) : (::std::nullopt);
}

void DataOp::setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().waitOperandsSegments;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void DataOp::setDefaultAttr(::std::optional<::mlir::acc::ClauseDefaultValue> attrValue) {
    auto &odsProp = getProperties().defaultAttr;
    if (attrValue)
      odsProp = ::mlir::acc::ClauseDefaultValueAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void DataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  (void)odsState.addRegion();
}

void DataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DataOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DataOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DataOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_defaultAttr = getProperties().defaultAttr; (void)tblgen_defaultAttr;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(*this, tblgen_waitOperandsSegments, "waitOperandsSegments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOperandsDeviceType, "waitOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(*this, tblgen_hasWaitDevnum, "hasWaitDevnum")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOnly, "waitOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps8(*this, tblgen_defaultAttr, "defaultAttr")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult DataOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DataOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitOperandsOperands;
  ::llvm::SMLoc waitOperandsOperandsLoc;
  (void)waitOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitOperandsTypes;
  ::mlir::ArrayAttr waitOperandsDeviceTypeAttr;
  ::mlir::DenseI32ArrayAttr waitOperandsSegmentsAttr;
  ::mlir::ArrayAttr hasWaitDevnumAttr;
  ::mlir::ArrayAttr waitOnlyAttr;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();
  bool ifClause = false;
  bool asyncClause = false;
  bool dataOperandsClause = false;
  bool waitClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<DataOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("wait"))) {

  if (waitClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  waitClause = true;
  {
    waitOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseWaitClause(parser, waitOperandsOperands, waitOperandsTypes, waitOperandsDeviceTypeAttr, waitOperandsSegmentsAttr, hasWaitDevnumAttr, waitOnlyAttr);
    if (odsResult) return ::mlir::failure();
    if (waitOperandsDeviceTypeAttr)
      result.getOrAddProperties<DataOp::Properties>().waitOperandsDeviceType = waitOperandsDeviceTypeAttr;
    if (waitOperandsSegmentsAttr)
      result.getOrAddProperties<DataOp::Properties>().waitOperandsSegments = waitOperandsSegmentsAttr;
    if (hasWaitDevnumAttr)
      result.getOrAddProperties<DataOp::Properties>().hasWaitDevnum = hasWaitDevnumAttr;
    if (waitOnlyAttr)
      result.getOrAddProperties<DataOp::Properties>().waitOnly = waitOnlyAttr;
  }
    } else  {
    break;
  }
}

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(ifCondOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size()), static_cast<int32_t>(waitOperandsOperands.size()), static_cast<int32_t>(dataClauseOperandsOperands.size())}), result.getOrAddProperties<DataOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitOperandsOperands, waitOperandsTypes, waitOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DataOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  if (false || getWaitOperands().size() || (getWaitOperandsDeviceTypeAttr()) || (getWaitOperandsSegmentsAttr()) || (getHasWaitDevnumAttr()) || (getWaitOnlyAttr())) {
  _odsPrinter << ' ' << "wait";
  printWaitClause(_odsPrinter, *this, getWaitOperands(), getWaitOperands().getTypes(), getWaitOperandsDeviceTypeAttr(), getWaitOperandsSegmentsAttr(), getHasWaitDevnumAttr(), getWaitOnlyAttr());
  }
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getRegion());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  elidedAttrs.push_back("waitOperandsDeviceType");
  elidedAttrs.push_back("waitOperandsSegments");
  elidedAttrs.push_back("hasWaitDevnum");
  elidedAttrs.push_back("waitOnly");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void DataOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DataOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareDeviceResidentOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
DeclareDeviceResidentOpGenericAdaptorBase::DeclareDeviceResidentOpGenericAdaptorBase(DeclareDeviceResidentOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> DeclareDeviceResidentOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > DeclareDeviceResidentOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DeclareDeviceResidentOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr DeclareDeviceResidentOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause DeclareDeviceResidentOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr DeclareDeviceResidentOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool DeclareDeviceResidentOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr DeclareDeviceResidentOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool DeclareDeviceResidentOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DeclareDeviceResidentOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
DeclareDeviceResidentOpAdaptor::DeclareDeviceResidentOpAdaptor(DeclareDeviceResidentOp op) : DeclareDeviceResidentOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DeclareDeviceResidentOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.declare_device_resident' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.declare_device_resident' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.declare_device_resident' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.declare_device_resident' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.declare_device_resident' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.declare_device_resident' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DeclareDeviceResidentOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange DeclareDeviceResidentOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DeclareDeviceResidentOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DeclareDeviceResidentOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult DeclareDeviceResidentOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute DeclareDeviceResidentOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DeclareDeviceResidentOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> DeclareDeviceResidentOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void DeclareDeviceResidentOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void DeclareDeviceResidentOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult DeclareDeviceResidentOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DeclareDeviceResidentOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void DeclareDeviceResidentOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > DeclareDeviceResidentOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DeclareDeviceResidentOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause DeclareDeviceResidentOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool DeclareDeviceResidentOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool DeclareDeviceResidentOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DeclareDeviceResidentOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void DeclareDeviceResidentOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void DeclareDeviceResidentOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DeclareDeviceResidentOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DeclareDeviceResidentOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void DeclareDeviceResidentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void DeclareDeviceResidentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeclareDeviceResidentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void DeclareDeviceResidentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeclareDeviceResidentOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DeclareDeviceResidentOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void DeclareDeviceResidentOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_declare_device_resident);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult DeclareDeviceResidentOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DeclareDeviceResidentOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DeclareDeviceResidentOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<DeclareDeviceResidentOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<DeclareDeviceResidentOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DeclareDeviceResidentOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_declare_device_resident)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void DeclareDeviceResidentOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareDeviceResidentOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareEnterOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> DeclareEnterOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
DeclareEnterOpAdaptor::DeclareEnterOpAdaptor(DeclareEnterOp op) : DeclareEnterOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DeclareEnterOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DeclareEnterOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange DeclareEnterOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

void DeclareEnterOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type token, ::mlir::ValueRange dataClauseOperands) {
  odsState.addOperands(dataClauseOperands);
  odsState.addTypes(token);
}

void DeclareEnterOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult DeclareEnterOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps10(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DeclareEnterOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DeclareEnterOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  bool dataOperandsClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
  }
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DeclareTokenType>();
  result.addTypes(odsBuildableType0);
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DeclareEnterOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void DeclareEnterOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareEnterOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareExitOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
DeclareExitOpGenericAdaptorBase::DeclareExitOpGenericAdaptorBase(DeclareExitOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> DeclareExitOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

} // namespace detail
DeclareExitOpAdaptor::DeclareExitOpAdaptor(DeclareExitOp op) : DeclareExitOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DeclareExitOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DeclareExitOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange DeclareExitOp::getTokenMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DeclareExitOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult DeclareExitOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }
    {

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute DeclareExitOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DeclareExitOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> DeclareExitOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void DeclareExitOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void DeclareExitOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult DeclareExitOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    return ::mlir::success();
}

::llvm::LogicalResult DeclareExitOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void DeclareExitOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

void DeclareExitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value token, ::mlir::ValueRange dataClauseOperands) {
  if (token)
    odsState.addOperands(token);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(token ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
}

void DeclareExitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value token, ::mlir::ValueRange dataClauseOperands) {
  if (token)
    odsState.addOperands(token);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(token ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeclareExitOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DeclareExitOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult DeclareExitOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps10(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DeclareExitOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DeclareExitOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> tokenOperands;
  ::llvm::SMLoc tokenOperandsLoc;
  (void)tokenOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  bool tokenClause = false;
  bool dataOperandsClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("token"))) {

  if (tokenClause) {
    return parser.emitError(parser.getNameLoc())
          << "`token` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  tokenClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    tokenOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      tokenOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(tokenOperands.size()), static_cast<int32_t>(dataClauseOperandsOperands.size())}), result.getOrAddProperties<DeclareExitOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DeclareTokenType>();
  if (parser.resolveOperands(tokenOperands, odsBuildableType0, tokenOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DeclareExitOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getToken()) {
  _odsPrinter << ' ' << "token";
  _odsPrinter << "(";
  if (::mlir::Value value = getToken())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void DeclareExitOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareExitOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareLinkOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
DeclareLinkOpGenericAdaptorBase::DeclareLinkOpGenericAdaptorBase(DeclareLinkOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> DeclareLinkOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > DeclareLinkOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DeclareLinkOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr DeclareLinkOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause DeclareLinkOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr DeclareLinkOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool DeclareLinkOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr DeclareLinkOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool DeclareLinkOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DeclareLinkOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
DeclareLinkOpAdaptor::DeclareLinkOpAdaptor(DeclareLinkOp op) : DeclareLinkOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DeclareLinkOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.declare_link' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.declare_link' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.declare_link' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.declare_link' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.declare_link' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.declare_link' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DeclareLinkOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange DeclareLinkOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DeclareLinkOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DeclareLinkOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult DeclareLinkOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute DeclareLinkOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DeclareLinkOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> DeclareLinkOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void DeclareLinkOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void DeclareLinkOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult DeclareLinkOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DeclareLinkOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void DeclareLinkOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > DeclareLinkOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DeclareLinkOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause DeclareLinkOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool DeclareLinkOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool DeclareLinkOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DeclareLinkOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void DeclareLinkOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void DeclareLinkOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DeclareLinkOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DeclareLinkOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void DeclareLinkOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void DeclareLinkOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeclareLinkOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void DeclareLinkOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeclareLinkOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DeclareLinkOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void DeclareLinkOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_declare_link);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult DeclareLinkOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DeclareLinkOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DeclareLinkOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<DeclareLinkOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<DeclareLinkOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DeclareLinkOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_declare_link)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void DeclareLinkOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareLinkOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeclareOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> DeclareOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
DeclareOpAdaptor::DeclareOpAdaptor(DeclareOp op) : DeclareOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DeclareOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DeclareOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange DeclareOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

void DeclareOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange dataClauseOperands) {
  odsState.addOperands(dataClauseOperands);
  (void)odsState.addRegion();
}

void DeclareOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult DeclareOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult DeclareOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DeclareOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();
  if (parser.parseKeyword("dataOperands"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DeclareOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getRegion());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void DeclareOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DeclareOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DeleteOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
DeleteOpGenericAdaptorBase::DeleteOpGenericAdaptorBase(DeleteOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> DeleteOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > DeleteOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DeleteOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr DeleteOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause DeleteOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr DeleteOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool DeleteOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr DeleteOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool DeleteOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DeleteOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
DeleteOpAdaptor::DeleteOpAdaptor(DeleteOp op) : DeleteOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DeleteOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.delete' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.delete' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.delete' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.delete' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.delete' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.delete' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DeleteOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange DeleteOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DeleteOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult DeleteOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute DeleteOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DeleteOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> DeleteOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void DeleteOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void DeleteOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult DeleteOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DeleteOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void DeleteOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > DeleteOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DeleteOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause DeleteOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool DeleteOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool DeleteOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DeleteOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void DeleteOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void DeleteOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DeleteOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DeleteOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void DeleteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
}

void DeleteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeleteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
}

void DeleteOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DeleteOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DeleteOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void DeleteOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_delete);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult DeleteOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DeleteOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DeleteOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand accPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> accPtrOperands(&accPtrRawOperand, 1);  ::llvm::SMLoc accPtrOperandsLoc;
  (void)accPtrOperandsLoc;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  if (parser.parseKeyword("accPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  accPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(accPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("bounds"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (::mlir::succeeded(parser.parseOptionalKeyword("async"))) {
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<DeleteOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<DeleteOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  if (parser.resolveOperands(accPtrOperands, accPtrTypes, accPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DeleteOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "accPtr";
  _odsPrinter << "(";
  _odsPrinter << getAccPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (!getBounds().empty()) {
    _odsPrinter << ' ' << "bounds";
    _odsPrinter << "(";
    _odsPrinter << getBounds();
    _odsPrinter << ")";
  }
  if (((!getAsyncOperands().empty()) || (!getAsyncOperands().empty()) || (getAsyncOperandsDeviceTypeAttr()))) {
    _odsPrinter << ' ' << "async";
    _odsPrinter << "(";
    printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
    _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_delete)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void DeleteOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DeleteOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DetachOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
DetachOpGenericAdaptorBase::DetachOpGenericAdaptorBase(DetachOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> DetachOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > DetachOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DetachOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr DetachOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause DetachOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr DetachOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool DetachOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr DetachOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool DetachOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DetachOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
DetachOpAdaptor::DetachOpAdaptor(DetachOp op) : DetachOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DetachOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.detach' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.detach' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.detach' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.detach' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.detach' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.detach' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DetachOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange DetachOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DetachOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult DetachOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute DetachOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DetachOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> DetachOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void DetachOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void DetachOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult DetachOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DetachOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void DetachOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > DetachOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DetachOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause DetachOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool DetachOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool DetachOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DetachOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void DetachOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void DetachOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DetachOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DetachOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void DetachOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
}

void DetachOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DetachOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
}

void DetachOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DetachOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DetachOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void DetachOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_detach);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult DetachOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DetachOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DetachOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand accPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> accPtrOperands(&accPtrRawOperand, 1);  ::llvm::SMLoc accPtrOperandsLoc;
  (void)accPtrOperandsLoc;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  if (parser.parseKeyword("accPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  accPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(accPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("bounds"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (::mlir::succeeded(parser.parseOptionalKeyword("async"))) {
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<DetachOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<DetachOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  if (parser.resolveOperands(accPtrOperands, accPtrTypes, accPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DetachOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "accPtr";
  _odsPrinter << "(";
  _odsPrinter << getAccPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (!getBounds().empty()) {
    _odsPrinter << ' ' << "bounds";
    _odsPrinter << "(";
    _odsPrinter << getBounds();
    _odsPrinter << ")";
  }
  if (((!getAsyncOperands().empty()) || (!getAsyncOperands().empty()) || (getAsyncOperandsDeviceTypeAttr()))) {
    _odsPrinter << ' ' << "async";
    _odsPrinter << "(";
    printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
    _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_detach)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void DetachOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DetachOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::DevicePtrOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
DevicePtrOpGenericAdaptorBase::DevicePtrOpGenericAdaptorBase(DevicePtrOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> DevicePtrOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > DevicePtrOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DevicePtrOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr DevicePtrOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause DevicePtrOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr DevicePtrOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool DevicePtrOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr DevicePtrOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool DevicePtrOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DevicePtrOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
DevicePtrOpAdaptor::DevicePtrOpAdaptor(DevicePtrOp op) : DevicePtrOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult DevicePtrOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.deviceptr' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.deviceptr' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.deviceptr' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.deviceptr' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.deviceptr' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.deviceptr' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> DevicePtrOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange DevicePtrOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DevicePtrOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange DevicePtrOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult DevicePtrOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute DevicePtrOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code DevicePtrOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> DevicePtrOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void DevicePtrOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void DevicePtrOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult DevicePtrOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult DevicePtrOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void DevicePtrOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > DevicePtrOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > DevicePtrOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause DevicePtrOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool DevicePtrOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool DevicePtrOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > DevicePtrOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void DevicePtrOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void DevicePtrOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DevicePtrOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void DevicePtrOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void DevicePtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void DevicePtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DevicePtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void DevicePtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void DevicePtrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<DevicePtrOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void DevicePtrOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_deviceptr);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult DevicePtrOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult DevicePtrOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult DevicePtrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<DevicePtrOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<DevicePtrOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void DevicePtrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_deviceptr)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void DevicePtrOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::DevicePtrOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::EnterDataOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
EnterDataOpGenericAdaptorBase::EnterDataOpGenericAdaptorBase(EnterDataOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> EnterDataOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::UnitAttr EnterDataOpGenericAdaptorBase::getAsyncAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().async);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool EnterDataOpGenericAdaptorBase::getAsync() {
  auto attr = getAsyncAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr EnterDataOpGenericAdaptorBase::getWaitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().wait);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool EnterDataOpGenericAdaptorBase::getWait() {
  auto attr = getWaitAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
EnterDataOpAdaptor::EnterDataOpAdaptor(EnterDataOp op) : EnterDataOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult EnterDataOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_async = getProperties().async; (void)tblgen_async;
  auto tblgen_wait = getProperties().wait; (void)tblgen_wait;

  if (tblgen_async && !((::llvm::isa<::mlir::UnitAttr>(tblgen_async))))
    return emitError(loc, "'acc.enter_data' op ""attribute 'async' failed to satisfy constraint: unit attribute");

  if (tblgen_wait && !((::llvm::isa<::mlir::UnitAttr>(tblgen_wait))))
    return emitError(loc, "'acc.enter_data' op ""attribute 'wait' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> EnterDataOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange EnterDataOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange EnterDataOp::getAsyncOperandMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange EnterDataOp::getWaitDevnumMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange EnterDataOp::getWaitOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange EnterDataOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(4);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(4u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult EnterDataOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.async;
       auto attr = dict.get("async");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `async` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.wait;
       auto attr = dict.get("wait");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `wait` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute EnterDataOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.async;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("async",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.wait;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("wait",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code EnterDataOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.async.getAsOpaquePointer()), 
    llvm::hash_value(prop.wait.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> EnterDataOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "async")
      return prop.async;

    if (name == "wait")
      return prop.wait;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void EnterDataOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "async") {
       prop.async = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.async)>>(value);
       return;
    }

    if (name == "wait") {
       prop.wait = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.wait)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void EnterDataOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.async) attrs.append("async", prop.async);

    if (prop.wait) attrs.append("wait", prop.wait);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult EnterDataOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "async", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "wait", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult EnterDataOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.async)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.wait)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void EnterDataOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.async);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.wait);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

bool EnterDataOp::getAsync() {
  auto attr = getAsyncAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool EnterDataOp::getWait() {
  auto attr = getWaitAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void EnterDataOp::setAsync(bool attrValue) {
    auto &odsProp = getProperties().async;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void EnterDataOp::setWait(bool attrValue) {
    auto &odsProp = getProperties().wait;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void EnterDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/::mlir::UnitAttr wait, ::mlir::ValueRange dataClauseOperands) {
  if (ifCond)
    odsState.addOperands(ifCond);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
  if (wait) {
    odsState.getOrAddProperties<Properties>().wait = wait;
  }
}

void EnterDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/::mlir::UnitAttr wait, ::mlir::ValueRange dataClauseOperands) {
  if (ifCond)
    odsState.addOperands(ifCond);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
  if (wait) {
    odsState.getOrAddProperties<Properties>().wait = wait;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EnterDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/bool async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/bool wait, ::mlir::ValueRange dataClauseOperands) {
  if (ifCond)
    odsState.addOperands(ifCond);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = ((async) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (wait) {
    odsState.getOrAddProperties<Properties>().wait = ((wait) ? odsBuilder.getUnitAttr() : nullptr);
  }
}

void EnterDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/bool async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/bool wait, ::mlir::ValueRange dataClauseOperands) {
  if (ifCond)
    odsState.addOperands(ifCond);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = ((async) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (wait) {
    odsState.getOrAddProperties<Properties>().wait = ((wait) ? odsBuilder.getUnitAttr() : nullptr);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void EnterDataOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<EnterDataOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult EnterDataOp::verifyInvariantsImpl() {
  auto tblgen_async = getProperties().async; (void)tblgen_async;
  auto tblgen_wait = getProperties().wait; (void)tblgen_wait;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_async, "async")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_wait, "wait")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    if (valueGroup2.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup2.size();
    }

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult EnterDataOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult EnterDataOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandOperands;
  ::llvm::SMLoc asyncOperandOperandsLoc;
  (void)asyncOperandOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitDevnumOperands;
  ::llvm::SMLoc waitDevnumOperandsLoc;
  (void)waitDevnumOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitDevnumTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitOperandsOperands;
  ::llvm::SMLoc waitOperandsOperandsLoc;
  (void)waitOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitOperandsTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  bool ifClause = false;
  bool asyncClause = false;
  bool wait_devnumClause = false;
  bool waitClause = false;
  bool dataOperandsClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    asyncOperandOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      asyncOperandOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      asyncOperandTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("wait_devnum"))) {

  if (wait_devnumClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait_devnum` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  wait_devnumClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    waitDevnumOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      waitDevnumOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      waitDevnumTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("wait"))) {

  if (waitClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  waitClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  waitOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(waitOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(waitOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(ifCondOperands.size()), static_cast<int32_t>(asyncOperandOperands.size()), static_cast<int32_t>(waitDevnumOperands.size()), static_cast<int32_t>(waitOperandsOperands.size()), static_cast<int32_t>(dataClauseOperandsOperands.size())}), result.getOrAddProperties<EnterDataOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandOperands, asyncOperandTypes, asyncOperandOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitDevnumOperands, waitDevnumTypes, waitDevnumOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitOperandsOperands, waitOperandsTypes, waitOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void EnterDataOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getAsyncOperand()) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  if (::mlir::Value value = getAsyncOperand())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getAsyncOperand() ? ::llvm::ArrayRef<::mlir::Type>(getAsyncOperand().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getWaitDevnum()) {
  _odsPrinter << ' ' << "wait_devnum";
  _odsPrinter << "(";
  if (::mlir::Value value = getWaitDevnum())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getWaitDevnum() ? ::llvm::ArrayRef<::mlir::Type>(getWaitDevnum().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getWaitOperands().size()) {
  _odsPrinter << ' ' << "wait";
  _odsPrinter << "(";
  _odsPrinter << getWaitOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getWaitOperands().getTypes();
  _odsPrinter << ")";
  }
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getAsyncAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("async");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getWaitAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("wait");
  }
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void EnterDataOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::EnterDataOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ExitDataOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ExitDataOpGenericAdaptorBase::ExitDataOpGenericAdaptorBase(ExitDataOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> ExitDataOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::UnitAttr ExitDataOpGenericAdaptorBase::getAsyncAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().async);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool ExitDataOpGenericAdaptorBase::getAsync() {
  auto attr = getAsyncAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr ExitDataOpGenericAdaptorBase::getWaitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().wait);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool ExitDataOpGenericAdaptorBase::getWait() {
  auto attr = getWaitAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr ExitDataOpGenericAdaptorBase::getFinalizeAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().finalize);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool ExitDataOpGenericAdaptorBase::getFinalize() {
  auto attr = getFinalizeAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
ExitDataOpAdaptor::ExitDataOpAdaptor(ExitDataOp op) : ExitDataOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ExitDataOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_async = getProperties().async; (void)tblgen_async;
  auto tblgen_finalize = getProperties().finalize; (void)tblgen_finalize;
  auto tblgen_wait = getProperties().wait; (void)tblgen_wait;

  if (tblgen_async && !((::llvm::isa<::mlir::UnitAttr>(tblgen_async))))
    return emitError(loc, "'acc.exit_data' op ""attribute 'async' failed to satisfy constraint: unit attribute");

  if (tblgen_wait && !((::llvm::isa<::mlir::UnitAttr>(tblgen_wait))))
    return emitError(loc, "'acc.exit_data' op ""attribute 'wait' failed to satisfy constraint: unit attribute");

  if (tblgen_finalize && !((::llvm::isa<::mlir::UnitAttr>(tblgen_finalize))))
    return emitError(loc, "'acc.exit_data' op ""attribute 'finalize' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ExitDataOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange ExitDataOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ExitDataOp::getAsyncOperandMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ExitDataOp::getWaitDevnumMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ExitDataOp::getWaitOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ExitDataOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(4);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(4u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult ExitDataOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.async;
       auto attr = dict.get("async");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `async` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.finalize;
       auto attr = dict.get("finalize");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `finalize` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.wait;
       auto attr = dict.get("wait");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `wait` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute ExitDataOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.async;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("async",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.finalize;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("finalize",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.wait;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("wait",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ExitDataOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.async.getAsOpaquePointer()), 
    llvm::hash_value(prop.finalize.getAsOpaquePointer()), 
    llvm::hash_value(prop.wait.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> ExitDataOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "async")
      return prop.async;

    if (name == "finalize")
      return prop.finalize;

    if (name == "wait")
      return prop.wait;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void ExitDataOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "async") {
       prop.async = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.async)>>(value);
       return;
    }

    if (name == "finalize") {
       prop.finalize = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.finalize)>>(value);
       return;
    }

    if (name == "wait") {
       prop.wait = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.wait)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void ExitDataOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.async) attrs.append("async", prop.async);

    if (prop.finalize) attrs.append("finalize", prop.finalize);

    if (prop.wait) attrs.append("wait", prop.wait);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult ExitDataOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "async", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFinalizeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "finalize", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "wait", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ExitDataOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.async)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.finalize)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.wait)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void ExitDataOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.async);

  writer.writeOptionalAttribute(prop.finalize);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.wait);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

bool ExitDataOp::getAsync() {
  auto attr = getAsyncAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool ExitDataOp::getWait() {
  auto attr = getWaitAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool ExitDataOp::getFinalize() {
  auto attr = getFinalizeAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void ExitDataOp::setAsync(bool attrValue) {
    auto &odsProp = getProperties().async;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void ExitDataOp::setWait(bool attrValue) {
    auto &odsProp = getProperties().wait;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void ExitDataOp::setFinalize(bool attrValue) {
    auto &odsProp = getProperties().finalize;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void ExitDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/::mlir::UnitAttr wait, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr finalize) {
  if (ifCond)
    odsState.addOperands(ifCond);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
  if (wait) {
    odsState.getOrAddProperties<Properties>().wait = wait;
  }
  if (finalize) {
    odsState.getOrAddProperties<Properties>().finalize = finalize;
  }
}

void ExitDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/::mlir::UnitAttr wait, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr finalize) {
  if (ifCond)
    odsState.addOperands(ifCond);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
  if (wait) {
    odsState.getOrAddProperties<Properties>().wait = wait;
  }
  if (finalize) {
    odsState.getOrAddProperties<Properties>().finalize = finalize;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExitDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/bool async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/bool wait, ::mlir::ValueRange dataClauseOperands, /*optional*/bool finalize) {
  if (ifCond)
    odsState.addOperands(ifCond);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = ((async) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (wait) {
    odsState.getOrAddProperties<Properties>().wait = ((wait) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (finalize) {
    odsState.getOrAddProperties<Properties>().finalize = ((finalize) ? odsBuilder.getUnitAttr() : nullptr);
  }
}

void ExitDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value asyncOperand, /*optional*/bool async, /*optional*/::mlir::Value waitDevnum, ::mlir::ValueRange waitOperands, /*optional*/bool wait, ::mlir::ValueRange dataClauseOperands, /*optional*/bool finalize) {
  if (ifCond)
    odsState.addOperands(ifCond);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = ((async) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (wait) {
    odsState.getOrAddProperties<Properties>().wait = ((wait) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (finalize) {
    odsState.getOrAddProperties<Properties>().finalize = ((finalize) ? odsBuilder.getUnitAttr() : nullptr);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ExitDataOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ExitDataOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ExitDataOp::verifyInvariantsImpl() {
  auto tblgen_async = getProperties().async; (void)tblgen_async;
  auto tblgen_finalize = getProperties().finalize; (void)tblgen_finalize;
  auto tblgen_wait = getProperties().wait; (void)tblgen_wait;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_async, "async")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_wait, "wait")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_finalize, "finalize")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    if (valueGroup2.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup2.size();
    }

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ExitDataOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ExitDataOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandOperands;
  ::llvm::SMLoc asyncOperandOperandsLoc;
  (void)asyncOperandOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitDevnumOperands;
  ::llvm::SMLoc waitDevnumOperandsLoc;
  (void)waitDevnumOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitDevnumTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitOperandsOperands;
  ::llvm::SMLoc waitOperandsOperandsLoc;
  (void)waitOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitOperandsTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  bool ifClause = false;
  bool asyncClause = false;
  bool wait_devnumClause = false;
  bool waitClause = false;
  bool dataOperandsClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    asyncOperandOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      asyncOperandOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      asyncOperandTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("wait_devnum"))) {

  if (wait_devnumClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait_devnum` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  wait_devnumClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    waitDevnumOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      waitDevnumOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      waitDevnumTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("wait"))) {

  if (waitClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  waitClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  waitOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(waitOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(waitOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(ifCondOperands.size()), static_cast<int32_t>(asyncOperandOperands.size()), static_cast<int32_t>(waitDevnumOperands.size()), static_cast<int32_t>(waitOperandsOperands.size()), static_cast<int32_t>(dataClauseOperandsOperands.size())}), result.getOrAddProperties<ExitDataOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandOperands, asyncOperandTypes, asyncOperandOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitDevnumOperands, waitDevnumTypes, waitDevnumOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitOperandsOperands, waitOperandsTypes, waitOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ExitDataOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getAsyncOperand()) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  if (::mlir::Value value = getAsyncOperand())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getAsyncOperand() ? ::llvm::ArrayRef<::mlir::Type>(getAsyncOperand().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getWaitDevnum()) {
  _odsPrinter << ' ' << "wait_devnum";
  _odsPrinter << "(";
  if (::mlir::Value value = getWaitDevnum())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getWaitDevnum() ? ::llvm::ArrayRef<::mlir::Type>(getWaitDevnum().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getWaitOperands().size()) {
  _odsPrinter << ' ' << "wait";
  _odsPrinter << "(";
  _odsPrinter << getWaitOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getWaitOperands().getTypes();
  _odsPrinter << ")";
  }
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getAsyncAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("async");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getWaitAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("wait");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getFinalizeAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("finalize");
  }
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void ExitDataOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::ExitDataOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::FirstprivateOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FirstprivateOpGenericAdaptorBase::FirstprivateOpGenericAdaptorBase(FirstprivateOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> FirstprivateOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > FirstprivateOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > FirstprivateOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr FirstprivateOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause FirstprivateOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr FirstprivateOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool FirstprivateOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr FirstprivateOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool FirstprivateOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > FirstprivateOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
FirstprivateOpAdaptor::FirstprivateOpAdaptor(FirstprivateOp op) : FirstprivateOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FirstprivateOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.firstprivate' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.firstprivate' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.firstprivate' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.firstprivate' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.firstprivate' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.firstprivate' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> FirstprivateOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange FirstprivateOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange FirstprivateOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange FirstprivateOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult FirstprivateOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute FirstprivateOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FirstprivateOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> FirstprivateOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void FirstprivateOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void FirstprivateOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult FirstprivateOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FirstprivateOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void FirstprivateOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > FirstprivateOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > FirstprivateOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause FirstprivateOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool FirstprivateOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool FirstprivateOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > FirstprivateOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void FirstprivateOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void FirstprivateOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void FirstprivateOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void FirstprivateOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void FirstprivateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void FirstprivateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FirstprivateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void FirstprivateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FirstprivateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FirstprivateOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void FirstprivateOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_firstprivate);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult FirstprivateOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult FirstprivateOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult FirstprivateOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<FirstprivateOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<FirstprivateOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void FirstprivateOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_firstprivate)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void FirstprivateOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
  {
    auto valueRange = getODSResultIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Write::get(), getOperation()->getOpResult(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::FirstprivateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::FirstprivateRecipeOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
FirstprivateRecipeOpGenericAdaptorBase::FirstprivateRecipeOpGenericAdaptorBase(FirstprivateRecipeOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef FirstprivateRecipeOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::Type FirstprivateRecipeOpGenericAdaptorBase::getType() {
  auto attr = getTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

} // namespace detail
FirstprivateRecipeOpAdaptor::FirstprivateRecipeOpAdaptor(FirstprivateRecipeOp op) : FirstprivateRecipeOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult FirstprivateRecipeOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'acc.firstprivate.recipe' op ""requires attribute 'sym_name'");
  auto tblgen_type = getProperties().type; (void)tblgen_type;
  if (!tblgen_type) return emitError(loc, "'acc.firstprivate.recipe' op ""requires attribute 'type'");

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'acc.firstprivate.recipe' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");

  if (tblgen_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_type))) && ((::llvm::isa<::mlir::Type>(::llvm::cast<::mlir::TypeAttr>(tblgen_type).getValue()))) && ((true))))
    return emitError(loc, "'acc.firstprivate.recipe' op ""attribute 'type' failed to satisfy constraint: any type attribute");
  return ::mlir::success();
}

::llvm::LogicalResult FirstprivateRecipeOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.type;
       auto attr = dict.get("type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute FirstprivateRecipeOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("type",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code FirstprivateRecipeOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()), 
    llvm::hash_value(prop.type.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> FirstprivateRecipeOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "sym_name")
      return prop.sym_name;

    if (name == "type")
      return prop.type;
  return std::nullopt;
}

void FirstprivateRecipeOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }

    if (name == "type") {
       prop.type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.type)>>(value);
       return;
    }
}

void FirstprivateRecipeOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);

    if (prop.type) attrs.append("type", prop.type);
}

::llvm::LogicalResult FirstprivateRecipeOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps1(attr, "type", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult FirstprivateRecipeOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.type)))
    return ::mlir::failure();
  return ::mlir::success();
}

void FirstprivateRecipeOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.sym_name);
  writer.writeAttribute(prop.type);
}

::llvm::StringRef FirstprivateRecipeOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::Type FirstprivateRecipeOp::getType() {
  auto attr = getTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

void FirstprivateRecipeOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void FirstprivateRecipeOp::setType(::mlir::Type attrValue) {
  getProperties().type = ::mlir::TypeAttr::get(attrValue);
}

void FirstprivateRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().type = type;
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  (void)odsState.addRegion();
}

void FirstprivateRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().type = type;
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FirstprivateRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::Type type) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().type = ::mlir::TypeAttr::get(type);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  (void)odsState.addRegion();
}

void FirstprivateRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::Type type) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().type = ::mlir::TypeAttr::get(type);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void FirstprivateRecipeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 3; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<FirstprivateRecipeOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult FirstprivateRecipeOp::verifyInvariantsImpl() {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");
  auto tblgen_type = getProperties().type; (void)tblgen_type;
  if (!tblgen_type) return emitOpError("requires attribute 'type'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps1(*this, tblgen_type, "type")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "initRegion", index++)))
        return ::mlir::failure();

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(1)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "copyRegion", index++)))
        return ::mlir::failure();

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(2)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "destroyRegion", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult FirstprivateRecipeOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult FirstprivateRecipeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr sym_nameAttr;
  ::mlir::TypeAttr typeAttr;
  std::unique_ptr<::mlir::Region> initRegionRegion = std::make_unique<::mlir::Region>();
  std::unique_ptr<::mlir::Region> copyRegionRegion = std::make_unique<::mlir::Region>();
  std::unique_ptr<::mlir::Region> destroyRegionRegion = std::make_unique<::mlir::Region>();

  if (parser.parseSymbolName(sym_nameAttr))
    return ::mlir::failure();
  if (sym_nameAttr) result.getOrAddProperties<FirstprivateRecipeOp::Properties>().sym_name = sym_nameAttr;
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(typeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (typeAttr) result.getOrAddProperties<FirstprivateRecipeOp::Properties>().type = typeAttr;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseKeyword("init"))
    return ::mlir::failure();

  if (parser.parseRegion(*initRegionRegion))
    return ::mlir::failure();
  if (parser.parseKeyword("copy"))
    return ::mlir::failure();

  if (parser.parseRegion(*copyRegionRegion))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("destroy"))) {

  if (parser.parseRegion(*destroyRegionRegion))
    return ::mlir::failure();
  }
  result.addRegion(std::move(initRegionRegion));
  result.addRegion(std::move(copyRegionRegion));
  result.addRegion(std::move(destroyRegionRegion));
  return ::mlir::success();
}

void FirstprivateRecipeOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printSymbolName(getSymNameAttr().getValue());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getTypeAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("sym_name");
  elidedAttrs.push_back("type");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << "init";
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getInitRegion());
  _odsPrinter << ' ' << "copy";
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getCopyRegion());
  if (!getDestroyRegion().empty()) {
    _odsPrinter << ' ' << "destroy";
    _odsPrinter << ' ';
    _odsPrinter.printRegion(getDestroyRegion());
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::FirstprivateRecipeOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::GetDevicePtrOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
GetDevicePtrOpGenericAdaptorBase::GetDevicePtrOpGenericAdaptorBase(GetDevicePtrOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> GetDevicePtrOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > GetDevicePtrOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > GetDevicePtrOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr GetDevicePtrOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause GetDevicePtrOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr GetDevicePtrOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool GetDevicePtrOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr GetDevicePtrOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool GetDevicePtrOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > GetDevicePtrOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
GetDevicePtrOpAdaptor::GetDevicePtrOpAdaptor(GetDevicePtrOp op) : GetDevicePtrOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GetDevicePtrOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.getdeviceptr' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.getdeviceptr' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.getdeviceptr' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.getdeviceptr' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.getdeviceptr' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.getdeviceptr' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> GetDevicePtrOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange GetDevicePtrOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange GetDevicePtrOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange GetDevicePtrOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult GetDevicePtrOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute GetDevicePtrOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GetDevicePtrOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> GetDevicePtrOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void GetDevicePtrOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void GetDevicePtrOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult GetDevicePtrOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GetDevicePtrOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void GetDevicePtrOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > GetDevicePtrOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > GetDevicePtrOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause GetDevicePtrOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool GetDevicePtrOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool GetDevicePtrOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > GetDevicePtrOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void GetDevicePtrOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void GetDevicePtrOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void GetDevicePtrOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void GetDevicePtrOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void GetDevicePtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void GetDevicePtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetDevicePtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void GetDevicePtrOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GetDevicePtrOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GetDevicePtrOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void GetDevicePtrOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_getdeviceptr);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult GetDevicePtrOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult GetDevicePtrOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GetDevicePtrOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<GetDevicePtrOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<GetDevicePtrOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void GetDevicePtrOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_getdeviceptr)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void GetDevicePtrOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::GetDevicePtrOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::GlobalConstructorOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
GlobalConstructorOpGenericAdaptorBase::GlobalConstructorOpGenericAdaptorBase(GlobalConstructorOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef GlobalConstructorOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

} // namespace detail
GlobalConstructorOpAdaptor::GlobalConstructorOpAdaptor(GlobalConstructorOp op) : GlobalConstructorOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GlobalConstructorOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'acc.global_ctor' op ""requires attribute 'sym_name'");

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'acc.global_ctor' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

::llvm::LogicalResult GlobalConstructorOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GlobalConstructorOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GlobalConstructorOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GlobalConstructorOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "sym_name")
      return prop.sym_name;
  return std::nullopt;
}

void GlobalConstructorOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }
}

void GlobalConstructorOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);
}

::llvm::LogicalResult GlobalConstructorOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GlobalConstructorOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GlobalConstructorOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.sym_name);
}

::llvm::StringRef GlobalConstructorOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

void GlobalConstructorOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void GlobalConstructorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  (void)odsState.addRegion();
}

void GlobalConstructorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalConstructorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  (void)odsState.addRegion();
}

void GlobalConstructorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalConstructorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GlobalConstructorOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult GlobalConstructorOp::verifyInvariantsImpl() {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult GlobalConstructorOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GlobalConstructorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr sym_nameAttr;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();

  if (parser.parseSymbolName(sym_nameAttr))
    return ::mlir::failure();
  if (sym_nameAttr) result.getOrAddProperties<GlobalConstructorOp::Properties>().sym_name = sym_nameAttr;

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
  return ::mlir::success();
}

void GlobalConstructorOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printSymbolName(getSymNameAttr().getValue());
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getRegion());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("sym_name");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::GlobalConstructorOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::GlobalDestructorOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
GlobalDestructorOpGenericAdaptorBase::GlobalDestructorOpGenericAdaptorBase(GlobalDestructorOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef GlobalDestructorOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

} // namespace detail
GlobalDestructorOpAdaptor::GlobalDestructorOpAdaptor(GlobalDestructorOp op) : GlobalDestructorOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult GlobalDestructorOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'acc.global_dtor' op ""requires attribute 'sym_name'");

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'acc.global_dtor' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

::llvm::LogicalResult GlobalDestructorOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute GlobalDestructorOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code GlobalDestructorOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> GlobalDestructorOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "sym_name")
      return prop.sym_name;
  return std::nullopt;
}

void GlobalDestructorOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }
}

void GlobalDestructorOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);
}

::llvm::LogicalResult GlobalDestructorOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult GlobalDestructorOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();
  return ::mlir::success();
}

void GlobalDestructorOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.sym_name);
}

::llvm::StringRef GlobalDestructorOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

void GlobalDestructorOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void GlobalDestructorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  (void)odsState.addRegion();
}

void GlobalDestructorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalDestructorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  (void)odsState.addRegion();
}

void GlobalDestructorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void GlobalDestructorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<GlobalDestructorOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult GlobalDestructorOp::verifyInvariantsImpl() {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult GlobalDestructorOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult GlobalDestructorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr sym_nameAttr;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();

  if (parser.parseSymbolName(sym_nameAttr))
    return ::mlir::failure();
  if (sym_nameAttr) result.getOrAddProperties<GlobalDestructorOp::Properties>().sym_name = sym_nameAttr;

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
  return ::mlir::success();
}

void GlobalDestructorOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printSymbolName(getSymNameAttr().getValue());
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getRegion());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("sym_name");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::GlobalDestructorOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::HostDataOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
HostDataOpGenericAdaptorBase::HostDataOpGenericAdaptorBase(HostDataOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> HostDataOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::UnitAttr HostDataOpGenericAdaptorBase::getIfPresentAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().ifPresent);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool HostDataOpGenericAdaptorBase::getIfPresent() {
  auto attr = getIfPresentAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
HostDataOpAdaptor::HostDataOpAdaptor(HostDataOp op) : HostDataOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult HostDataOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_ifPresent = getProperties().ifPresent; (void)tblgen_ifPresent;

  if (tblgen_ifPresent && !((::llvm::isa<::mlir::UnitAttr>(tblgen_ifPresent))))
    return emitError(loc, "'acc.host_data' op ""attribute 'ifPresent' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> HostDataOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange HostDataOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange HostDataOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult HostDataOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.ifPresent;
       auto attr = dict.get("ifPresent");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `ifPresent` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute HostDataOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.ifPresent;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("ifPresent",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code HostDataOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.ifPresent.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> HostDataOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "ifPresent")
      return prop.ifPresent;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void HostDataOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "ifPresent") {
       prop.ifPresent = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.ifPresent)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void HostDataOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.ifPresent) attrs.append("ifPresent", prop.ifPresent);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult HostDataOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getIfPresentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "ifPresent", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult HostDataOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.ifPresent)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void HostDataOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.ifPresent);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

bool HostDataOp::getIfPresent() {
  auto attr = getIfPresentAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void HostDataOp::setIfPresent(bool attrValue) {
    auto &odsProp = getProperties().ifPresent;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void HostDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr ifPresent) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (ifPresent) {
    odsState.getOrAddProperties<Properties>().ifPresent = ifPresent;
  }
  (void)odsState.addRegion();
}

void HostDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr ifPresent) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (ifPresent) {
    odsState.getOrAddProperties<Properties>().ifPresent = ifPresent;
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void HostDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange dataClauseOperands, /*optional*/bool ifPresent) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (ifPresent) {
    odsState.getOrAddProperties<Properties>().ifPresent = ((ifPresent) ? odsBuilder.getUnitAttr() : nullptr);
  }
  (void)odsState.addRegion();
}

void HostDataOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange dataClauseOperands, /*optional*/bool ifPresent) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (ifPresent) {
    odsState.getOrAddProperties<Properties>().ifPresent = ((ifPresent) ? odsBuilder.getUnitAttr() : nullptr);
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void HostDataOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<HostDataOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult HostDataOp::verifyInvariantsImpl() {
  auto tblgen_ifPresent = getProperties().ifPresent; (void)tblgen_ifPresent;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_ifPresent, "ifPresent")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult HostDataOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult HostDataOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();
  bool ifClause = false;
  bool dataOperandsClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(ifCondOperands.size()), static_cast<int32_t>(dataClauseOperandsOperands.size())}), result.getOrAddProperties<HostDataOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void HostDataOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getRegion());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getIfPresentAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("ifPresent");
  }
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void HostDataOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::HostDataOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::InitOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
InitOpGenericAdaptorBase::InitOpGenericAdaptorBase(InitOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> InitOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > InitOpGenericAdaptorBase::getDeviceTypes() {
  auto attr = getDeviceTypesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

} // namespace detail
InitOpAdaptor::InitOpAdaptor(InitOp op) : InitOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult InitOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_device_types = getProperties().device_types; (void)tblgen_device_types;

  if (tblgen_device_types && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_device_types))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_device_types), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.init' op ""attribute 'device_types' failed to satisfy constraint: Device type attributes");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> InitOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange InitOp::getDeviceNumOperandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange InitOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult InitOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.device_types;
       auto attr = dict.get("device_types");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `device_types` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute InitOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.device_types;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("device_types",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code InitOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.device_types.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> InitOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "device_types")
      return prop.device_types;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void InitOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "device_types") {
       prop.device_types = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.device_types)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void InitOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.device_types) attrs.append("device_types", prop.device_types);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult InitOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDeviceTypesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps10(attr, "device_types", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult InitOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.device_types)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void InitOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.device_types);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > InitOp::getDeviceTypes() {
  auto attr = getDeviceTypesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

void InitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr device_types, /*optional*/::mlir::Value deviceNumOperand, /*optional*/::mlir::Value ifCond) {
  if (deviceNumOperand)
    odsState.addOperands(deviceNumOperand);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(deviceNumOperand ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (device_types) {
    odsState.getOrAddProperties<Properties>().device_types = device_types;
  }
}

void InitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr device_types, /*optional*/::mlir::Value deviceNumOperand, /*optional*/::mlir::Value ifCond) {
  if (deviceNumOperand)
    odsState.addOperands(deviceNumOperand);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(deviceNumOperand ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (device_types) {
    odsState.getOrAddProperties<Properties>().device_types = device_types;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void InitOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<InitOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult InitOp::verifyInvariantsImpl() {
  auto tblgen_device_types = getProperties().device_types; (void)tblgen_device_types;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps10(*this, tblgen_device_types, "device_types")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult InitOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult InitOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> deviceNumOperandOperands;
  ::llvm::SMLoc deviceNumOperandOperandsLoc;
  (void)deviceNumOperandOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> deviceNumOperandTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  bool device_numClause = false;
  bool ifClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("device_num"))) {

  if (device_numClause) {
    return parser.emitError(parser.getNameLoc())
          << "`device_num` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  device_numClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    deviceNumOperandOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      deviceNumOperandOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      deviceNumOperandTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(deviceNumOperandOperands.size()), static_cast<int32_t>(ifCondOperands.size())}), result.getOrAddProperties<InitOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(deviceNumOperandOperands, deviceNumOperandTypes, deviceNumOperandOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void InitOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getDeviceNumOperand()) {
  _odsPrinter << ' ' << "device_num";
  _odsPrinter << "(";
  if (::mlir::Value value = getDeviceNumOperand())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getDeviceNumOperand() ? ::llvm::ArrayRef<::mlir::Type>(getDeviceNumOperand().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::InitOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::KernelsOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
KernelsOpGenericAdaptorBase::KernelsOpGenericAdaptorBase(KernelsOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> KernelsOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > KernelsOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> KernelsOpGenericAdaptorBase::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOpGenericAdaptorBase::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOpGenericAdaptorBase::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOpGenericAdaptorBase::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> KernelsOpGenericAdaptorBase::getNumGangsSegments() {
  auto attr = getNumGangsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOpGenericAdaptorBase::getNumGangsDeviceType() {
  auto attr = getNumGangsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOpGenericAdaptorBase::getNumWorkersDeviceType() {
  auto attr = getNumWorkersDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOpGenericAdaptorBase::getVectorLengthDeviceType() {
  auto attr = getVectorLengthDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::UnitAttr KernelsOpGenericAdaptorBase::getSelfAttrAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().selfAttr);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool KernelsOpGenericAdaptorBase::getSelfAttr() {
  auto attr = getSelfAttrAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional<::mlir::acc::ClauseDefaultValue> KernelsOpGenericAdaptorBase::getDefaultAttr() {
  auto attr = getDefaultAttrAttr();
  return attr ? ::std::optional<::mlir::acc::ClauseDefaultValue>(attr.getValue()) : (::std::nullopt);
}

::mlir::UnitAttr KernelsOpGenericAdaptorBase::getCombinedAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().combined);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool KernelsOpGenericAdaptorBase::getCombined() {
  auto attr = getCombinedAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
KernelsOpAdaptor::KernelsOpAdaptor(KernelsOp op) : KernelsOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult KernelsOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_combined = getProperties().combined; (void)tblgen_combined;
  auto tblgen_defaultAttr = getProperties().defaultAttr; (void)tblgen_defaultAttr;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_numGangsDeviceType = getProperties().numGangsDeviceType; (void)tblgen_numGangsDeviceType;
  auto tblgen_numGangsSegments = getProperties().numGangsSegments; (void)tblgen_numGangsSegments;
  auto tblgen_numWorkersDeviceType = getProperties().numWorkersDeviceType; (void)tblgen_numWorkersDeviceType;
  auto tblgen_selfAttr = getProperties().selfAttr; (void)tblgen_selfAttr;
  auto tblgen_vectorLengthDeviceType = getProperties().vectorLengthDeviceType; (void)tblgen_vectorLengthDeviceType;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.kernels' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.kernels' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_waitOperandsSegments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_waitOperandsSegments))))
    return emitError(loc, "'acc.kernels' op ""attribute 'waitOperandsSegments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_waitOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.kernels' op ""attribute 'waitOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_hasWaitDevnum && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_hasWaitDevnum))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_hasWaitDevnum), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::BoolAttr>(attr))); }))))
    return emitError(loc, "'acc.kernels' op ""attribute 'hasWaitDevnum' failed to satisfy constraint: 1-bit boolean array attribute");

  if (tblgen_waitOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.kernels' op ""attribute 'waitOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_numGangsSegments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_numGangsSegments))))
    return emitError(loc, "'acc.kernels' op ""attribute 'numGangsSegments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_numGangsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_numGangsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_numGangsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.kernels' op ""attribute 'numGangsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_numWorkersDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_numWorkersDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_numWorkersDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.kernels' op ""attribute 'numWorkersDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_vectorLengthDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_vectorLengthDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_vectorLengthDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.kernels' op ""attribute 'vectorLengthDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_selfAttr && !((::llvm::isa<::mlir::UnitAttr>(tblgen_selfAttr))))
    return emitError(loc, "'acc.kernels' op ""attribute 'selfAttr' failed to satisfy constraint: unit attribute");

  if (tblgen_defaultAttr && !((::llvm::isa<::mlir::acc::ClauseDefaultValueAttr>(tblgen_defaultAttr))))
    return emitError(loc, "'acc.kernels' op ""attribute 'defaultAttr' failed to satisfy constraint: DefaultValue Clause");

  if (tblgen_combined && !((::llvm::isa<::mlir::UnitAttr>(tblgen_combined))))
    return emitError(loc, "'acc.kernels' op ""attribute 'combined' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> KernelsOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange KernelsOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange KernelsOp::getWaitOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange KernelsOp::getNumGangsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange KernelsOp::getNumWorkersMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange KernelsOp::getVectorLengthMutable() {
  auto range = getODSOperandIndexAndLength(4);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(4u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange KernelsOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(5);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(5u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange KernelsOp::getSelfCondMutable() {
  auto range = getODSOperandIndexAndLength(6);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(6u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange KernelsOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(7);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(7u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult KernelsOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.combined;
       auto attr = dict.get("combined");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `combined` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.defaultAttr;
       auto attr = dict.get("defaultAttr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `defaultAttr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.hasWaitDevnum;
       auto attr = dict.get("hasWaitDevnum");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `hasWaitDevnum` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.numGangsDeviceType;
       auto attr = dict.get("numGangsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `numGangsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.numGangsSegments;
       auto attr = dict.get("numGangsSegments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `numGangsSegments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.numWorkersDeviceType;
       auto attr = dict.get("numWorkersDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `numWorkersDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.selfAttr;
       auto attr = dict.get("selfAttr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `selfAttr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.vectorLengthDeviceType;
       auto attr = dict.get("vectorLengthDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `vectorLengthDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOnly;
       auto attr = dict.get("waitOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsDeviceType;
       auto attr = dict.get("waitOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsSegments;
       auto attr = dict.get("waitOperandsSegments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsSegments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute KernelsOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.combined;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("combined",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.defaultAttr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("defaultAttr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.hasWaitDevnum;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("hasWaitDevnum",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.numGangsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("numGangsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.numGangsSegments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("numGangsSegments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.numWorkersDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("numWorkersDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.selfAttr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("selfAttr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.vectorLengthDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("vectorLengthDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsSegments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsSegments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code KernelsOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.combined.getAsOpaquePointer()), 
    llvm::hash_value(prop.defaultAttr.getAsOpaquePointer()), 
    llvm::hash_value(prop.hasWaitDevnum.getAsOpaquePointer()), 
    llvm::hash_value(prop.numGangsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.numGangsSegments.getAsOpaquePointer()), 
    llvm::hash_value(prop.numWorkersDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.selfAttr.getAsOpaquePointer()), 
    llvm::hash_value(prop.vectorLengthDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsSegments.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> KernelsOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "combined")
      return prop.combined;

    if (name == "defaultAttr")
      return prop.defaultAttr;

    if (name == "hasWaitDevnum")
      return prop.hasWaitDevnum;

    if (name == "numGangsDeviceType")
      return prop.numGangsDeviceType;

    if (name == "numGangsSegments")
      return prop.numGangsSegments;

    if (name == "numWorkersDeviceType")
      return prop.numWorkersDeviceType;

    if (name == "selfAttr")
      return prop.selfAttr;

    if (name == "vectorLengthDeviceType")
      return prop.vectorLengthDeviceType;

    if (name == "waitOnly")
      return prop.waitOnly;

    if (name == "waitOperandsDeviceType")
      return prop.waitOperandsDeviceType;

    if (name == "waitOperandsSegments")
      return prop.waitOperandsSegments;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void KernelsOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "combined") {
       prop.combined = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.combined)>>(value);
       return;
    }

    if (name == "defaultAttr") {
       prop.defaultAttr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.defaultAttr)>>(value);
       return;
    }

    if (name == "hasWaitDevnum") {
       prop.hasWaitDevnum = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.hasWaitDevnum)>>(value);
       return;
    }

    if (name == "numGangsDeviceType") {
       prop.numGangsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.numGangsDeviceType)>>(value);
       return;
    }

    if (name == "numGangsSegments") {
       prop.numGangsSegments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.numGangsSegments)>>(value);
       return;
    }

    if (name == "numWorkersDeviceType") {
       prop.numWorkersDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.numWorkersDeviceType)>>(value);
       return;
    }

    if (name == "selfAttr") {
       prop.selfAttr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.selfAttr)>>(value);
       return;
    }

    if (name == "vectorLengthDeviceType") {
       prop.vectorLengthDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.vectorLengthDeviceType)>>(value);
       return;
    }

    if (name == "waitOnly") {
       prop.waitOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOnly)>>(value);
       return;
    }

    if (name == "waitOperandsDeviceType") {
       prop.waitOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsDeviceType)>>(value);
       return;
    }

    if (name == "waitOperandsSegments") {
       prop.waitOperandsSegments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsSegments)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void KernelsOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.combined) attrs.append("combined", prop.combined);

    if (prop.defaultAttr) attrs.append("defaultAttr", prop.defaultAttr);

    if (prop.hasWaitDevnum) attrs.append("hasWaitDevnum", prop.hasWaitDevnum);

    if (prop.numGangsDeviceType) attrs.append("numGangsDeviceType", prop.numGangsDeviceType);

    if (prop.numGangsSegments) attrs.append("numGangsSegments", prop.numGangsSegments);

    if (prop.numWorkersDeviceType) attrs.append("numWorkersDeviceType", prop.numWorkersDeviceType);

    if (prop.selfAttr) attrs.append("selfAttr", prop.selfAttr);

    if (prop.vectorLengthDeviceType) attrs.append("vectorLengthDeviceType", prop.vectorLengthDeviceType);

    if (prop.waitOnly) attrs.append("waitOnly", prop.waitOnly);

    if (prop.waitOperandsDeviceType) attrs.append("waitOperandsDeviceType", prop.waitOperandsDeviceType);

    if (prop.waitOperandsSegments) attrs.append("waitOperandsSegments", prop.waitOperandsSegments);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult KernelsOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCombinedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "combined", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDefaultAttrAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps8(attr, "defaultAttr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getHasWaitDevnumAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(attr, "hasWaitDevnum", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNumGangsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "numGangsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNumGangsSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(attr, "numGangsSegments", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNumWorkersDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "numWorkersDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSelfAttrAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "selfAttr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVectorLengthDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "vectorLengthDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(attr, "waitOperandsSegments", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult KernelsOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.combined)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.defaultAttr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.hasWaitDevnum)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.numGangsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.numGangsSegments)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.numWorkersDeviceType)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.selfAttr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.vectorLengthDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsSegments)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void KernelsOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.combined);

  writer.writeOptionalAttribute(prop.defaultAttr);

  writer.writeOptionalAttribute(prop.hasWaitDevnum);

  writer.writeOptionalAttribute(prop.numGangsDeviceType);

  writer.writeOptionalAttribute(prop.numGangsSegments);

  writer.writeOptionalAttribute(prop.numWorkersDeviceType);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.selfAttr);

  writer.writeOptionalAttribute(prop.vectorLengthDeviceType);

  writer.writeOptionalAttribute(prop.waitOnly);

  writer.writeOptionalAttribute(prop.waitOperandsDeviceType);

  writer.writeOptionalAttribute(prop.waitOperandsSegments);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > KernelsOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> KernelsOp::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOp::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOp::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOp::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> KernelsOp::getNumGangsSegments() {
  auto attr = getNumGangsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOp::getNumGangsDeviceType() {
  auto attr = getNumGangsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOp::getNumWorkersDeviceType() {
  auto attr = getNumWorkersDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > KernelsOp::getVectorLengthDeviceType() {
  auto attr = getVectorLengthDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

bool KernelsOp::getSelfAttr() {
  auto attr = getSelfAttrAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional<::mlir::acc::ClauseDefaultValue> KernelsOp::getDefaultAttr() {
  auto attr = getDefaultAttrAttr();
  return attr ? ::std::optional<::mlir::acc::ClauseDefaultValue>(attr.getValue()) : (::std::nullopt);
}

bool KernelsOp::getCombined() {
  auto attr = getCombinedAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void KernelsOp::setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().waitOperandsSegments;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void KernelsOp::setNumGangsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().numGangsSegments;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void KernelsOp::setSelfAttr(bool attrValue) {
    auto &odsProp = getProperties().selfAttr;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void KernelsOp::setDefaultAttr(::std::optional<::mlir::acc::ClauseDefaultValue> attrValue) {
    auto &odsProp = getProperties().defaultAttr;
    if (attrValue)
      odsProp = ::mlir::acc::ClauseDefaultValueAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void KernelsOp::setCombined(bool attrValue) {
    auto &odsProp = getProperties().combined;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void KernelsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/::mlir::UnitAttr combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(numGangs);
  odsState.addOperands(numWorkers);
  odsState.addOperands(vectorLength);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(numGangs.size()), static_cast<int32_t>(numWorkers.size()), static_cast<int32_t>(vectorLength.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (numGangsSegments) {
    odsState.getOrAddProperties<Properties>().numGangsSegments = numGangsSegments;
  }
  if (numGangsDeviceType) {
    odsState.getOrAddProperties<Properties>().numGangsDeviceType = numGangsDeviceType;
  }
  if (numWorkersDeviceType) {
    odsState.getOrAddProperties<Properties>().numWorkersDeviceType = numWorkersDeviceType;
  }
  if (vectorLengthDeviceType) {
    odsState.getOrAddProperties<Properties>().vectorLengthDeviceType = vectorLengthDeviceType;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = selfAttr;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = combined;
  }
  (void)odsState.addRegion();
}

void KernelsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/::mlir::UnitAttr combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(numGangs);
  odsState.addOperands(numWorkers);
  odsState.addOperands(vectorLength);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(numGangs.size()), static_cast<int32_t>(numWorkers.size()), static_cast<int32_t>(vectorLength.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (numGangsSegments) {
    odsState.getOrAddProperties<Properties>().numGangsSegments = numGangsSegments;
  }
  if (numGangsDeviceType) {
    odsState.getOrAddProperties<Properties>().numGangsDeviceType = numGangsDeviceType;
  }
  if (numWorkersDeviceType) {
    odsState.getOrAddProperties<Properties>().numWorkersDeviceType = numWorkersDeviceType;
  }
  if (vectorLengthDeviceType) {
    odsState.getOrAddProperties<Properties>().vectorLengthDeviceType = vectorLengthDeviceType;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = selfAttr;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = combined;
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void KernelsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/bool combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(numGangs);
  odsState.addOperands(numWorkers);
  odsState.addOperands(vectorLength);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(numGangs.size()), static_cast<int32_t>(numWorkers.size()), static_cast<int32_t>(vectorLength.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (numGangsSegments) {
    odsState.getOrAddProperties<Properties>().numGangsSegments = numGangsSegments;
  }
  if (numGangsDeviceType) {
    odsState.getOrAddProperties<Properties>().numGangsDeviceType = numGangsDeviceType;
  }
  if (numWorkersDeviceType) {
    odsState.getOrAddProperties<Properties>().numWorkersDeviceType = numWorkersDeviceType;
  }
  if (vectorLengthDeviceType) {
    odsState.getOrAddProperties<Properties>().vectorLengthDeviceType = vectorLengthDeviceType;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = ((selfAttr) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = ((combined) ? odsBuilder.getUnitAttr() : nullptr);
  }
  (void)odsState.addRegion();
}

void KernelsOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/bool combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(numGangs);
  odsState.addOperands(numWorkers);
  odsState.addOperands(vectorLength);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(numGangs.size()), static_cast<int32_t>(numWorkers.size()), static_cast<int32_t>(vectorLength.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (numGangsSegments) {
    odsState.getOrAddProperties<Properties>().numGangsSegments = numGangsSegments;
  }
  if (numGangsDeviceType) {
    odsState.getOrAddProperties<Properties>().numGangsDeviceType = numGangsDeviceType;
  }
  if (numWorkersDeviceType) {
    odsState.getOrAddProperties<Properties>().numWorkersDeviceType = numWorkersDeviceType;
  }
  if (vectorLengthDeviceType) {
    odsState.getOrAddProperties<Properties>().vectorLengthDeviceType = vectorLengthDeviceType;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = ((selfAttr) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = ((combined) ? odsBuilder.getUnitAttr() : nullptr);
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void KernelsOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<KernelsOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult KernelsOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_combined = getProperties().combined; (void)tblgen_combined;
  auto tblgen_defaultAttr = getProperties().defaultAttr; (void)tblgen_defaultAttr;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_numGangsDeviceType = getProperties().numGangsDeviceType; (void)tblgen_numGangsDeviceType;
  auto tblgen_numGangsSegments = getProperties().numGangsSegments; (void)tblgen_numGangsSegments;
  auto tblgen_numWorkersDeviceType = getProperties().numWorkersDeviceType; (void)tblgen_numWorkersDeviceType;
  auto tblgen_selfAttr = getProperties().selfAttr; (void)tblgen_selfAttr;
  auto tblgen_vectorLengthDeviceType = getProperties().vectorLengthDeviceType; (void)tblgen_vectorLengthDeviceType;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(*this, tblgen_waitOperandsSegments, "waitOperandsSegments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOperandsDeviceType, "waitOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(*this, tblgen_hasWaitDevnum, "hasWaitDevnum")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOnly, "waitOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(*this, tblgen_numGangsSegments, "numGangsSegments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_numGangsDeviceType, "numGangsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_numWorkersDeviceType, "numWorkersDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_vectorLengthDeviceType, "vectorLengthDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_selfAttr, "selfAttr")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps8(*this, tblgen_defaultAttr, "defaultAttr")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_combined, "combined")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup5 = getODSOperands(5);

    if (valueGroup5.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup5.size();
    }

    for (auto v : valueGroup5) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup6 = getODSOperands(6);

    if (valueGroup6.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup6.size();
    }

    for (auto v : valueGroup6) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup7 = getODSOperands(7);

    for (auto v : valueGroup7) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult KernelsOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult KernelsOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> numGangsOperands;
  ::llvm::SMLoc numGangsOperandsLoc;
  (void)numGangsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> numGangsTypes;
  ::mlir::ArrayAttr numGangsDeviceTypeAttr;
  ::mlir::DenseI32ArrayAttr numGangsSegmentsAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> numWorkersOperands;
  ::llvm::SMLoc numWorkersOperandsLoc;
  (void)numWorkersOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> numWorkersTypes;
  ::mlir::ArrayAttr numWorkersDeviceTypeAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> vectorLengthOperands;
  ::llvm::SMLoc vectorLengthOperandsLoc;
  (void)vectorLengthOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> vectorLengthTypes;
  ::mlir::ArrayAttr vectorLengthDeviceTypeAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitOperandsOperands;
  ::llvm::SMLoc waitOperandsOperandsLoc;
  (void)waitOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitOperandsTypes;
  ::mlir::ArrayAttr waitOperandsDeviceTypeAttr;
  ::mlir::DenseI32ArrayAttr waitOperandsSegmentsAttr;
  ::mlir::ArrayAttr hasWaitDevnumAttr;
  ::mlir::ArrayAttr waitOnlyAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> selfCondOperands;
  ::llvm::SMLoc selfCondOperandsLoc;
  (void)selfCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();
  if (::mlir::succeeded(parser.parseOptionalKeyword("combined"))) {
    result.getOrAddProperties<KernelsOp::Properties>().combined = parser.getBuilder().getUnitAttr();  if (parser.parseLParen())
    return ::mlir::failure();
  if (parser.parseKeyword("loop"))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  bool dataOperandsClause = false;
  bool asyncClause = false;
  bool num_gangsClause = false;
  bool num_workersClause = false;
  bool vector_lengthClause = false;
  bool waitClause = false;
  bool selfClause = false;
  bool ifClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<KernelsOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("num_gangs"))) {

  if (num_gangsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`num_gangs` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  num_gangsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    numGangsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseNumGangs(parser, numGangsOperands, numGangsTypes, numGangsDeviceTypeAttr, numGangsSegmentsAttr);
    if (odsResult) return ::mlir::failure();
    if (numGangsDeviceTypeAttr)
      result.getOrAddProperties<KernelsOp::Properties>().numGangsDeviceType = numGangsDeviceTypeAttr;
    if (numGangsSegmentsAttr)
      result.getOrAddProperties<KernelsOp::Properties>().numGangsSegments = numGangsSegmentsAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("num_workers"))) {

  if (num_workersClause) {
    return parser.emitError(parser.getNameLoc())
          << "`num_workers` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  num_workersClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    numWorkersOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, numWorkersOperands, numWorkersTypes, numWorkersDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (numWorkersDeviceTypeAttr)
      result.getOrAddProperties<KernelsOp::Properties>().numWorkersDeviceType = numWorkersDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("vector_length"))) {

  if (vector_lengthClause) {
    return parser.emitError(parser.getNameLoc())
          << "`vector_length` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  vector_lengthClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    vectorLengthOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, vectorLengthOperands, vectorLengthTypes, vectorLengthDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (vectorLengthDeviceTypeAttr)
      result.getOrAddProperties<KernelsOp::Properties>().vectorLengthDeviceType = vectorLengthDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("wait"))) {

  if (waitClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  waitClause = true;
  {
    waitOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseWaitClause(parser, waitOperandsOperands, waitOperandsTypes, waitOperandsDeviceTypeAttr, waitOperandsSegmentsAttr, hasWaitDevnumAttr, waitOnlyAttr);
    if (odsResult) return ::mlir::failure();
    if (waitOperandsDeviceTypeAttr)
      result.getOrAddProperties<KernelsOp::Properties>().waitOperandsDeviceType = waitOperandsDeviceTypeAttr;
    if (waitOperandsSegmentsAttr)
      result.getOrAddProperties<KernelsOp::Properties>().waitOperandsSegments = waitOperandsSegmentsAttr;
    if (hasWaitDevnumAttr)
      result.getOrAddProperties<KernelsOp::Properties>().hasWaitDevnum = hasWaitDevnumAttr;
    if (waitOnlyAttr)
      result.getOrAddProperties<KernelsOp::Properties>().waitOnly = waitOnlyAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("self"))) {

  if (selfClause) {
    return parser.emitError(parser.getNameLoc())
          << "`self` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  selfClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    selfCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      selfCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperandsOperands.size()), static_cast<int32_t>(waitOperandsOperands.size()), static_cast<int32_t>(numGangsOperands.size()), static_cast<int32_t>(numWorkersOperands.size()), static_cast<int32_t>(vectorLengthOperands.size()), static_cast<int32_t>(ifCondOperands.size()), static_cast<int32_t>(selfCondOperands.size()), static_cast<int32_t>(dataClauseOperandsOperands.size())}), result.getOrAddProperties<KernelsOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitOperandsOperands, waitOperandsTypes, waitOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(numGangsOperands, numGangsTypes, numGangsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(numWorkersOperands, numWorkersTypes, numWorkersOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(vectorLengthOperands, vectorLengthTypes, vectorLengthOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(selfCondOperands, odsBuildableType0, selfCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void KernelsOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if ((getCombinedAttr() && getCombinedAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "combined";
    _odsPrinter << "(";
    _odsPrinter << "loop";
    _odsPrinter << ")";
  }
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  if (false || getNumGangs().size() || (getNumGangsDeviceTypeAttr()) || (getNumGangsSegmentsAttr())) {
  _odsPrinter << ' ' << "num_gangs";
  _odsPrinter << "(";
  printNumGangs(_odsPrinter, *this, getNumGangs(), getNumGangs().getTypes(), getNumGangsDeviceTypeAttr(), getNumGangsSegmentsAttr());
  _odsPrinter << ")";
  }
  if (false || getNumWorkers().size() || (getNumWorkersDeviceTypeAttr())) {
  _odsPrinter << ' ' << "num_workers";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getNumWorkers(), getNumWorkers().getTypes(), getNumWorkersDeviceTypeAttr());
  _odsPrinter << ")";
  }
  if (false || getVectorLength().size() || (getVectorLengthDeviceTypeAttr())) {
  _odsPrinter << ' ' << "vector_length";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getVectorLength(), getVectorLength().getTypes(), getVectorLengthDeviceTypeAttr());
  _odsPrinter << ")";
  }
  if (false || getWaitOperands().size() || (getWaitOperandsDeviceTypeAttr()) || (getWaitOperandsSegmentsAttr()) || (getHasWaitDevnumAttr()) || (getWaitOnlyAttr())) {
  _odsPrinter << ' ' << "wait";
  printWaitClause(_odsPrinter, *this, getWaitOperands(), getWaitOperands().getTypes(), getWaitOperandsDeviceTypeAttr(), getWaitOperandsSegmentsAttr(), getHasWaitDevnumAttr(), getWaitOnlyAttr());
  }
  if (false || getSelfCond()) {
  _odsPrinter << ' ' << "self";
  _odsPrinter << "(";
  if (::mlir::Value value = getSelfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getRegion());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("combined");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  elidedAttrs.push_back("numGangsDeviceType");
  elidedAttrs.push_back("numGangsSegments");
  elidedAttrs.push_back("numWorkersDeviceType");
  elidedAttrs.push_back("vectorLengthDeviceType");
  elidedAttrs.push_back("waitOperandsDeviceType");
  elidedAttrs.push_back("waitOperandsSegments");
  elidedAttrs.push_back("hasWaitDevnum");
  elidedAttrs.push_back("waitOnly");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getSelfAttrAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("selfAttr");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getCombinedAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("combined");
  }
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void KernelsOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::KernelsOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::LoopOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
LoopOpGenericAdaptorBase::LoopOpGenericAdaptorBase(LoopOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> LoopOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional<::llvm::ArrayRef<bool>> LoopOpGenericAdaptorBase::getInclusiveUpperbound() {
  auto attr = getInclusiveUpperboundAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<bool>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getCollapse() {
  auto attr = getCollapseAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getCollapseDeviceType() {
  auto attr = getCollapseDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getGangOperandsArgType() {
  auto attr = getGangOperandsArgTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> LoopOpGenericAdaptorBase::getGangOperandsSegments() {
  auto attr = getGangOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getGangOperandsDeviceType() {
  auto attr = getGangOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getWorkerNumOperandsDeviceType() {
  auto attr = getWorkerNumOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getVectorOperandsDeviceType() {
  auto attr = getVectorOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getSeq() {
  auto attr = getSeqAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getIndependent() {
  auto attr = getIndependentAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getAuto_() {
  auto attr = getAuto_Attr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getGang() {
  auto attr = getGangAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getWorker() {
  auto attr = getWorkerAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getVector() {
  auto attr = getVectorAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> LoopOpGenericAdaptorBase::getTileOperandsSegments() {
  auto attr = getTileOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getTileOperandsDeviceType() {
  auto attr = getTileOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getPrivatizations() {
  auto attr = getPrivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOpGenericAdaptorBase::getReductionRecipes() {
  auto attr = getReductionRecipesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::mlir::acc::CombinedConstructsType> LoopOpGenericAdaptorBase::getCombined() {
  auto attr = getCombinedAttr();
  return attr ? ::std::optional<::mlir::acc::CombinedConstructsType>(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
LoopOpAdaptor::LoopOpAdaptor(LoopOp op) : LoopOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult LoopOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_auto_ = getProperties().auto_; (void)tblgen_auto_;
  auto tblgen_collapse = getProperties().collapse; (void)tblgen_collapse;
  auto tblgen_collapseDeviceType = getProperties().collapseDeviceType; (void)tblgen_collapseDeviceType;
  auto tblgen_combined = getProperties().combined; (void)tblgen_combined;
  auto tblgen_gang = getProperties().gang; (void)tblgen_gang;
  auto tblgen_gangOperandsArgType = getProperties().gangOperandsArgType; (void)tblgen_gangOperandsArgType;
  auto tblgen_gangOperandsDeviceType = getProperties().gangOperandsDeviceType; (void)tblgen_gangOperandsDeviceType;
  auto tblgen_gangOperandsSegments = getProperties().gangOperandsSegments; (void)tblgen_gangOperandsSegments;
  auto tblgen_inclusiveUpperbound = getProperties().inclusiveUpperbound; (void)tblgen_inclusiveUpperbound;
  auto tblgen_independent = getProperties().independent; (void)tblgen_independent;
  auto tblgen_privatizations = getProperties().privatizations; (void)tblgen_privatizations;
  auto tblgen_reductionRecipes = getProperties().reductionRecipes; (void)tblgen_reductionRecipes;
  auto tblgen_seq = getProperties().seq; (void)tblgen_seq;
  auto tblgen_tileOperandsDeviceType = getProperties().tileOperandsDeviceType; (void)tblgen_tileOperandsDeviceType;
  auto tblgen_tileOperandsSegments = getProperties().tileOperandsSegments; (void)tblgen_tileOperandsSegments;
  auto tblgen_vector = getProperties().vector; (void)tblgen_vector;
  auto tblgen_vectorOperandsDeviceType = getProperties().vectorOperandsDeviceType; (void)tblgen_vectorOperandsDeviceType;
  auto tblgen_worker = getProperties().worker; (void)tblgen_worker;
  auto tblgen_workerNumOperandsDeviceType = getProperties().workerNumOperandsDeviceType; (void)tblgen_workerNumOperandsDeviceType;

  if (tblgen_inclusiveUpperbound && !((::llvm::isa<::mlir::DenseBoolArrayAttr>(tblgen_inclusiveUpperbound))))
    return emitError(loc, "'acc.loop' op ""attribute 'inclusiveUpperbound' failed to satisfy constraint: i1 dense array attribute");

  if (tblgen_collapse && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_collapse))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_collapse), [&](::mlir::Attribute attr) { return attr && (((::llvm::isa<::mlir::IntegerAttr>(attr))) && ((::llvm::cast<::mlir::IntegerAttr>(attr).getType().isSignlessInteger(64)))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'collapse' failed to satisfy constraint: 64-bit integer array attribute");

  if (tblgen_collapseDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_collapseDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_collapseDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'collapseDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_gangOperandsArgType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_gangOperandsArgType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_gangOperandsArgType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::GangArgTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'gangOperandsArgType' failed to satisfy constraint: gang arg type array attribute");

  if (tblgen_gangOperandsSegments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_gangOperandsSegments))))
    return emitError(loc, "'acc.loop' op ""attribute 'gangOperandsSegments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_gangOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_gangOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_gangOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'gangOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_workerNumOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_workerNumOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_workerNumOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'workerNumOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_vectorOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_vectorOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_vectorOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'vectorOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_seq && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_seq))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_seq), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'seq' failed to satisfy constraint: device type array attribute");

  if (tblgen_independent && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_independent))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_independent), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'independent' failed to satisfy constraint: device type array attribute");

  if (tblgen_auto_ && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_auto_))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_auto_), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'auto_' failed to satisfy constraint: device type array attribute");

  if (tblgen_gang && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_gang))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_gang), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'gang' failed to satisfy constraint: device type array attribute");

  if (tblgen_worker && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_worker))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_worker), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'worker' failed to satisfy constraint: device type array attribute");

  if (tblgen_vector && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_vector))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_vector), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'vector' failed to satisfy constraint: device type array attribute");

  if (tblgen_tileOperandsSegments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_tileOperandsSegments))))
    return emitError(loc, "'acc.loop' op ""attribute 'tileOperandsSegments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_tileOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_tileOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_tileOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'tileOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_privatizations && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_privatizations))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_privatizations), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::SymbolRefAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'privatizations' failed to satisfy constraint: symbol ref array attribute");

  if (tblgen_reductionRecipes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_reductionRecipes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_reductionRecipes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::SymbolRefAttr>(attr))); }))))
    return emitError(loc, "'acc.loop' op ""attribute 'reductionRecipes' failed to satisfy constraint: symbol ref array attribute");

  if (tblgen_combined && !((::llvm::isa<::mlir::acc::CombinedConstructsTypeAttr>(tblgen_combined))))
    return emitError(loc, "'acc.loop' op ""attribute 'combined' failed to satisfy constraint: Differentiate between combined constructs");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> LoopOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange LoopOp::getLowerboundMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange LoopOp::getUpperboundMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange LoopOp::getStepMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange LoopOp::getGangOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange LoopOp::getWorkerNumOperandsMutable() {
  auto range = getODSOperandIndexAndLength(4);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(4u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange LoopOp::getVectorOperandsMutable() {
  auto range = getODSOperandIndexAndLength(5);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(5u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange LoopOp::getTileOperandsMutable() {
  auto range = getODSOperandIndexAndLength(6);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(6u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange LoopOp::getCacheOperandsMutable() {
  auto range = getODSOperandIndexAndLength(7);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(7u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange LoopOp::getPrivateOperandsMutable() {
  auto range = getODSOperandIndexAndLength(8);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(8u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange LoopOp::getReductionOperandsMutable() {
  auto range = getODSOperandIndexAndLength(9);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(9u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

std::pair<unsigned, unsigned> LoopOp::getODSResultIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumResults() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::llvm::LogicalResult LoopOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.auto_;
       auto attr = dict.get("auto_");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `auto_` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.collapse;
       auto attr = dict.get("collapse");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `collapse` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.collapseDeviceType;
       auto attr = dict.get("collapseDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `collapseDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.combined;
       auto attr = dict.get("combined");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `combined` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.gang;
       auto attr = dict.get("gang");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `gang` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.gangOperandsArgType;
       auto attr = dict.get("gangOperandsArgType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `gangOperandsArgType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.gangOperandsDeviceType;
       auto attr = dict.get("gangOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `gangOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.gangOperandsSegments;
       auto attr = dict.get("gangOperandsSegments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `gangOperandsSegments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.inclusiveUpperbound;
       auto attr = dict.get("inclusiveUpperbound");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `inclusiveUpperbound` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.independent;
       auto attr = dict.get("independent");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `independent` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.privatizations;
       auto attr = dict.get("privatizations");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `privatizations` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.reductionRecipes;
       auto attr = dict.get("reductionRecipes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `reductionRecipes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.seq;
       auto attr = dict.get("seq");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `seq` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.tileOperandsDeviceType;
       auto attr = dict.get("tileOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `tileOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.tileOperandsSegments;
       auto attr = dict.get("tileOperandsSegments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `tileOperandsSegments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.vector;
       auto attr = dict.get("vector");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `vector` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.vectorOperandsDeviceType;
       auto attr = dict.get("vectorOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `vectorOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.worker;
       auto attr = dict.get("worker");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `worker` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.workerNumOperandsDeviceType;
       auto attr = dict.get("workerNumOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `workerNumOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute LoopOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.auto_;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("auto_",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.collapse;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("collapse",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.collapseDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("collapseDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.combined;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("combined",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.gang;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("gang",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.gangOperandsArgType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("gangOperandsArgType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.gangOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("gangOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.gangOperandsSegments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("gangOperandsSegments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.inclusiveUpperbound;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("inclusiveUpperbound",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.independent;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("independent",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.privatizations;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("privatizations",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.reductionRecipes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("reductionRecipes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.seq;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("seq",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.tileOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("tileOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.tileOperandsSegments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("tileOperandsSegments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.vector;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("vector",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.vectorOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("vectorOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.worker;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("worker",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.workerNumOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("workerNumOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code LoopOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.auto_.getAsOpaquePointer()), 
    llvm::hash_value(prop.collapse.getAsOpaquePointer()), 
    llvm::hash_value(prop.collapseDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.combined.getAsOpaquePointer()), 
    llvm::hash_value(prop.gang.getAsOpaquePointer()), 
    llvm::hash_value(prop.gangOperandsArgType.getAsOpaquePointer()), 
    llvm::hash_value(prop.gangOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.gangOperandsSegments.getAsOpaquePointer()), 
    llvm::hash_value(prop.inclusiveUpperbound.getAsOpaquePointer()), 
    llvm::hash_value(prop.independent.getAsOpaquePointer()), 
    llvm::hash_value(prop.privatizations.getAsOpaquePointer()), 
    llvm::hash_value(prop.reductionRecipes.getAsOpaquePointer()), 
    llvm::hash_value(prop.seq.getAsOpaquePointer()), 
    llvm::hash_value(prop.tileOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.tileOperandsSegments.getAsOpaquePointer()), 
    llvm::hash_value(prop.vector.getAsOpaquePointer()), 
    llvm::hash_value(prop.vectorOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.worker.getAsOpaquePointer()), 
    llvm::hash_value(prop.workerNumOperandsDeviceType.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> LoopOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "auto_")
      return prop.auto_;

    if (name == "collapse")
      return prop.collapse;

    if (name == "collapseDeviceType")
      return prop.collapseDeviceType;

    if (name == "combined")
      return prop.combined;

    if (name == "gang")
      return prop.gang;

    if (name == "gangOperandsArgType")
      return prop.gangOperandsArgType;

    if (name == "gangOperandsDeviceType")
      return prop.gangOperandsDeviceType;

    if (name == "gangOperandsSegments")
      return prop.gangOperandsSegments;

    if (name == "inclusiveUpperbound")
      return prop.inclusiveUpperbound;

    if (name == "independent")
      return prop.independent;

    if (name == "privatizations")
      return prop.privatizations;

    if (name == "reductionRecipes")
      return prop.reductionRecipes;

    if (name == "seq")
      return prop.seq;

    if (name == "tileOperandsDeviceType")
      return prop.tileOperandsDeviceType;

    if (name == "tileOperandsSegments")
      return prop.tileOperandsSegments;

    if (name == "vector")
      return prop.vector;

    if (name == "vectorOperandsDeviceType")
      return prop.vectorOperandsDeviceType;

    if (name == "worker")
      return prop.worker;

    if (name == "workerNumOperandsDeviceType")
      return prop.workerNumOperandsDeviceType;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void LoopOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "auto_") {
       prop.auto_ = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.auto_)>>(value);
       return;
    }

    if (name == "collapse") {
       prop.collapse = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.collapse)>>(value);
       return;
    }

    if (name == "collapseDeviceType") {
       prop.collapseDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.collapseDeviceType)>>(value);
       return;
    }

    if (name == "combined") {
       prop.combined = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.combined)>>(value);
       return;
    }

    if (name == "gang") {
       prop.gang = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.gang)>>(value);
       return;
    }

    if (name == "gangOperandsArgType") {
       prop.gangOperandsArgType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.gangOperandsArgType)>>(value);
       return;
    }

    if (name == "gangOperandsDeviceType") {
       prop.gangOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.gangOperandsDeviceType)>>(value);
       return;
    }

    if (name == "gangOperandsSegments") {
       prop.gangOperandsSegments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.gangOperandsSegments)>>(value);
       return;
    }

    if (name == "inclusiveUpperbound") {
       prop.inclusiveUpperbound = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.inclusiveUpperbound)>>(value);
       return;
    }

    if (name == "independent") {
       prop.independent = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.independent)>>(value);
       return;
    }

    if (name == "privatizations") {
       prop.privatizations = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.privatizations)>>(value);
       return;
    }

    if (name == "reductionRecipes") {
       prop.reductionRecipes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.reductionRecipes)>>(value);
       return;
    }

    if (name == "seq") {
       prop.seq = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.seq)>>(value);
       return;
    }

    if (name == "tileOperandsDeviceType") {
       prop.tileOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.tileOperandsDeviceType)>>(value);
       return;
    }

    if (name == "tileOperandsSegments") {
       prop.tileOperandsSegments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.tileOperandsSegments)>>(value);
       return;
    }

    if (name == "vector") {
       prop.vector = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.vector)>>(value);
       return;
    }

    if (name == "vectorOperandsDeviceType") {
       prop.vectorOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.vectorOperandsDeviceType)>>(value);
       return;
    }

    if (name == "worker") {
       prop.worker = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.worker)>>(value);
       return;
    }

    if (name == "workerNumOperandsDeviceType") {
       prop.workerNumOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.workerNumOperandsDeviceType)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void LoopOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.auto_) attrs.append("auto_", prop.auto_);

    if (prop.collapse) attrs.append("collapse", prop.collapse);

    if (prop.collapseDeviceType) attrs.append("collapseDeviceType", prop.collapseDeviceType);

    if (prop.combined) attrs.append("combined", prop.combined);

    if (prop.gang) attrs.append("gang", prop.gang);

    if (prop.gangOperandsArgType) attrs.append("gangOperandsArgType", prop.gangOperandsArgType);

    if (prop.gangOperandsDeviceType) attrs.append("gangOperandsDeviceType", prop.gangOperandsDeviceType);

    if (prop.gangOperandsSegments) attrs.append("gangOperandsSegments", prop.gangOperandsSegments);

    if (prop.inclusiveUpperbound) attrs.append("inclusiveUpperbound", prop.inclusiveUpperbound);

    if (prop.independent) attrs.append("independent", prop.independent);

    if (prop.privatizations) attrs.append("privatizations", prop.privatizations);

    if (prop.reductionRecipes) attrs.append("reductionRecipes", prop.reductionRecipes);

    if (prop.seq) attrs.append("seq", prop.seq);

    if (prop.tileOperandsDeviceType) attrs.append("tileOperandsDeviceType", prop.tileOperandsDeviceType);

    if (prop.tileOperandsSegments) attrs.append("tileOperandsSegments", prop.tileOperandsSegments);

    if (prop.vector) attrs.append("vector", prop.vector);

    if (prop.vectorOperandsDeviceType) attrs.append("vectorOperandsDeviceType", prop.vectorOperandsDeviceType);

    if (prop.worker) attrs.append("worker", prop.worker);

    if (prop.workerNumOperandsDeviceType) attrs.append("workerNumOperandsDeviceType", prop.workerNumOperandsDeviceType);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult LoopOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAuto_AttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "auto_", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCollapseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps12(attr, "collapse", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCollapseDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "collapseDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCombinedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps15(attr, "combined", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getGangAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "gang", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getGangOperandsArgTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps13(attr, "gangOperandsArgType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getGangOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "gangOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getGangOperandsSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(attr, "gangOperandsSegments", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getInclusiveUpperboundAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps11(attr, "inclusiveUpperbound", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIndependentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "independent", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrivatizationsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(attr, "privatizations", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReductionRecipesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(attr, "reductionRecipes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSeqAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "seq", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTileOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "tileOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTileOperandsSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(attr, "tileOperandsSegments", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVectorAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "vector", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVectorOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "vectorOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWorkerAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "worker", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWorkerNumOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "workerNumOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult LoopOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.auto_)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.collapse)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.collapseDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.combined)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.gang)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.gangOperandsArgType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.gangOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.gangOperandsSegments)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.inclusiveUpperbound)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.independent)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.privatizations)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.reductionRecipes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.seq)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.tileOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.tileOperandsSegments)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.vector)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.vectorOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.worker)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.workerNumOperandsDeviceType)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void LoopOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.auto_);

  writer.writeOptionalAttribute(prop.collapse);

  writer.writeOptionalAttribute(prop.collapseDeviceType);

  writer.writeOptionalAttribute(prop.combined);

  writer.writeOptionalAttribute(prop.gang);

  writer.writeOptionalAttribute(prop.gangOperandsArgType);

  writer.writeOptionalAttribute(prop.gangOperandsDeviceType);

  writer.writeOptionalAttribute(prop.gangOperandsSegments);

  writer.writeOptionalAttribute(prop.inclusiveUpperbound);

  writer.writeOptionalAttribute(prop.independent);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.privatizations);

  writer.writeOptionalAttribute(prop.reductionRecipes);

  writer.writeOptionalAttribute(prop.seq);

  writer.writeOptionalAttribute(prop.tileOperandsDeviceType);

  writer.writeOptionalAttribute(prop.tileOperandsSegments);

  writer.writeOptionalAttribute(prop.vector);

  writer.writeOptionalAttribute(prop.vectorOperandsDeviceType);

  writer.writeOptionalAttribute(prop.worker);

  writer.writeOptionalAttribute(prop.workerNumOperandsDeviceType);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional<::llvm::ArrayRef<bool>> LoopOp::getInclusiveUpperbound() {
  auto attr = getInclusiveUpperboundAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<bool>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getCollapse() {
  auto attr = getCollapseAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getCollapseDeviceType() {
  auto attr = getCollapseDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getGangOperandsArgType() {
  auto attr = getGangOperandsArgTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> LoopOp::getGangOperandsSegments() {
  auto attr = getGangOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getGangOperandsDeviceType() {
  auto attr = getGangOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getWorkerNumOperandsDeviceType() {
  auto attr = getWorkerNumOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getVectorOperandsDeviceType() {
  auto attr = getVectorOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getSeq() {
  auto attr = getSeqAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getIndependent() {
  auto attr = getIndependentAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getAuto_() {
  auto attr = getAuto_Attr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getGang() {
  auto attr = getGangAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getWorker() {
  auto attr = getWorkerAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getVector() {
  auto attr = getVectorAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> LoopOp::getTileOperandsSegments() {
  auto attr = getTileOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getTileOperandsDeviceType() {
  auto attr = getTileOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getPrivatizations() {
  auto attr = getPrivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > LoopOp::getReductionRecipes() {
  auto attr = getReductionRecipesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::mlir::acc::CombinedConstructsType> LoopOp::getCombined() {
  auto attr = getCombinedAttr();
  return attr ? ::std::optional<::mlir::acc::CombinedConstructsType>(attr.getValue()) : (::std::nullopt);
}

void LoopOp::setInclusiveUpperbound(::std::optional<::llvm::ArrayRef<bool>> attrValue) {
    auto &odsProp = getProperties().inclusiveUpperbound;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseBoolArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LoopOp::setGangOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().gangOperandsSegments;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LoopOp::setTileOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().tileOperandsSegments;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void LoopOp::setCombined(::std::optional<::mlir::acc::CombinedConstructsType> attrValue) {
    auto &odsProp = getProperties().combined;
    if (attrValue)
      odsProp = ::mlir::acc::CombinedConstructsTypeAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void LoopOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange results, ::mlir::ValueRange lowerbound, ::mlir::ValueRange upperbound, ::mlir::ValueRange step, /*optional*/::mlir::DenseBoolArrayAttr inclusiveUpperbound, /*optional*/::mlir::ArrayAttr collapse, /*optional*/::mlir::ArrayAttr collapseDeviceType, ::mlir::ValueRange gangOperands, /*optional*/::mlir::ArrayAttr gangOperandsArgType, /*optional*/::mlir::DenseI32ArrayAttr gangOperandsSegments, /*optional*/::mlir::ArrayAttr gangOperandsDeviceType, ::mlir::ValueRange workerNumOperands, /*optional*/::mlir::ArrayAttr workerNumOperandsDeviceType, ::mlir::ValueRange vectorOperands, /*optional*/::mlir::ArrayAttr vectorOperandsDeviceType, /*optional*/::mlir::ArrayAttr seq, /*optional*/::mlir::ArrayAttr independent, /*optional*/::mlir::ArrayAttr auto_, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, ::mlir::ValueRange tileOperands, /*optional*/::mlir::DenseI32ArrayAttr tileOperandsSegments, /*optional*/::mlir::ArrayAttr tileOperandsDeviceType, ::mlir::ValueRange cacheOperands, ::mlir::ValueRange privateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, /*optional*/::mlir::acc::CombinedConstructsTypeAttr combined) {
  odsState.addOperands(lowerbound);
  odsState.addOperands(upperbound);
  odsState.addOperands(step);
  odsState.addOperands(gangOperands);
  odsState.addOperands(workerNumOperands);
  odsState.addOperands(vectorOperands);
  odsState.addOperands(tileOperands);
  odsState.addOperands(cacheOperands);
  odsState.addOperands(privateOperands);
  odsState.addOperands(reductionOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(lowerbound.size()), static_cast<int32_t>(upperbound.size()), static_cast<int32_t>(step.size()), static_cast<int32_t>(gangOperands.size()), static_cast<int32_t>(workerNumOperands.size()), static_cast<int32_t>(vectorOperands.size()), static_cast<int32_t>(tileOperands.size()), static_cast<int32_t>(cacheOperands.size()), static_cast<int32_t>(privateOperands.size()), static_cast<int32_t>(reductionOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (inclusiveUpperbound) {
    odsState.getOrAddProperties<Properties>().inclusiveUpperbound = inclusiveUpperbound;
  }
  if (collapse) {
    odsState.getOrAddProperties<Properties>().collapse = collapse;
  }
  if (collapseDeviceType) {
    odsState.getOrAddProperties<Properties>().collapseDeviceType = collapseDeviceType;
  }
  if (gangOperandsArgType) {
    odsState.getOrAddProperties<Properties>().gangOperandsArgType = gangOperandsArgType;
  }
  if (gangOperandsSegments) {
    odsState.getOrAddProperties<Properties>().gangOperandsSegments = gangOperandsSegments;
  }
  if (gangOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().gangOperandsDeviceType = gangOperandsDeviceType;
  }
  if (workerNumOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().workerNumOperandsDeviceType = workerNumOperandsDeviceType;
  }
  if (vectorOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().vectorOperandsDeviceType = vectorOperandsDeviceType;
  }
  if (seq) {
    odsState.getOrAddProperties<Properties>().seq = seq;
  }
  if (independent) {
    odsState.getOrAddProperties<Properties>().independent = independent;
  }
  if (auto_) {
    odsState.getOrAddProperties<Properties>().auto_ = auto_;
  }
  if (gang) {
    odsState.getOrAddProperties<Properties>().gang = gang;
  }
  if (worker) {
    odsState.getOrAddProperties<Properties>().worker = worker;
  }
  if (vector) {
    odsState.getOrAddProperties<Properties>().vector = vector;
  }
  if (tileOperandsSegments) {
    odsState.getOrAddProperties<Properties>().tileOperandsSegments = tileOperandsSegments;
  }
  if (tileOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().tileOperandsDeviceType = tileOperandsDeviceType;
  }
  if (privatizations) {
    odsState.getOrAddProperties<Properties>().privatizations = privatizations;
  }
  if (reductionRecipes) {
    odsState.getOrAddProperties<Properties>().reductionRecipes = reductionRecipes;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = combined;
  }
  (void)odsState.addRegion();
  odsState.addTypes(results);
}

void LoopOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<LoopOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult LoopOp::verifyInvariantsImpl() {
  auto tblgen_auto_ = getProperties().auto_; (void)tblgen_auto_;
  auto tblgen_collapse = getProperties().collapse; (void)tblgen_collapse;
  auto tblgen_collapseDeviceType = getProperties().collapseDeviceType; (void)tblgen_collapseDeviceType;
  auto tblgen_combined = getProperties().combined; (void)tblgen_combined;
  auto tblgen_gang = getProperties().gang; (void)tblgen_gang;
  auto tblgen_gangOperandsArgType = getProperties().gangOperandsArgType; (void)tblgen_gangOperandsArgType;
  auto tblgen_gangOperandsDeviceType = getProperties().gangOperandsDeviceType; (void)tblgen_gangOperandsDeviceType;
  auto tblgen_gangOperandsSegments = getProperties().gangOperandsSegments; (void)tblgen_gangOperandsSegments;
  auto tblgen_inclusiveUpperbound = getProperties().inclusiveUpperbound; (void)tblgen_inclusiveUpperbound;
  auto tblgen_independent = getProperties().independent; (void)tblgen_independent;
  auto tblgen_privatizations = getProperties().privatizations; (void)tblgen_privatizations;
  auto tblgen_reductionRecipes = getProperties().reductionRecipes; (void)tblgen_reductionRecipes;
  auto tblgen_seq = getProperties().seq; (void)tblgen_seq;
  auto tblgen_tileOperandsDeviceType = getProperties().tileOperandsDeviceType; (void)tblgen_tileOperandsDeviceType;
  auto tblgen_tileOperandsSegments = getProperties().tileOperandsSegments; (void)tblgen_tileOperandsSegments;
  auto tblgen_vector = getProperties().vector; (void)tblgen_vector;
  auto tblgen_vectorOperandsDeviceType = getProperties().vectorOperandsDeviceType; (void)tblgen_vectorOperandsDeviceType;
  auto tblgen_worker = getProperties().worker; (void)tblgen_worker;
  auto tblgen_workerNumOperandsDeviceType = getProperties().workerNumOperandsDeviceType; (void)tblgen_workerNumOperandsDeviceType;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps11(*this, tblgen_inclusiveUpperbound, "inclusiveUpperbound")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps12(*this, tblgen_collapse, "collapse")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_collapseDeviceType, "collapseDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps13(*this, tblgen_gangOperandsArgType, "gangOperandsArgType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(*this, tblgen_gangOperandsSegments, "gangOperandsSegments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_gangOperandsDeviceType, "gangOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_workerNumOperandsDeviceType, "workerNumOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_vectorOperandsDeviceType, "vectorOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_seq, "seq")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_independent, "independent")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_auto_, "auto_")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_gang, "gang")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_worker, "worker")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_vector, "vector")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(*this, tblgen_tileOperandsSegments, "tileOperandsSegments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_tileOperandsDeviceType, "tileOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(*this, tblgen_privatizations, "privatizations")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(*this, tblgen_reductionRecipes, "reductionRecipes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps15(*this, tblgen_combined, "combined")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup5 = getODSOperands(5);

    for (auto v : valueGroup5) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup6 = getODSOperands(6);

    for (auto v : valueGroup6) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup7 = getODSOperands(7);

    for (auto v : valueGroup7) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup8 = getODSOperands(8);

    for (auto v : valueGroup8) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup9 = getODSOperands(9);

    for (auto v : valueGroup9) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps11(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps11(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult LoopOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult LoopOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::acc::CombinedConstructsTypeAttr combinedAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> gangOperandsOperands;
  ::llvm::SMLoc gangOperandsOperandsLoc;
  (void)gangOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> gangOperandsTypes;
  ::mlir::ArrayAttr gangOperandsArgTypeAttr;
  ::mlir::ArrayAttr gangOperandsDeviceTypeAttr;
  ::mlir::DenseI32ArrayAttr gangOperandsSegmentsAttr;
  ::mlir::ArrayAttr gangAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> workerNumOperandsOperands;
  ::llvm::SMLoc workerNumOperandsOperandsLoc;
  (void)workerNumOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> workerNumOperandsTypes;
  ::mlir::ArrayAttr workerNumOperandsDeviceTypeAttr;
  ::mlir::ArrayAttr workerAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> vectorOperandsOperands;
  ::llvm::SMLoc vectorOperandsOperandsLoc;
  (void)vectorOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> vectorOperandsTypes;
  ::mlir::ArrayAttr vectorOperandsDeviceTypeAttr;
  ::mlir::ArrayAttr vectorAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> privateOperandsOperands;
  ::llvm::SMLoc privateOperandsOperandsLoc;
  (void)privateOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> privateOperandsTypes;
  ::mlir::ArrayAttr privatizationsAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> tileOperandsOperands;
  ::llvm::SMLoc tileOperandsOperandsLoc;
  (void)tileOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> tileOperandsTypes;
  ::mlir::ArrayAttr tileOperandsDeviceTypeAttr;
  ::mlir::DenseI32ArrayAttr tileOperandsSegmentsAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> reductionOperandsOperands;
  ::llvm::SMLoc reductionOperandsOperandsLoc;
  (void)reductionOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> reductionOperandsTypes;
  ::mlir::ArrayAttr reductionRecipesAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> cacheOperandsOperands;
  ::llvm::SMLoc cacheOperandsOperandsLoc;
  (void)cacheOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> cacheOperandsTypes;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> lowerboundOperands;
  ::llvm::SMLoc lowerboundOperandsLoc;
  (void)lowerboundOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> lowerboundTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> upperboundOperands;
  ::llvm::SMLoc upperboundOperandsLoc;
  (void)upperboundOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> upperboundTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> stepOperands;
  ::llvm::SMLoc stepOperandsLoc;
  (void)stepOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> stepTypes;
  ::llvm::SmallVector<::mlir::Type, 1> resultsTypes;
  {
    auto odsResult = parseCombinedConstructsLoop(parser, combinedAttr);
    if (odsResult) return ::mlir::failure();
    if (combinedAttr)
      result.getOrAddProperties<LoopOp::Properties>().combined = combinedAttr;
  }
  bool gangClause = false;
  bool workerClause = false;
  bool vectorClause = false;
  bool privateClause = false;
  bool tileClause = false;
  bool reductionClause = false;
  bool cacheClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("gang"))) {

  if (gangClause) {
    return parser.emitError(parser.getNameLoc())
          << "`gang` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  gangClause = true;
  {
    gangOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseGangClause(parser, gangOperandsOperands, gangOperandsTypes, gangOperandsArgTypeAttr, gangOperandsDeviceTypeAttr, gangOperandsSegmentsAttr, gangAttr);
    if (odsResult) return ::mlir::failure();
    if (gangOperandsArgTypeAttr)
      result.getOrAddProperties<LoopOp::Properties>().gangOperandsArgType = gangOperandsArgTypeAttr;
    if (gangOperandsDeviceTypeAttr)
      result.getOrAddProperties<LoopOp::Properties>().gangOperandsDeviceType = gangOperandsDeviceTypeAttr;
    if (gangOperandsSegmentsAttr)
      result.getOrAddProperties<LoopOp::Properties>().gangOperandsSegments = gangOperandsSegmentsAttr;
    if (gangAttr)
      result.getOrAddProperties<LoopOp::Properties>().gang = gangAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("worker"))) {

  if (workerClause) {
    return parser.emitError(parser.getNameLoc())
          << "`worker` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  workerClause = true;
  {
    workerNumOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperandsWithKeywordOnly(parser, workerNumOperandsOperands, workerNumOperandsTypes, workerNumOperandsDeviceTypeAttr, workerAttr);
    if (odsResult) return ::mlir::failure();
    if (workerNumOperandsDeviceTypeAttr)
      result.getOrAddProperties<LoopOp::Properties>().workerNumOperandsDeviceType = workerNumOperandsDeviceTypeAttr;
    if (workerAttr)
      result.getOrAddProperties<LoopOp::Properties>().worker = workerAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("vector"))) {

  if (vectorClause) {
    return parser.emitError(parser.getNameLoc())
          << "`vector` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  vectorClause = true;
  {
    vectorOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperandsWithKeywordOnly(parser, vectorOperandsOperands, vectorOperandsTypes, vectorOperandsDeviceTypeAttr, vectorAttr);
    if (odsResult) return ::mlir::failure();
    if (vectorOperandsDeviceTypeAttr)
      result.getOrAddProperties<LoopOp::Properties>().vectorOperandsDeviceType = vectorOperandsDeviceTypeAttr;
    if (vectorAttr)
      result.getOrAddProperties<LoopOp::Properties>().vector = vectorAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("private"))) {

  if (privateClause) {
    return parser.emitError(parser.getNameLoc())
          << "`private` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  privateClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    privateOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseSymOperandList(parser, privateOperandsOperands, privateOperandsTypes, privatizationsAttr);
    if (odsResult) return ::mlir::failure();
    if (privatizationsAttr)
      result.getOrAddProperties<LoopOp::Properties>().privatizations = privatizationsAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("tile"))) {

  if (tileClause) {
    return parser.emitError(parser.getNameLoc())
          << "`tile` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  tileClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    tileOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperandsWithSegment(parser, tileOperandsOperands, tileOperandsTypes, tileOperandsDeviceTypeAttr, tileOperandsSegmentsAttr);
    if (odsResult) return ::mlir::failure();
    if (tileOperandsDeviceTypeAttr)
      result.getOrAddProperties<LoopOp::Properties>().tileOperandsDeviceType = tileOperandsDeviceTypeAttr;
    if (tileOperandsSegmentsAttr)
      result.getOrAddProperties<LoopOp::Properties>().tileOperandsSegments = tileOperandsSegmentsAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("reduction"))) {

  if (reductionClause) {
    return parser.emitError(parser.getNameLoc())
          << "`reduction` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  reductionClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    reductionOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseSymOperandList(parser, reductionOperandsOperands, reductionOperandsTypes, reductionRecipesAttr);
    if (odsResult) return ::mlir::failure();
    if (reductionRecipesAttr)
      result.getOrAddProperties<LoopOp::Properties>().reductionRecipes = reductionRecipesAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("cache"))) {

  if (cacheClause) {
    return parser.emitError(parser.getNameLoc())
          << "`cache` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  cacheClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  cacheOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(cacheOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(cacheOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    lowerboundOperandsLoc = parser.getCurrentLocation();
    upperboundOperandsLoc = parser.getCurrentLocation();
    stepOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseLoopControl(parser, *regionRegion, lowerboundOperands, lowerboundTypes, upperboundOperands, upperboundTypes, stepOperands, stepTypes);
    if (odsResult) return ::mlir::failure();
  }
  if (::mlir::succeeded(parser.parseOptionalLParen())) {

  if (parser.parseTypeList(resultsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(lowerboundOperands.size()), static_cast<int32_t>(upperboundOperands.size()), static_cast<int32_t>(stepOperands.size()), static_cast<int32_t>(gangOperandsOperands.size()), static_cast<int32_t>(workerNumOperandsOperands.size()), static_cast<int32_t>(vectorOperandsOperands.size()), static_cast<int32_t>(tileOperandsOperands.size()), static_cast<int32_t>(cacheOperandsOperands.size()), static_cast<int32_t>(privateOperandsOperands.size()), static_cast<int32_t>(reductionOperandsOperands.size())}), result.getOrAddProperties<LoopOp::Properties>().operandSegmentSizes.begin());
  result.addTypes(resultsTypes);
  if (parser.resolveOperands(lowerboundOperands, lowerboundTypes, lowerboundOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(upperboundOperands, upperboundTypes, upperboundOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(stepOperands, stepTypes, stepOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(gangOperandsOperands, gangOperandsTypes, gangOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(workerNumOperandsOperands, workerNumOperandsTypes, workerNumOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(vectorOperandsOperands, vectorOperandsTypes, vectorOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(tileOperandsOperands, tileOperandsTypes, tileOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(cacheOperandsOperands, cacheOperandsTypes, cacheOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(privateOperandsOperands, privateOperandsTypes, privateOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(reductionOperandsOperands, reductionOperandsTypes, reductionOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void LoopOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  printCombinedConstructsLoop(_odsPrinter, *this, getCombinedAttr());
  if (false || getGangOperands().size() || (getGangOperandsArgTypeAttr()) || (getGangOperandsDeviceTypeAttr()) || (getGangOperandsSegmentsAttr()) || (getGangAttr())) {
  _odsPrinter << ' ' << "gang";
  printGangClause(_odsPrinter, *this, getGangOperands(), getGangOperands().getTypes(), getGangOperandsArgTypeAttr(), getGangOperandsDeviceTypeAttr(), getGangOperandsSegmentsAttr(), getGangAttr());
  }
  if (false || getWorkerNumOperands().size() || (getWorkerNumOperandsDeviceTypeAttr()) || (getWorkerAttr())) {
  _odsPrinter << ' ' << "worker";
  printDeviceTypeOperandsWithKeywordOnly(_odsPrinter, *this, getWorkerNumOperands(), getWorkerNumOperands().getTypes(), getWorkerNumOperandsDeviceTypeAttr(), getWorkerAttr());
  }
  if (false || getVectorOperands().size() || (getVectorOperandsDeviceTypeAttr()) || (getVectorAttr())) {
  _odsPrinter << ' ' << "vector";
  printDeviceTypeOperandsWithKeywordOnly(_odsPrinter, *this, getVectorOperands(), getVectorOperands().getTypes(), getVectorOperandsDeviceTypeAttr(), getVectorAttr());
  }
  if (false || getPrivateOperands().size() || (getPrivatizationsAttr())) {
  _odsPrinter << ' ' << "private";
  _odsPrinter << "(";
  printSymOperandList(_odsPrinter, *this, getPrivateOperands(), getPrivateOperands().getTypes(), getPrivatizationsAttr());
  _odsPrinter << ")";
  }
  if (false || getTileOperands().size() || (getTileOperandsDeviceTypeAttr()) || (getTileOperandsSegmentsAttr())) {
  _odsPrinter << ' ' << "tile";
  _odsPrinter << "(";
  printDeviceTypeOperandsWithSegment(_odsPrinter, *this, getTileOperands(), getTileOperands().getTypes(), getTileOperandsDeviceTypeAttr(), getTileOperandsSegmentsAttr());
  _odsPrinter << ")";
  }
  if (false || getReductionOperands().size() || (getReductionRecipesAttr())) {
  _odsPrinter << ' ' << "reduction";
  _odsPrinter << "(";
  printSymOperandList(_odsPrinter, *this, getReductionOperands(), getReductionOperands().getTypes(), getReductionRecipesAttr());
  _odsPrinter << ")";
  }
  if (false || getCacheOperands().size()) {
  _odsPrinter << ' ' << "cache";
  _odsPrinter << "(";
  _odsPrinter << getCacheOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getCacheOperands().getTypes();
  _odsPrinter << ")";
  }
  _odsPrinter << ' ';
  printLoopControl(_odsPrinter, *this, getRegion(), getLowerbound(), getLowerbound().getTypes(), getUpperbound(), getUpperbound().getTypes(), getStep(), getStep().getTypes());
  if (!getResults().empty()) {
    _odsPrinter << "(";
    _odsPrinter << getResults().getTypes();
    _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("combined");
  elidedAttrs.push_back("gangOperandsArgType");
  elidedAttrs.push_back("gangOperandsDeviceType");
  elidedAttrs.push_back("gangOperandsSegments");
  elidedAttrs.push_back("gang");
  elidedAttrs.push_back("workerNumOperandsDeviceType");
  elidedAttrs.push_back("worker");
  elidedAttrs.push_back("vectorOperandsDeviceType");
  elidedAttrs.push_back("vector");
  elidedAttrs.push_back("privatizations");
  elidedAttrs.push_back("tileOperandsDeviceType");
  elidedAttrs.push_back("tileOperandsSegments");
  elidedAttrs.push_back("reductionRecipes");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void LoopOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::LoopOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::NoCreateOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
NoCreateOpGenericAdaptorBase::NoCreateOpGenericAdaptorBase(NoCreateOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> NoCreateOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > NoCreateOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > NoCreateOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr NoCreateOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause NoCreateOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr NoCreateOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool NoCreateOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr NoCreateOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool NoCreateOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > NoCreateOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
NoCreateOpAdaptor::NoCreateOpAdaptor(NoCreateOp op) : NoCreateOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult NoCreateOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.nocreate' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.nocreate' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.nocreate' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.nocreate' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.nocreate' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.nocreate' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> NoCreateOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange NoCreateOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange NoCreateOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange NoCreateOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult NoCreateOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute NoCreateOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code NoCreateOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> NoCreateOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void NoCreateOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void NoCreateOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult NoCreateOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult NoCreateOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void NoCreateOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > NoCreateOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > NoCreateOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause NoCreateOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool NoCreateOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool NoCreateOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > NoCreateOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void NoCreateOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void NoCreateOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void NoCreateOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void NoCreateOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void NoCreateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void NoCreateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NoCreateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void NoCreateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void NoCreateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<NoCreateOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void NoCreateOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_no_create);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult NoCreateOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult NoCreateOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult NoCreateOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<NoCreateOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<NoCreateOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void NoCreateOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_no_create)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void NoCreateOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::NoCreateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ParallelOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ParallelOpGenericAdaptorBase::ParallelOpGenericAdaptorBase(ParallelOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> ParallelOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> ParallelOpGenericAdaptorBase::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> ParallelOpGenericAdaptorBase::getNumGangsSegments() {
  auto attr = getNumGangsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getNumGangsDeviceType() {
  auto attr = getNumGangsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getNumWorkersDeviceType() {
  auto attr = getNumWorkersDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getVectorLengthDeviceType() {
  auto attr = getVectorLengthDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::UnitAttr ParallelOpGenericAdaptorBase::getSelfAttrAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().selfAttr);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool ParallelOpGenericAdaptorBase::getSelfAttr() {
  auto attr = getSelfAttrAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getReductionRecipes() {
  auto attr = getReductionRecipesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getPrivatizations() {
  auto attr = getPrivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOpGenericAdaptorBase::getFirstprivatizations() {
  auto attr = getFirstprivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::mlir::acc::ClauseDefaultValue> ParallelOpGenericAdaptorBase::getDefaultAttr() {
  auto attr = getDefaultAttrAttr();
  return attr ? ::std::optional<::mlir::acc::ClauseDefaultValue>(attr.getValue()) : (::std::nullopt);
}

::mlir::UnitAttr ParallelOpGenericAdaptorBase::getCombinedAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().combined);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool ParallelOpGenericAdaptorBase::getCombined() {
  auto attr = getCombinedAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
ParallelOpAdaptor::ParallelOpAdaptor(ParallelOp op) : ParallelOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ParallelOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_combined = getProperties().combined; (void)tblgen_combined;
  auto tblgen_defaultAttr = getProperties().defaultAttr; (void)tblgen_defaultAttr;
  auto tblgen_firstprivatizations = getProperties().firstprivatizations; (void)tblgen_firstprivatizations;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_numGangsDeviceType = getProperties().numGangsDeviceType; (void)tblgen_numGangsDeviceType;
  auto tblgen_numGangsSegments = getProperties().numGangsSegments; (void)tblgen_numGangsSegments;
  auto tblgen_numWorkersDeviceType = getProperties().numWorkersDeviceType; (void)tblgen_numWorkersDeviceType;
  auto tblgen_privatizations = getProperties().privatizations; (void)tblgen_privatizations;
  auto tblgen_reductionRecipes = getProperties().reductionRecipes; (void)tblgen_reductionRecipes;
  auto tblgen_selfAttr = getProperties().selfAttr; (void)tblgen_selfAttr;
  auto tblgen_vectorLengthDeviceType = getProperties().vectorLengthDeviceType; (void)tblgen_vectorLengthDeviceType;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_waitOperandsSegments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_waitOperandsSegments))))
    return emitError(loc, "'acc.parallel' op ""attribute 'waitOperandsSegments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_waitOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'waitOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_hasWaitDevnum && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_hasWaitDevnum))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_hasWaitDevnum), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::BoolAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'hasWaitDevnum' failed to satisfy constraint: 1-bit boolean array attribute");

  if (tblgen_waitOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'waitOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_numGangsSegments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_numGangsSegments))))
    return emitError(loc, "'acc.parallel' op ""attribute 'numGangsSegments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_numGangsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_numGangsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_numGangsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'numGangsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_numWorkersDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_numWorkersDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_numWorkersDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'numWorkersDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_vectorLengthDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_vectorLengthDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_vectorLengthDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'vectorLengthDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_selfAttr && !((::llvm::isa<::mlir::UnitAttr>(tblgen_selfAttr))))
    return emitError(loc, "'acc.parallel' op ""attribute 'selfAttr' failed to satisfy constraint: unit attribute");

  if (tblgen_reductionRecipes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_reductionRecipes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_reductionRecipes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::SymbolRefAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'reductionRecipes' failed to satisfy constraint: symbol ref array attribute");

  if (tblgen_privatizations && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_privatizations))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_privatizations), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::SymbolRefAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'privatizations' failed to satisfy constraint: symbol ref array attribute");

  if (tblgen_firstprivatizations && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_firstprivatizations))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_firstprivatizations), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::SymbolRefAttr>(attr))); }))))
    return emitError(loc, "'acc.parallel' op ""attribute 'firstprivatizations' failed to satisfy constraint: symbol ref array attribute");

  if (tblgen_defaultAttr && !((::llvm::isa<::mlir::acc::ClauseDefaultValueAttr>(tblgen_defaultAttr))))
    return emitError(loc, "'acc.parallel' op ""attribute 'defaultAttr' failed to satisfy constraint: DefaultValue Clause");

  if (tblgen_combined && !((::llvm::isa<::mlir::UnitAttr>(tblgen_combined))))
    return emitError(loc, "'acc.parallel' op ""attribute 'combined' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ParallelOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange ParallelOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getWaitOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getNumGangsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getNumWorkersMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getVectorLengthMutable() {
  auto range = getODSOperandIndexAndLength(4);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(4u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(5);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(5u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getSelfCondMutable() {
  auto range = getODSOperandIndexAndLength(6);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(6u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getReductionOperandsMutable() {
  auto range = getODSOperandIndexAndLength(7);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(7u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getGangPrivateOperandsMutable() {
  auto range = getODSOperandIndexAndLength(8);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(8u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getGangFirstPrivateOperandsMutable() {
  auto range = getODSOperandIndexAndLength(9);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(9u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ParallelOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(10);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(10u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult ParallelOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.combined;
       auto attr = dict.get("combined");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `combined` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.defaultAttr;
       auto attr = dict.get("defaultAttr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `defaultAttr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.firstprivatizations;
       auto attr = dict.get("firstprivatizations");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `firstprivatizations` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.hasWaitDevnum;
       auto attr = dict.get("hasWaitDevnum");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `hasWaitDevnum` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.numGangsDeviceType;
       auto attr = dict.get("numGangsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `numGangsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.numGangsSegments;
       auto attr = dict.get("numGangsSegments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `numGangsSegments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.numWorkersDeviceType;
       auto attr = dict.get("numWorkersDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `numWorkersDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.privatizations;
       auto attr = dict.get("privatizations");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `privatizations` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.reductionRecipes;
       auto attr = dict.get("reductionRecipes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `reductionRecipes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.selfAttr;
       auto attr = dict.get("selfAttr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `selfAttr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.vectorLengthDeviceType;
       auto attr = dict.get("vectorLengthDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `vectorLengthDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOnly;
       auto attr = dict.get("waitOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsDeviceType;
       auto attr = dict.get("waitOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsSegments;
       auto attr = dict.get("waitOperandsSegments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsSegments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute ParallelOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.combined;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("combined",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.defaultAttr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("defaultAttr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.firstprivatizations;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("firstprivatizations",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.hasWaitDevnum;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("hasWaitDevnum",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.numGangsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("numGangsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.numGangsSegments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("numGangsSegments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.numWorkersDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("numWorkersDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.privatizations;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("privatizations",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.reductionRecipes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("reductionRecipes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.selfAttr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("selfAttr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.vectorLengthDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("vectorLengthDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsSegments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsSegments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ParallelOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.combined.getAsOpaquePointer()), 
    llvm::hash_value(prop.defaultAttr.getAsOpaquePointer()), 
    llvm::hash_value(prop.firstprivatizations.getAsOpaquePointer()), 
    llvm::hash_value(prop.hasWaitDevnum.getAsOpaquePointer()), 
    llvm::hash_value(prop.numGangsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.numGangsSegments.getAsOpaquePointer()), 
    llvm::hash_value(prop.numWorkersDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.privatizations.getAsOpaquePointer()), 
    llvm::hash_value(prop.reductionRecipes.getAsOpaquePointer()), 
    llvm::hash_value(prop.selfAttr.getAsOpaquePointer()), 
    llvm::hash_value(prop.vectorLengthDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsSegments.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> ParallelOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "combined")
      return prop.combined;

    if (name == "defaultAttr")
      return prop.defaultAttr;

    if (name == "firstprivatizations")
      return prop.firstprivatizations;

    if (name == "hasWaitDevnum")
      return prop.hasWaitDevnum;

    if (name == "numGangsDeviceType")
      return prop.numGangsDeviceType;

    if (name == "numGangsSegments")
      return prop.numGangsSegments;

    if (name == "numWorkersDeviceType")
      return prop.numWorkersDeviceType;

    if (name == "privatizations")
      return prop.privatizations;

    if (name == "reductionRecipes")
      return prop.reductionRecipes;

    if (name == "selfAttr")
      return prop.selfAttr;

    if (name == "vectorLengthDeviceType")
      return prop.vectorLengthDeviceType;

    if (name == "waitOnly")
      return prop.waitOnly;

    if (name == "waitOperandsDeviceType")
      return prop.waitOperandsDeviceType;

    if (name == "waitOperandsSegments")
      return prop.waitOperandsSegments;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void ParallelOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "combined") {
       prop.combined = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.combined)>>(value);
       return;
    }

    if (name == "defaultAttr") {
       prop.defaultAttr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.defaultAttr)>>(value);
       return;
    }

    if (name == "firstprivatizations") {
       prop.firstprivatizations = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.firstprivatizations)>>(value);
       return;
    }

    if (name == "hasWaitDevnum") {
       prop.hasWaitDevnum = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.hasWaitDevnum)>>(value);
       return;
    }

    if (name == "numGangsDeviceType") {
       prop.numGangsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.numGangsDeviceType)>>(value);
       return;
    }

    if (name == "numGangsSegments") {
       prop.numGangsSegments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.numGangsSegments)>>(value);
       return;
    }

    if (name == "numWorkersDeviceType") {
       prop.numWorkersDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.numWorkersDeviceType)>>(value);
       return;
    }

    if (name == "privatizations") {
       prop.privatizations = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.privatizations)>>(value);
       return;
    }

    if (name == "reductionRecipes") {
       prop.reductionRecipes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.reductionRecipes)>>(value);
       return;
    }

    if (name == "selfAttr") {
       prop.selfAttr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.selfAttr)>>(value);
       return;
    }

    if (name == "vectorLengthDeviceType") {
       prop.vectorLengthDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.vectorLengthDeviceType)>>(value);
       return;
    }

    if (name == "waitOnly") {
       prop.waitOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOnly)>>(value);
       return;
    }

    if (name == "waitOperandsDeviceType") {
       prop.waitOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsDeviceType)>>(value);
       return;
    }

    if (name == "waitOperandsSegments") {
       prop.waitOperandsSegments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsSegments)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void ParallelOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.combined) attrs.append("combined", prop.combined);

    if (prop.defaultAttr) attrs.append("defaultAttr", prop.defaultAttr);

    if (prop.firstprivatizations) attrs.append("firstprivatizations", prop.firstprivatizations);

    if (prop.hasWaitDevnum) attrs.append("hasWaitDevnum", prop.hasWaitDevnum);

    if (prop.numGangsDeviceType) attrs.append("numGangsDeviceType", prop.numGangsDeviceType);

    if (prop.numGangsSegments) attrs.append("numGangsSegments", prop.numGangsSegments);

    if (prop.numWorkersDeviceType) attrs.append("numWorkersDeviceType", prop.numWorkersDeviceType);

    if (prop.privatizations) attrs.append("privatizations", prop.privatizations);

    if (prop.reductionRecipes) attrs.append("reductionRecipes", prop.reductionRecipes);

    if (prop.selfAttr) attrs.append("selfAttr", prop.selfAttr);

    if (prop.vectorLengthDeviceType) attrs.append("vectorLengthDeviceType", prop.vectorLengthDeviceType);

    if (prop.waitOnly) attrs.append("waitOnly", prop.waitOnly);

    if (prop.waitOperandsDeviceType) attrs.append("waitOperandsDeviceType", prop.waitOperandsDeviceType);

    if (prop.waitOperandsSegments) attrs.append("waitOperandsSegments", prop.waitOperandsSegments);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult ParallelOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCombinedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "combined", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDefaultAttrAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps8(attr, "defaultAttr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFirstprivatizationsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(attr, "firstprivatizations", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getHasWaitDevnumAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(attr, "hasWaitDevnum", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNumGangsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "numGangsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNumGangsSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(attr, "numGangsSegments", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNumWorkersDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "numWorkersDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrivatizationsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(attr, "privatizations", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReductionRecipesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(attr, "reductionRecipes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSelfAttrAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "selfAttr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVectorLengthDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "vectorLengthDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(attr, "waitOperandsSegments", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ParallelOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.combined)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.defaultAttr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.firstprivatizations)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.hasWaitDevnum)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.numGangsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.numGangsSegments)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.numWorkersDeviceType)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.privatizations)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.reductionRecipes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.selfAttr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.vectorLengthDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsSegments)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void ParallelOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.combined);

  writer.writeOptionalAttribute(prop.defaultAttr);

  writer.writeOptionalAttribute(prop.firstprivatizations);

  writer.writeOptionalAttribute(prop.hasWaitDevnum);

  writer.writeOptionalAttribute(prop.numGangsDeviceType);

  writer.writeOptionalAttribute(prop.numGangsSegments);

  writer.writeOptionalAttribute(prop.numWorkersDeviceType);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.privatizations);

  writer.writeOptionalAttribute(prop.reductionRecipes);

  writer.writeOptionalAttribute(prop.selfAttr);

  writer.writeOptionalAttribute(prop.vectorLengthDeviceType);

  writer.writeOptionalAttribute(prop.waitOnly);

  writer.writeOptionalAttribute(prop.waitOperandsDeviceType);

  writer.writeOptionalAttribute(prop.waitOperandsSegments);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> ParallelOp::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> ParallelOp::getNumGangsSegments() {
  auto attr = getNumGangsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getNumGangsDeviceType() {
  auto attr = getNumGangsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getNumWorkersDeviceType() {
  auto attr = getNumWorkersDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getVectorLengthDeviceType() {
  auto attr = getVectorLengthDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

bool ParallelOp::getSelfAttr() {
  auto attr = getSelfAttrAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getReductionRecipes() {
  auto attr = getReductionRecipesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getPrivatizations() {
  auto attr = getPrivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ParallelOp::getFirstprivatizations() {
  auto attr = getFirstprivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::mlir::acc::ClauseDefaultValue> ParallelOp::getDefaultAttr() {
  auto attr = getDefaultAttrAttr();
  return attr ? ::std::optional<::mlir::acc::ClauseDefaultValue>(attr.getValue()) : (::std::nullopt);
}

bool ParallelOp::getCombined() {
  auto attr = getCombinedAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void ParallelOp::setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().waitOperandsSegments;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void ParallelOp::setNumGangsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().numGangsSegments;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void ParallelOp::setSelfAttr(bool attrValue) {
    auto &odsProp = getProperties().selfAttr;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void ParallelOp::setDefaultAttr(::std::optional<::mlir::acc::ClauseDefaultValue> attrValue) {
    auto &odsProp = getProperties().defaultAttr;
    if (attrValue)
      odsProp = ::mlir::acc::ClauseDefaultValueAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void ParallelOp::setCombined(bool attrValue) {
    auto &odsProp = getProperties().combined;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void ParallelOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/::mlir::UnitAttr combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(numGangs);
  odsState.addOperands(numWorkers);
  odsState.addOperands(vectorLength);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(reductionOperands);
  odsState.addOperands(gangPrivateOperands);
  odsState.addOperands(gangFirstPrivateOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(numGangs.size()), static_cast<int32_t>(numWorkers.size()), static_cast<int32_t>(vectorLength.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(reductionOperands.size()), static_cast<int32_t>(gangPrivateOperands.size()), static_cast<int32_t>(gangFirstPrivateOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (numGangsSegments) {
    odsState.getOrAddProperties<Properties>().numGangsSegments = numGangsSegments;
  }
  if (numGangsDeviceType) {
    odsState.getOrAddProperties<Properties>().numGangsDeviceType = numGangsDeviceType;
  }
  if (numWorkersDeviceType) {
    odsState.getOrAddProperties<Properties>().numWorkersDeviceType = numWorkersDeviceType;
  }
  if (vectorLengthDeviceType) {
    odsState.getOrAddProperties<Properties>().vectorLengthDeviceType = vectorLengthDeviceType;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = selfAttr;
  }
  if (reductionRecipes) {
    odsState.getOrAddProperties<Properties>().reductionRecipes = reductionRecipes;
  }
  if (privatizations) {
    odsState.getOrAddProperties<Properties>().privatizations = privatizations;
  }
  if (firstprivatizations) {
    odsState.getOrAddProperties<Properties>().firstprivatizations = firstprivatizations;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = combined;
  }
  (void)odsState.addRegion();
}

void ParallelOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/::mlir::UnitAttr combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(numGangs);
  odsState.addOperands(numWorkers);
  odsState.addOperands(vectorLength);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(reductionOperands);
  odsState.addOperands(gangPrivateOperands);
  odsState.addOperands(gangFirstPrivateOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(numGangs.size()), static_cast<int32_t>(numWorkers.size()), static_cast<int32_t>(vectorLength.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(reductionOperands.size()), static_cast<int32_t>(gangPrivateOperands.size()), static_cast<int32_t>(gangFirstPrivateOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (numGangsSegments) {
    odsState.getOrAddProperties<Properties>().numGangsSegments = numGangsSegments;
  }
  if (numGangsDeviceType) {
    odsState.getOrAddProperties<Properties>().numGangsDeviceType = numGangsDeviceType;
  }
  if (numWorkersDeviceType) {
    odsState.getOrAddProperties<Properties>().numWorkersDeviceType = numWorkersDeviceType;
  }
  if (vectorLengthDeviceType) {
    odsState.getOrAddProperties<Properties>().vectorLengthDeviceType = vectorLengthDeviceType;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = selfAttr;
  }
  if (reductionRecipes) {
    odsState.getOrAddProperties<Properties>().reductionRecipes = reductionRecipes;
  }
  if (privatizations) {
    odsState.getOrAddProperties<Properties>().privatizations = privatizations;
  }
  if (firstprivatizations) {
    odsState.getOrAddProperties<Properties>().firstprivatizations = firstprivatizations;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = combined;
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ParallelOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/bool combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(numGangs);
  odsState.addOperands(numWorkers);
  odsState.addOperands(vectorLength);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(reductionOperands);
  odsState.addOperands(gangPrivateOperands);
  odsState.addOperands(gangFirstPrivateOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(numGangs.size()), static_cast<int32_t>(numWorkers.size()), static_cast<int32_t>(vectorLength.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(reductionOperands.size()), static_cast<int32_t>(gangPrivateOperands.size()), static_cast<int32_t>(gangFirstPrivateOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (numGangsSegments) {
    odsState.getOrAddProperties<Properties>().numGangsSegments = numGangsSegments;
  }
  if (numGangsDeviceType) {
    odsState.getOrAddProperties<Properties>().numGangsDeviceType = numGangsDeviceType;
  }
  if (numWorkersDeviceType) {
    odsState.getOrAddProperties<Properties>().numWorkersDeviceType = numWorkersDeviceType;
  }
  if (vectorLengthDeviceType) {
    odsState.getOrAddProperties<Properties>().vectorLengthDeviceType = vectorLengthDeviceType;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = ((selfAttr) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (reductionRecipes) {
    odsState.getOrAddProperties<Properties>().reductionRecipes = reductionRecipes;
  }
  if (privatizations) {
    odsState.getOrAddProperties<Properties>().privatizations = privatizations;
  }
  if (firstprivatizations) {
    odsState.getOrAddProperties<Properties>().firstprivatizations = firstprivatizations;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = ((combined) ? odsBuilder.getUnitAttr() : nullptr);
  }
  (void)odsState.addRegion();
}

void ParallelOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange numGangs, /*optional*/::mlir::DenseI32ArrayAttr numGangsSegments, /*optional*/::mlir::ArrayAttr numGangsDeviceType, ::mlir::ValueRange numWorkers, /*optional*/::mlir::ArrayAttr numWorkersDeviceType, ::mlir::ValueRange vectorLength, /*optional*/::mlir::ArrayAttr vectorLengthDeviceType, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/bool combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(numGangs);
  odsState.addOperands(numWorkers);
  odsState.addOperands(vectorLength);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(reductionOperands);
  odsState.addOperands(gangPrivateOperands);
  odsState.addOperands(gangFirstPrivateOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(numGangs.size()), static_cast<int32_t>(numWorkers.size()), static_cast<int32_t>(vectorLength.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(reductionOperands.size()), static_cast<int32_t>(gangPrivateOperands.size()), static_cast<int32_t>(gangFirstPrivateOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (numGangsSegments) {
    odsState.getOrAddProperties<Properties>().numGangsSegments = numGangsSegments;
  }
  if (numGangsDeviceType) {
    odsState.getOrAddProperties<Properties>().numGangsDeviceType = numGangsDeviceType;
  }
  if (numWorkersDeviceType) {
    odsState.getOrAddProperties<Properties>().numWorkersDeviceType = numWorkersDeviceType;
  }
  if (vectorLengthDeviceType) {
    odsState.getOrAddProperties<Properties>().vectorLengthDeviceType = vectorLengthDeviceType;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = ((selfAttr) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (reductionRecipes) {
    odsState.getOrAddProperties<Properties>().reductionRecipes = reductionRecipes;
  }
  if (privatizations) {
    odsState.getOrAddProperties<Properties>().privatizations = privatizations;
  }
  if (firstprivatizations) {
    odsState.getOrAddProperties<Properties>().firstprivatizations = firstprivatizations;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = ((combined) ? odsBuilder.getUnitAttr() : nullptr);
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ParallelOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ParallelOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ParallelOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_combined = getProperties().combined; (void)tblgen_combined;
  auto tblgen_defaultAttr = getProperties().defaultAttr; (void)tblgen_defaultAttr;
  auto tblgen_firstprivatizations = getProperties().firstprivatizations; (void)tblgen_firstprivatizations;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_numGangsDeviceType = getProperties().numGangsDeviceType; (void)tblgen_numGangsDeviceType;
  auto tblgen_numGangsSegments = getProperties().numGangsSegments; (void)tblgen_numGangsSegments;
  auto tblgen_numWorkersDeviceType = getProperties().numWorkersDeviceType; (void)tblgen_numWorkersDeviceType;
  auto tblgen_privatizations = getProperties().privatizations; (void)tblgen_privatizations;
  auto tblgen_reductionRecipes = getProperties().reductionRecipes; (void)tblgen_reductionRecipes;
  auto tblgen_selfAttr = getProperties().selfAttr; (void)tblgen_selfAttr;
  auto tblgen_vectorLengthDeviceType = getProperties().vectorLengthDeviceType; (void)tblgen_vectorLengthDeviceType;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(*this, tblgen_waitOperandsSegments, "waitOperandsSegments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOperandsDeviceType, "waitOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(*this, tblgen_hasWaitDevnum, "hasWaitDevnum")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOnly, "waitOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(*this, tblgen_numGangsSegments, "numGangsSegments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_numGangsDeviceType, "numGangsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_numWorkersDeviceType, "numWorkersDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_vectorLengthDeviceType, "vectorLengthDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_selfAttr, "selfAttr")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(*this, tblgen_reductionRecipes, "reductionRecipes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(*this, tblgen_privatizations, "privatizations")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(*this, tblgen_firstprivatizations, "firstprivatizations")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps8(*this, tblgen_defaultAttr, "defaultAttr")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_combined, "combined")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup5 = getODSOperands(5);

    if (valueGroup5.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup5.size();
    }

    for (auto v : valueGroup5) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup6 = getODSOperands(6);

    if (valueGroup6.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup6.size();
    }

    for (auto v : valueGroup6) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup7 = getODSOperands(7);

    for (auto v : valueGroup7) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps11(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup8 = getODSOperands(8);

    for (auto v : valueGroup8) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup9 = getODSOperands(9);

    for (auto v : valueGroup9) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup10 = getODSOperands(10);

    for (auto v : valueGroup10) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult ParallelOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ParallelOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> gangFirstPrivateOperandsOperands;
  ::llvm::SMLoc gangFirstPrivateOperandsOperandsLoc;
  (void)gangFirstPrivateOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> gangFirstPrivateOperandsTypes;
  ::mlir::ArrayAttr firstprivatizationsAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> numGangsOperands;
  ::llvm::SMLoc numGangsOperandsLoc;
  (void)numGangsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> numGangsTypes;
  ::mlir::ArrayAttr numGangsDeviceTypeAttr;
  ::mlir::DenseI32ArrayAttr numGangsSegmentsAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> numWorkersOperands;
  ::llvm::SMLoc numWorkersOperandsLoc;
  (void)numWorkersOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> numWorkersTypes;
  ::mlir::ArrayAttr numWorkersDeviceTypeAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> gangPrivateOperandsOperands;
  ::llvm::SMLoc gangPrivateOperandsOperandsLoc;
  (void)gangPrivateOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> gangPrivateOperandsTypes;
  ::mlir::ArrayAttr privatizationsAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> vectorLengthOperands;
  ::llvm::SMLoc vectorLengthOperandsLoc;
  (void)vectorLengthOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> vectorLengthTypes;
  ::mlir::ArrayAttr vectorLengthDeviceTypeAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitOperandsOperands;
  ::llvm::SMLoc waitOperandsOperandsLoc;
  (void)waitOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitOperandsTypes;
  ::mlir::ArrayAttr waitOperandsDeviceTypeAttr;
  ::mlir::DenseI32ArrayAttr waitOperandsSegmentsAttr;
  ::mlir::ArrayAttr hasWaitDevnumAttr;
  ::mlir::ArrayAttr waitOnlyAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> selfCondOperands;
  ::llvm::SMLoc selfCondOperandsLoc;
  (void)selfCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> reductionOperandsOperands;
  ::llvm::SMLoc reductionOperandsOperandsLoc;
  (void)reductionOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> reductionOperandsTypes;
  ::mlir::ArrayAttr reductionRecipesAttr;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();
  if (::mlir::succeeded(parser.parseOptionalKeyword("combined"))) {
    result.getOrAddProperties<ParallelOp::Properties>().combined = parser.getBuilder().getUnitAttr();  if (parser.parseLParen())
    return ::mlir::failure();
  if (parser.parseKeyword("loop"))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  bool dataOperandsClause = false;
  bool asyncClause = false;
  bool firstprivateClause = false;
  bool num_gangsClause = false;
  bool num_workersClause = false;
  bool privateClause = false;
  bool vector_lengthClause = false;
  bool waitClause = false;
  bool selfClause = false;
  bool ifClause = false;
  bool reductionClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<ParallelOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("firstprivate"))) {

  if (firstprivateClause) {
    return parser.emitError(parser.getNameLoc())
          << "`firstprivate` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  firstprivateClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    gangFirstPrivateOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseSymOperandList(parser, gangFirstPrivateOperandsOperands, gangFirstPrivateOperandsTypes, firstprivatizationsAttr);
    if (odsResult) return ::mlir::failure();
    if (firstprivatizationsAttr)
      result.getOrAddProperties<ParallelOp::Properties>().firstprivatizations = firstprivatizationsAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("num_gangs"))) {

  if (num_gangsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`num_gangs` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  num_gangsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    numGangsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseNumGangs(parser, numGangsOperands, numGangsTypes, numGangsDeviceTypeAttr, numGangsSegmentsAttr);
    if (odsResult) return ::mlir::failure();
    if (numGangsDeviceTypeAttr)
      result.getOrAddProperties<ParallelOp::Properties>().numGangsDeviceType = numGangsDeviceTypeAttr;
    if (numGangsSegmentsAttr)
      result.getOrAddProperties<ParallelOp::Properties>().numGangsSegments = numGangsSegmentsAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("num_workers"))) {

  if (num_workersClause) {
    return parser.emitError(parser.getNameLoc())
          << "`num_workers` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  num_workersClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    numWorkersOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, numWorkersOperands, numWorkersTypes, numWorkersDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (numWorkersDeviceTypeAttr)
      result.getOrAddProperties<ParallelOp::Properties>().numWorkersDeviceType = numWorkersDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("private"))) {

  if (privateClause) {
    return parser.emitError(parser.getNameLoc())
          << "`private` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  privateClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    gangPrivateOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseSymOperandList(parser, gangPrivateOperandsOperands, gangPrivateOperandsTypes, privatizationsAttr);
    if (odsResult) return ::mlir::failure();
    if (privatizationsAttr)
      result.getOrAddProperties<ParallelOp::Properties>().privatizations = privatizationsAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("vector_length"))) {

  if (vector_lengthClause) {
    return parser.emitError(parser.getNameLoc())
          << "`vector_length` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  vector_lengthClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    vectorLengthOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, vectorLengthOperands, vectorLengthTypes, vectorLengthDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (vectorLengthDeviceTypeAttr)
      result.getOrAddProperties<ParallelOp::Properties>().vectorLengthDeviceType = vectorLengthDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("wait"))) {

  if (waitClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  waitClause = true;
  {
    waitOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseWaitClause(parser, waitOperandsOperands, waitOperandsTypes, waitOperandsDeviceTypeAttr, waitOperandsSegmentsAttr, hasWaitDevnumAttr, waitOnlyAttr);
    if (odsResult) return ::mlir::failure();
    if (waitOperandsDeviceTypeAttr)
      result.getOrAddProperties<ParallelOp::Properties>().waitOperandsDeviceType = waitOperandsDeviceTypeAttr;
    if (waitOperandsSegmentsAttr)
      result.getOrAddProperties<ParallelOp::Properties>().waitOperandsSegments = waitOperandsSegmentsAttr;
    if (hasWaitDevnumAttr)
      result.getOrAddProperties<ParallelOp::Properties>().hasWaitDevnum = hasWaitDevnumAttr;
    if (waitOnlyAttr)
      result.getOrAddProperties<ParallelOp::Properties>().waitOnly = waitOnlyAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("self"))) {

  if (selfClause) {
    return parser.emitError(parser.getNameLoc())
          << "`self` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  selfClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    selfCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      selfCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("reduction"))) {

  if (reductionClause) {
    return parser.emitError(parser.getNameLoc())
          << "`reduction` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  reductionClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    reductionOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseSymOperandList(parser, reductionOperandsOperands, reductionOperandsTypes, reductionRecipesAttr);
    if (odsResult) return ::mlir::failure();
    if (reductionRecipesAttr)
      result.getOrAddProperties<ParallelOp::Properties>().reductionRecipes = reductionRecipesAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperandsOperands.size()), static_cast<int32_t>(waitOperandsOperands.size()), static_cast<int32_t>(numGangsOperands.size()), static_cast<int32_t>(numWorkersOperands.size()), static_cast<int32_t>(vectorLengthOperands.size()), static_cast<int32_t>(ifCondOperands.size()), static_cast<int32_t>(selfCondOperands.size()), static_cast<int32_t>(reductionOperandsOperands.size()), static_cast<int32_t>(gangPrivateOperandsOperands.size()), static_cast<int32_t>(gangFirstPrivateOperandsOperands.size()), static_cast<int32_t>(dataClauseOperandsOperands.size())}), result.getOrAddProperties<ParallelOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitOperandsOperands, waitOperandsTypes, waitOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(numGangsOperands, numGangsTypes, numGangsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(numWorkersOperands, numWorkersTypes, numWorkersOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(vectorLengthOperands, vectorLengthTypes, vectorLengthOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(selfCondOperands, odsBuildableType0, selfCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(reductionOperandsOperands, reductionOperandsTypes, reductionOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(gangPrivateOperandsOperands, gangPrivateOperandsTypes, gangPrivateOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(gangFirstPrivateOperandsOperands, gangFirstPrivateOperandsTypes, gangFirstPrivateOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ParallelOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if ((getCombinedAttr() && getCombinedAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "combined";
    _odsPrinter << "(";
    _odsPrinter << "loop";
    _odsPrinter << ")";
  }
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  if (false || getGangFirstPrivateOperands().size() || (getFirstprivatizationsAttr())) {
  _odsPrinter << ' ' << "firstprivate";
  _odsPrinter << "(";
  printSymOperandList(_odsPrinter, *this, getGangFirstPrivateOperands(), getGangFirstPrivateOperands().getTypes(), getFirstprivatizationsAttr());
  _odsPrinter << ")";
  }
  if (false || getNumGangs().size() || (getNumGangsDeviceTypeAttr()) || (getNumGangsSegmentsAttr())) {
  _odsPrinter << ' ' << "num_gangs";
  _odsPrinter << "(";
  printNumGangs(_odsPrinter, *this, getNumGangs(), getNumGangs().getTypes(), getNumGangsDeviceTypeAttr(), getNumGangsSegmentsAttr());
  _odsPrinter << ")";
  }
  if (false || getNumWorkers().size() || (getNumWorkersDeviceTypeAttr())) {
  _odsPrinter << ' ' << "num_workers";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getNumWorkers(), getNumWorkers().getTypes(), getNumWorkersDeviceTypeAttr());
  _odsPrinter << ")";
  }
  if (false || getGangPrivateOperands().size() || (getPrivatizationsAttr())) {
  _odsPrinter << ' ' << "private";
  _odsPrinter << "(";
  printSymOperandList(_odsPrinter, *this, getGangPrivateOperands(), getGangPrivateOperands().getTypes(), getPrivatizationsAttr());
  _odsPrinter << ")";
  }
  if (false || getVectorLength().size() || (getVectorLengthDeviceTypeAttr())) {
  _odsPrinter << ' ' << "vector_length";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getVectorLength(), getVectorLength().getTypes(), getVectorLengthDeviceTypeAttr());
  _odsPrinter << ")";
  }
  if (false || getWaitOperands().size() || (getWaitOperandsDeviceTypeAttr()) || (getWaitOperandsSegmentsAttr()) || (getHasWaitDevnumAttr()) || (getWaitOnlyAttr())) {
  _odsPrinter << ' ' << "wait";
  printWaitClause(_odsPrinter, *this, getWaitOperands(), getWaitOperands().getTypes(), getWaitOperandsDeviceTypeAttr(), getWaitOperandsSegmentsAttr(), getHasWaitDevnumAttr(), getWaitOnlyAttr());
  }
  if (false || getSelfCond()) {
  _odsPrinter << ' ' << "self";
  _odsPrinter << "(";
  if (::mlir::Value value = getSelfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getReductionOperands().size() || (getReductionRecipesAttr())) {
  _odsPrinter << ' ' << "reduction";
  _odsPrinter << "(";
  printSymOperandList(_odsPrinter, *this, getReductionOperands(), getReductionOperands().getTypes(), getReductionRecipesAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getRegion());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("combined");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  elidedAttrs.push_back("firstprivatizations");
  elidedAttrs.push_back("numGangsDeviceType");
  elidedAttrs.push_back("numGangsSegments");
  elidedAttrs.push_back("numWorkersDeviceType");
  elidedAttrs.push_back("privatizations");
  elidedAttrs.push_back("vectorLengthDeviceType");
  elidedAttrs.push_back("waitOperandsDeviceType");
  elidedAttrs.push_back("waitOperandsSegments");
  elidedAttrs.push_back("hasWaitDevnum");
  elidedAttrs.push_back("waitOnly");
  elidedAttrs.push_back("reductionRecipes");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getSelfAttrAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("selfAttr");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getCombinedAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("combined");
  }
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void ParallelOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::ParallelOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::PresentOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
PresentOpGenericAdaptorBase::PresentOpGenericAdaptorBase(PresentOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> PresentOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > PresentOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > PresentOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr PresentOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause PresentOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr PresentOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool PresentOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr PresentOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool PresentOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > PresentOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
PresentOpAdaptor::PresentOpAdaptor(PresentOp op) : PresentOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult PresentOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.present' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.present' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.present' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.present' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.present' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.present' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> PresentOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange PresentOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange PresentOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange PresentOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult PresentOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute PresentOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code PresentOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> PresentOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void PresentOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void PresentOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult PresentOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult PresentOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void PresentOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > PresentOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > PresentOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause PresentOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool PresentOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool PresentOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > PresentOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void PresentOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void PresentOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void PresentOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void PresentOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void PresentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void PresentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PresentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void PresentOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PresentOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<PresentOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void PresentOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_present);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult PresentOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult PresentOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult PresentOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<PresentOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<PresentOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void PresentOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_present)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void PresentOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::PresentOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::PrivateOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
PrivateOpGenericAdaptorBase::PrivateOpGenericAdaptorBase(PrivateOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> PrivateOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > PrivateOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > PrivateOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr PrivateOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause PrivateOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr PrivateOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool PrivateOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr PrivateOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool PrivateOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > PrivateOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
PrivateOpAdaptor::PrivateOpAdaptor(PrivateOp op) : PrivateOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult PrivateOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.private' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.private' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.private' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.private' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.private' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.private' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> PrivateOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange PrivateOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange PrivateOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange PrivateOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult PrivateOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute PrivateOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code PrivateOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> PrivateOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void PrivateOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void PrivateOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult PrivateOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult PrivateOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void PrivateOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > PrivateOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > PrivateOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause PrivateOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool PrivateOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool PrivateOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > PrivateOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void PrivateOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void PrivateOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void PrivateOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void PrivateOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void PrivateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void PrivateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PrivateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void PrivateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PrivateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<PrivateOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void PrivateOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_private);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult PrivateOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult PrivateOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult PrivateOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<PrivateOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<PrivateOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void PrivateOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_private)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void PrivateOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSResultIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Write::get(), getOperation()->getOpResult(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::PrivateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::PrivateRecipeOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
PrivateRecipeOpGenericAdaptorBase::PrivateRecipeOpGenericAdaptorBase(PrivateRecipeOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef PrivateRecipeOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::Type PrivateRecipeOpGenericAdaptorBase::getType() {
  auto attr = getTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

} // namespace detail
PrivateRecipeOpAdaptor::PrivateRecipeOpAdaptor(PrivateRecipeOp op) : PrivateRecipeOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult PrivateRecipeOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'acc.private.recipe' op ""requires attribute 'sym_name'");
  auto tblgen_type = getProperties().type; (void)tblgen_type;
  if (!tblgen_type) return emitError(loc, "'acc.private.recipe' op ""requires attribute 'type'");

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'acc.private.recipe' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");

  if (tblgen_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_type))) && ((::llvm::isa<::mlir::Type>(::llvm::cast<::mlir::TypeAttr>(tblgen_type).getValue()))) && ((true))))
    return emitError(loc, "'acc.private.recipe' op ""attribute 'type' failed to satisfy constraint: any type attribute");
  return ::mlir::success();
}

::llvm::LogicalResult PrivateRecipeOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.type;
       auto attr = dict.get("type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute PrivateRecipeOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("type",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code PrivateRecipeOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()), 
    llvm::hash_value(prop.type.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> PrivateRecipeOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "sym_name")
      return prop.sym_name;

    if (name == "type")
      return prop.type;
  return std::nullopt;
}

void PrivateRecipeOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }

    if (name == "type") {
       prop.type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.type)>>(value);
       return;
    }
}

void PrivateRecipeOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);

    if (prop.type) attrs.append("type", prop.type);
}

::llvm::LogicalResult PrivateRecipeOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps1(attr, "type", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult PrivateRecipeOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.type)))
    return ::mlir::failure();
  return ::mlir::success();
}

void PrivateRecipeOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.sym_name);
  writer.writeAttribute(prop.type);
}

::llvm::StringRef PrivateRecipeOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::Type PrivateRecipeOp::getType() {
  auto attr = getTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

void PrivateRecipeOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void PrivateRecipeOp::setType(::mlir::Type attrValue) {
  getProperties().type = ::mlir::TypeAttr::get(attrValue);
}

void PrivateRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().type = type;
  (void)odsState.addRegion();
  (void)odsState.addRegion();
}

void PrivateRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().type = type;
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PrivateRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::Type type) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().type = ::mlir::TypeAttr::get(type);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
}

void PrivateRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::Type type) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().type = ::mlir::TypeAttr::get(type);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void PrivateRecipeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 2; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<PrivateRecipeOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult PrivateRecipeOp::verifyInvariantsImpl() {
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");
  auto tblgen_type = getProperties().type; (void)tblgen_type;
  if (!tblgen_type) return emitOpError("requires attribute 'type'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps1(*this, tblgen_type, "type")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "initRegion", index++)))
        return ::mlir::failure();

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(1)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "destroyRegion", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult PrivateRecipeOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult PrivateRecipeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr sym_nameAttr;
  ::mlir::TypeAttr typeAttr;
  std::unique_ptr<::mlir::Region> initRegionRegion = std::make_unique<::mlir::Region>();
  std::unique_ptr<::mlir::Region> destroyRegionRegion = std::make_unique<::mlir::Region>();

  if (parser.parseSymbolName(sym_nameAttr))
    return ::mlir::failure();
  if (sym_nameAttr) result.getOrAddProperties<PrivateRecipeOp::Properties>().sym_name = sym_nameAttr;
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(typeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (typeAttr) result.getOrAddProperties<PrivateRecipeOp::Properties>().type = typeAttr;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseKeyword("init"))
    return ::mlir::failure();

  if (parser.parseRegion(*initRegionRegion))
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("destroy"))) {

  if (parser.parseRegion(*destroyRegionRegion))
    return ::mlir::failure();
  }
  result.addRegion(std::move(initRegionRegion));
  result.addRegion(std::move(destroyRegionRegion));
  return ::mlir::success();
}

void PrivateRecipeOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printSymbolName(getSymNameAttr().getValue());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getTypeAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("sym_name");
  elidedAttrs.push_back("type");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << "init";
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getInitRegion());
  if (!getDestroyRegion().empty()) {
    _odsPrinter << ' ' << "destroy";
    _odsPrinter << ' ';
    _odsPrinter.printRegion(getDestroyRegion());
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::PrivateRecipeOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ReductionOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ReductionOpGenericAdaptorBase::ReductionOpGenericAdaptorBase(ReductionOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> ReductionOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > ReductionOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ReductionOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr ReductionOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause ReductionOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr ReductionOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool ReductionOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr ReductionOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool ReductionOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > ReductionOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
ReductionOpAdaptor::ReductionOpAdaptor(ReductionOp op) : ReductionOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReductionOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.reduction' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.reduction' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.reduction' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.reduction' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.reduction' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.reduction' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ReductionOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange ReductionOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ReductionOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ReductionOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult ReductionOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute ReductionOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ReductionOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> ReductionOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void ReductionOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void ReductionOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult ReductionOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ReductionOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void ReductionOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > ReductionOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > ReductionOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause ReductionOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool ReductionOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool ReductionOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > ReductionOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void ReductionOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void ReductionOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void ReductionOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void ReductionOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void ReductionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void ReductionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReductionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void ReductionOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReductionOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ReductionOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void ReductionOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_reduction);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult ReductionOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReductionOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ReductionOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<ReductionOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<ReductionOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReductionOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_reduction)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void ReductionOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
  {
    auto valueRange = getODSResultIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Write::get(), getOperation()->getOpResult(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::ReductionOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ReductionRecipeOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ReductionRecipeOpGenericAdaptorBase::ReductionRecipeOpGenericAdaptorBase(ReductionRecipeOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef ReductionRecipeOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::Type ReductionRecipeOpGenericAdaptorBase::getType() {
  auto attr = getTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

::mlir::acc::ReductionOperator ReductionRecipeOpGenericAdaptorBase::getReductionOperator() {
  auto attr = getReductionOperatorAttr();
  return attr.getValue();
}

} // namespace detail
ReductionRecipeOpAdaptor::ReductionRecipeOpAdaptor(ReductionRecipeOp op) : ReductionRecipeOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ReductionRecipeOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_reductionOperator = getProperties().reductionOperator; (void)tblgen_reductionOperator;
  if (!tblgen_reductionOperator) return emitError(loc, "'acc.reduction.recipe' op ""requires attribute 'reductionOperator'");
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'acc.reduction.recipe' op ""requires attribute 'sym_name'");
  auto tblgen_type = getProperties().type; (void)tblgen_type;
  if (!tblgen_type) return emitError(loc, "'acc.reduction.recipe' op ""requires attribute 'type'");

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'acc.reduction.recipe' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");

  if (tblgen_type && !(((::llvm::isa<::mlir::TypeAttr>(tblgen_type))) && ((::llvm::isa<::mlir::Type>(::llvm::cast<::mlir::TypeAttr>(tblgen_type).getValue()))) && ((true))))
    return emitError(loc, "'acc.reduction.recipe' op ""attribute 'type' failed to satisfy constraint: any type attribute");

  if (tblgen_reductionOperator && !((::llvm::isa<::mlir::acc::ReductionOperatorAttr>(tblgen_reductionOperator))))
    return emitError(loc, "'acc.reduction.recipe' op ""attribute 'reductionOperator' failed to satisfy constraint: built-in reduction operations supported by OpenACC");
  return ::mlir::success();
}

::llvm::LogicalResult ReductionRecipeOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.reductionOperator;
       auto attr = dict.get("reductionOperator");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `reductionOperator` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.type;
       auto attr = dict.get("type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute ReductionRecipeOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.reductionOperator;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("reductionOperator",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("type",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ReductionRecipeOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.reductionOperator.getAsOpaquePointer()), 
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()), 
    llvm::hash_value(prop.type.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> ReductionRecipeOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "reductionOperator")
      return prop.reductionOperator;

    if (name == "sym_name")
      return prop.sym_name;

    if (name == "type")
      return prop.type;
  return std::nullopt;
}

void ReductionRecipeOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "reductionOperator") {
       prop.reductionOperator = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.reductionOperator)>>(value);
       return;
    }

    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }

    if (name == "type") {
       prop.type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.type)>>(value);
       return;
    }
}

void ReductionRecipeOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.reductionOperator) attrs.append("reductionOperator", prop.reductionOperator);

    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);

    if (prop.type) attrs.append("type", prop.type);
}

::llvm::LogicalResult ReductionRecipeOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getReductionOperatorAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps16(attr, "reductionOperator", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps1(attr, "type", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ReductionRecipeOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readAttribute(prop.reductionOperator)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.type)))
    return ::mlir::failure();
  return ::mlir::success();
}

void ReductionRecipeOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;
  writer.writeAttribute(prop.reductionOperator);
  writer.writeAttribute(prop.sym_name);
  writer.writeAttribute(prop.type);
}

::llvm::StringRef ReductionRecipeOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::mlir::Type ReductionRecipeOp::getType() {
  auto attr = getTypeAttr();
  return ::llvm::cast<::mlir::Type>(attr.getValue());
}

::mlir::acc::ReductionOperator ReductionRecipeOp::getReductionOperator() {
  auto attr = getReductionOperatorAttr();
  return attr.getValue();
}

void ReductionRecipeOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void ReductionRecipeOp::setType(::mlir::Type attrValue) {
  getProperties().type = ::mlir::TypeAttr::get(attrValue);
}

void ReductionRecipeOp::setReductionOperator(::mlir::acc::ReductionOperator attrValue) {
  getProperties().reductionOperator = ::mlir::acc::ReductionOperatorAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void ReductionRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type, ::mlir::acc::ReductionOperatorAttr reductionOperator) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().type = type;
  odsState.getOrAddProperties<Properties>().reductionOperator = reductionOperator;
  (void)odsState.addRegion();
  (void)odsState.addRegion();
}

void ReductionRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::TypeAttr type, ::mlir::acc::ReductionOperatorAttr reductionOperator) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().type = type;
  odsState.getOrAddProperties<Properties>().reductionOperator = reductionOperator;
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReductionRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::mlir::Type type, ::mlir::acc::ReductionOperator reductionOperator) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().type = ::mlir::TypeAttr::get(type);
  odsState.getOrAddProperties<Properties>().reductionOperator = ::mlir::acc::ReductionOperatorAttr::get(odsBuilder.getContext(), reductionOperator);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
}

void ReductionRecipeOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::mlir::Type type, ::mlir::acc::ReductionOperator reductionOperator) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().type = ::mlir::TypeAttr::get(type);
  odsState.getOrAddProperties<Properties>().reductionOperator = ::mlir::acc::ReductionOperatorAttr::get(odsBuilder.getContext(), reductionOperator);
  (void)odsState.addRegion();
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ReductionRecipeOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 2; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ReductionRecipeOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ReductionRecipeOp::verifyInvariantsImpl() {
  auto tblgen_reductionOperator = getProperties().reductionOperator; (void)tblgen_reductionOperator;
  if (!tblgen_reductionOperator) return emitOpError("requires attribute 'reductionOperator'");
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");
  auto tblgen_type = getProperties().type; (void)tblgen_type;
  if (!tblgen_type) return emitOpError("requires attribute 'type'");

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps1(*this, tblgen_type, "type")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps16(*this, tblgen_reductionOperator, "reductionOperator")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "initRegion", index++)))
        return ::mlir::failure();

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(1)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "combinerRegion", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult ReductionRecipeOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult ReductionRecipeOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr sym_nameAttr;
  ::mlir::TypeAttr typeAttr;
  ::mlir::acc::ReductionOperatorAttr reductionOperatorAttr;
  std::unique_ptr<::mlir::Region> initRegionRegion = std::make_unique<::mlir::Region>();
  std::unique_ptr<::mlir::Region> combinerRegionRegion = std::make_unique<::mlir::Region>();

  if (parser.parseSymbolName(sym_nameAttr))
    return ::mlir::failure();
  if (sym_nameAttr) result.getOrAddProperties<ReductionRecipeOp::Properties>().sym_name = sym_nameAttr;
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(typeAttr, parser.getBuilder().getType<::mlir::NoneType>())) {
    return ::mlir::failure();
  }
  if (typeAttr) result.getOrAddProperties<ReductionRecipeOp::Properties>().type = typeAttr;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  if (parser.parseKeyword("reduction_operator"))
    return ::mlir::failure();

  if (parser.parseCustomAttributeWithFallback(reductionOperatorAttr, ::mlir::Type{})) {
    return ::mlir::failure();
  }
  if (reductionOperatorAttr) result.getOrAddProperties<ReductionRecipeOp::Properties>().reductionOperator = reductionOperatorAttr;
  if (parser.parseKeyword("init"))
    return ::mlir::failure();

  if (parser.parseRegion(*initRegionRegion))
    return ::mlir::failure();
  if (parser.parseKeyword("combiner"))
    return ::mlir::failure();

  if (parser.parseRegion(*combinerRegionRegion))
    return ::mlir::failure();
  result.addRegion(std::move(initRegionRegion));
  result.addRegion(std::move(combinerRegionRegion));
  return ::mlir::success();
}

void ReductionRecipeOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printSymbolName(getSymNameAttr().getValue());
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter.printAttributeWithoutType(getTypeAttr());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("sym_name");
  elidedAttrs.push_back("type");
  elidedAttrs.push_back("reductionOperator");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
  _odsPrinter << ' ' << "reduction_operator";
  _odsPrinter << ' ';
_odsPrinter.printStrippedAttrOrType(getReductionOperatorAttr());
  _odsPrinter << ' ' << "init";
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getInitRegion());
  _odsPrinter << ' ' << "combiner";
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getCombinerRegion());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::ReductionRecipeOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::RoutineOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
RoutineOpGenericAdaptorBase::RoutineOpGenericAdaptorBase(RoutineOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

::llvm::StringRef RoutineOpGenericAdaptorBase::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::llvm::StringRef RoutineOpGenericAdaptorBase::getFuncName() {
  auto attr = getFuncNameAttr();
  return attr.getValue();
}

::std::optional< ::mlir::ArrayAttr > RoutineOpGenericAdaptorBase::getBindName() {
  auto attr = getBindNameAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOpGenericAdaptorBase::getBindNameDeviceType() {
  auto attr = getBindNameDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOpGenericAdaptorBase::getWorker() {
  auto attr = getWorkerAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOpGenericAdaptorBase::getVector() {
  auto attr = getVectorAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOpGenericAdaptorBase::getSeq() {
  auto attr = getSeqAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::UnitAttr RoutineOpGenericAdaptorBase::getNohostAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().nohost);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool RoutineOpGenericAdaptorBase::getNohost() {
  auto attr = getNohostAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::mlir::UnitAttr RoutineOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().implicit);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool RoutineOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > RoutineOpGenericAdaptorBase::getGang() {
  auto attr = getGangAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOpGenericAdaptorBase::getGangDim() {
  auto attr = getGangDimAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOpGenericAdaptorBase::getGangDimDeviceType() {
  auto attr = getGangDimDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

} // namespace detail
RoutineOpAdaptor::RoutineOpAdaptor(RoutineOp op) : RoutineOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult RoutineOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_bindName = getProperties().bindName; (void)tblgen_bindName;
  auto tblgen_bindNameDeviceType = getProperties().bindNameDeviceType; (void)tblgen_bindNameDeviceType;
  auto tblgen_func_name = getProperties().func_name; (void)tblgen_func_name;
  if (!tblgen_func_name) return emitError(loc, "'acc.routine' op ""requires attribute 'func_name'");
  auto tblgen_gang = getProperties().gang; (void)tblgen_gang;
  auto tblgen_gangDim = getProperties().gangDim; (void)tblgen_gangDim;
  auto tblgen_gangDimDeviceType = getProperties().gangDimDeviceType; (void)tblgen_gangDimDeviceType;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_nohost = getProperties().nohost; (void)tblgen_nohost;
  auto tblgen_seq = getProperties().seq; (void)tblgen_seq;
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitError(loc, "'acc.routine' op ""requires attribute 'sym_name'");
  auto tblgen_vector = getProperties().vector; (void)tblgen_vector;
  auto tblgen_worker = getProperties().worker; (void)tblgen_worker;

  if (tblgen_sym_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_sym_name))))
    return emitError(loc, "'acc.routine' op ""attribute 'sym_name' failed to satisfy constraint: string attribute");

  if (tblgen_func_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_func_name))))
    return emitError(loc, "'acc.routine' op ""attribute 'func_name' failed to satisfy constraint: string attribute");

  if (tblgen_bindName && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_bindName))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_bindName), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::StringAttr>(attr))); }))))
    return emitError(loc, "'acc.routine' op ""attribute 'bindName' failed to satisfy constraint: string array attribute");

  if (tblgen_bindNameDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_bindNameDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_bindNameDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.routine' op ""attribute 'bindNameDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_worker && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_worker))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_worker), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.routine' op ""attribute 'worker' failed to satisfy constraint: device type array attribute");

  if (tblgen_vector && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_vector))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_vector), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.routine' op ""attribute 'vector' failed to satisfy constraint: device type array attribute");

  if (tblgen_seq && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_seq))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_seq), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.routine' op ""attribute 'seq' failed to satisfy constraint: device type array attribute");

  if (tblgen_nohost && !((::llvm::isa<::mlir::UnitAttr>(tblgen_nohost))))
    return emitError(loc, "'acc.routine' op ""attribute 'nohost' failed to satisfy constraint: unit attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::UnitAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.routine' op ""attribute 'implicit' failed to satisfy constraint: unit attribute");

  if (tblgen_gang && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_gang))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_gang), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.routine' op ""attribute 'gang' failed to satisfy constraint: device type array attribute");

  if (tblgen_gangDim && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_gangDim))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_gangDim), [&](::mlir::Attribute attr) { return attr && (((::llvm::isa<::mlir::IntegerAttr>(attr))) && ((::llvm::cast<::mlir::IntegerAttr>(attr).getType().isSignlessInteger(64)))); }))))
    return emitError(loc, "'acc.routine' op ""attribute 'gangDim' failed to satisfy constraint: 64-bit integer array attribute");

  if (tblgen_gangDimDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_gangDimDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_gangDimDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.routine' op ""attribute 'gangDimDeviceType' failed to satisfy constraint: device type array attribute");
  return ::mlir::success();
}

::llvm::LogicalResult RoutineOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.bindName;
       auto attr = dict.get("bindName");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `bindName` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.bindNameDeviceType;
       auto attr = dict.get("bindNameDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `bindNameDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.func_name;
       auto attr = dict.get("func_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `func_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.gang;
       auto attr = dict.get("gang");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `gang` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.gangDim;
       auto attr = dict.get("gangDim");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `gangDim` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.gangDimDeviceType;
       auto attr = dict.get("gangDimDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `gangDimDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.nohost;
       auto attr = dict.get("nohost");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `nohost` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.seq;
       auto attr = dict.get("seq");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `seq` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.sym_name;
       auto attr = dict.get("sym_name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `sym_name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.vector;
       auto attr = dict.get("vector");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `vector` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.worker;
       auto attr = dict.get("worker");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `worker` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
  return ::mlir::success();
}

::mlir::Attribute RoutineOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.bindName;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("bindName",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.bindNameDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("bindNameDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.func_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("func_name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.gang;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("gang",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.gangDim;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("gangDim",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.gangDimDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("gangDimDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.nohost;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("nohost",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.seq;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("seq",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.sym_name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("sym_name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.vector;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("vector",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.worker;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("worker",
                                       propStorage));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code RoutineOp::computePropertiesHash(const Properties &prop) {
  return llvm::hash_combine(
    llvm::hash_value(prop.bindName.getAsOpaquePointer()), 
    llvm::hash_value(prop.bindNameDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.func_name.getAsOpaquePointer()), 
    llvm::hash_value(prop.gang.getAsOpaquePointer()), 
    llvm::hash_value(prop.gangDim.getAsOpaquePointer()), 
    llvm::hash_value(prop.gangDimDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.nohost.getAsOpaquePointer()), 
    llvm::hash_value(prop.seq.getAsOpaquePointer()), 
    llvm::hash_value(prop.sym_name.getAsOpaquePointer()), 
    llvm::hash_value(prop.vector.getAsOpaquePointer()), 
    llvm::hash_value(prop.worker.getAsOpaquePointer()));
}

std::optional<mlir::Attribute> RoutineOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "bindName")
      return prop.bindName;

    if (name == "bindNameDeviceType")
      return prop.bindNameDeviceType;

    if (name == "func_name")
      return prop.func_name;

    if (name == "gang")
      return prop.gang;

    if (name == "gangDim")
      return prop.gangDim;

    if (name == "gangDimDeviceType")
      return prop.gangDimDeviceType;

    if (name == "implicit")
      return prop.implicit;

    if (name == "nohost")
      return prop.nohost;

    if (name == "seq")
      return prop.seq;

    if (name == "sym_name")
      return prop.sym_name;

    if (name == "vector")
      return prop.vector;

    if (name == "worker")
      return prop.worker;
  return std::nullopt;
}

void RoutineOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "bindName") {
       prop.bindName = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.bindName)>>(value);
       return;
    }

    if (name == "bindNameDeviceType") {
       prop.bindNameDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.bindNameDeviceType)>>(value);
       return;
    }

    if (name == "func_name") {
       prop.func_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.func_name)>>(value);
       return;
    }

    if (name == "gang") {
       prop.gang = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.gang)>>(value);
       return;
    }

    if (name == "gangDim") {
       prop.gangDim = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.gangDim)>>(value);
       return;
    }

    if (name == "gangDimDeviceType") {
       prop.gangDimDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.gangDimDeviceType)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "nohost") {
       prop.nohost = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.nohost)>>(value);
       return;
    }

    if (name == "seq") {
       prop.seq = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.seq)>>(value);
       return;
    }

    if (name == "sym_name") {
       prop.sym_name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.sym_name)>>(value);
       return;
    }

    if (name == "vector") {
       prop.vector = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.vector)>>(value);
       return;
    }

    if (name == "worker") {
       prop.worker = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.worker)>>(value);
       return;
    }
}

void RoutineOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.bindName) attrs.append("bindName", prop.bindName);

    if (prop.bindNameDeviceType) attrs.append("bindNameDeviceType", prop.bindNameDeviceType);

    if (prop.func_name) attrs.append("func_name", prop.func_name);

    if (prop.gang) attrs.append("gang", prop.gang);

    if (prop.gangDim) attrs.append("gangDim", prop.gangDim);

    if (prop.gangDimDeviceType) attrs.append("gangDimDeviceType", prop.gangDimDeviceType);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.nohost) attrs.append("nohost", prop.nohost);

    if (prop.seq) attrs.append("seq", prop.seq);

    if (prop.sym_name) attrs.append("sym_name", prop.sym_name);

    if (prop.vector) attrs.append("vector", prop.vector);

    if (prop.worker) attrs.append("worker", prop.worker);
}

::llvm::LogicalResult RoutineOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getBindNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps17(attr, "bindName", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getBindNameDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "bindNameDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFuncNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "func_name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getGangAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "gang", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getGangDimAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps12(attr, "gangDim", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getGangDimDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "gangDimDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNohostAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "nohost", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSeqAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "seq", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSymNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "sym_name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getVectorAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "vector", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWorkerAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "worker", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult RoutineOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.bindName)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.bindNameDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.func_name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.gang)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.gangDim)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.gangDimDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.nohost)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.seq)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readAttribute(prop.sym_name)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.vector)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.worker)))
    return ::mlir::failure();
  return ::mlir::success();
}

void RoutineOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.bindName);

  writer.writeOptionalAttribute(prop.bindNameDeviceType);
  writer.writeAttribute(prop.func_name);

  writer.writeOptionalAttribute(prop.gang);

  writer.writeOptionalAttribute(prop.gangDim);

  writer.writeOptionalAttribute(prop.gangDimDeviceType);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.nohost);

  writer.writeOptionalAttribute(prop.seq);
  writer.writeAttribute(prop.sym_name);

  writer.writeOptionalAttribute(prop.vector);

  writer.writeOptionalAttribute(prop.worker);
}

::llvm::StringRef RoutineOp::getSymName() {
  auto attr = getSymNameAttr();
  return attr.getValue();
}

::llvm::StringRef RoutineOp::getFuncName() {
  auto attr = getFuncNameAttr();
  return attr.getValue();
}

::std::optional< ::mlir::ArrayAttr > RoutineOp::getBindName() {
  auto attr = getBindNameAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOp::getBindNameDeviceType() {
  auto attr = getBindNameDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOp::getWorker() {
  auto attr = getWorkerAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOp::getVector() {
  auto attr = getVectorAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOp::getSeq() {
  auto attr = getSeqAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

bool RoutineOp::getNohost() {
  auto attr = getNohostAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

bool RoutineOp::getImplicit() {
  auto attr = getImplicitAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > RoutineOp::getGang() {
  auto attr = getGangAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOp::getGangDim() {
  auto attr = getGangDimAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > RoutineOp::getGangDimDeviceType() {
  auto attr = getGangDimDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

void RoutineOp::setSymName(::llvm::StringRef attrValue) {
  getProperties().sym_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void RoutineOp::setFuncName(::llvm::StringRef attrValue) {
  getProperties().func_name = ::mlir::Builder((*this)->getContext()).getStringAttr(attrValue);
}

void RoutineOp::setNohost(bool attrValue) {
    auto &odsProp = getProperties().nohost;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void RoutineOp::setImplicit(bool attrValue) {
    auto &odsProp = getProperties().implicit;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void RoutineOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::StringAttr sym_name, ::mlir::StringAttr func_name, /*optional*/::mlir::ArrayAttr bindName, /*optional*/::mlir::ArrayAttr bindNameDeviceType, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, /*optional*/::mlir::ArrayAttr seq, /*optional*/::mlir::UnitAttr nohost, /*optional*/::mlir::UnitAttr implicit, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr gangDim, /*optional*/::mlir::ArrayAttr gangDimDeviceType) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().func_name = func_name;
  if (bindName) {
    odsState.getOrAddProperties<Properties>().bindName = bindName;
  }
  if (bindNameDeviceType) {
    odsState.getOrAddProperties<Properties>().bindNameDeviceType = bindNameDeviceType;
  }
  if (worker) {
    odsState.getOrAddProperties<Properties>().worker = worker;
  }
  if (vector) {
    odsState.getOrAddProperties<Properties>().vector = vector;
  }
  if (seq) {
    odsState.getOrAddProperties<Properties>().seq = seq;
  }
  if (nohost) {
    odsState.getOrAddProperties<Properties>().nohost = nohost;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (gang) {
    odsState.getOrAddProperties<Properties>().gang = gang;
  }
  if (gangDim) {
    odsState.getOrAddProperties<Properties>().gangDim = gangDim;
  }
  if (gangDimDeviceType) {
    odsState.getOrAddProperties<Properties>().gangDimDeviceType = gangDimDeviceType;
  }
}

void RoutineOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::StringAttr sym_name, ::mlir::StringAttr func_name, /*optional*/::mlir::ArrayAttr bindName, /*optional*/::mlir::ArrayAttr bindNameDeviceType, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, /*optional*/::mlir::ArrayAttr seq, /*optional*/::mlir::UnitAttr nohost, /*optional*/::mlir::UnitAttr implicit, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr gangDim, /*optional*/::mlir::ArrayAttr gangDimDeviceType) {
  odsState.getOrAddProperties<Properties>().sym_name = sym_name;
  odsState.getOrAddProperties<Properties>().func_name = func_name;
  if (bindName) {
    odsState.getOrAddProperties<Properties>().bindName = bindName;
  }
  if (bindNameDeviceType) {
    odsState.getOrAddProperties<Properties>().bindNameDeviceType = bindNameDeviceType;
  }
  if (worker) {
    odsState.getOrAddProperties<Properties>().worker = worker;
  }
  if (vector) {
    odsState.getOrAddProperties<Properties>().vector = vector;
  }
  if (seq) {
    odsState.getOrAddProperties<Properties>().seq = seq;
  }
  if (nohost) {
    odsState.getOrAddProperties<Properties>().nohost = nohost;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (gang) {
    odsState.getOrAddProperties<Properties>().gang = gang;
  }
  if (gangDim) {
    odsState.getOrAddProperties<Properties>().gangDim = gangDim;
  }
  if (gangDimDeviceType) {
    odsState.getOrAddProperties<Properties>().gangDimDeviceType = gangDimDeviceType;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RoutineOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::llvm::StringRef sym_name, ::llvm::StringRef func_name, /*optional*/::mlir::ArrayAttr bindName, /*optional*/::mlir::ArrayAttr bindNameDeviceType, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, /*optional*/::mlir::ArrayAttr seq, /*optional*/bool nohost, /*optional*/bool implicit, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr gangDim, /*optional*/::mlir::ArrayAttr gangDimDeviceType) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().func_name = odsBuilder.getStringAttr(func_name);
  if (bindName) {
    odsState.getOrAddProperties<Properties>().bindName = bindName;
  }
  if (bindNameDeviceType) {
    odsState.getOrAddProperties<Properties>().bindNameDeviceType = bindNameDeviceType;
  }
  if (worker) {
    odsState.getOrAddProperties<Properties>().worker = worker;
  }
  if (vector) {
    odsState.getOrAddProperties<Properties>().vector = vector;
  }
  if (seq) {
    odsState.getOrAddProperties<Properties>().seq = seq;
  }
  if (nohost) {
    odsState.getOrAddProperties<Properties>().nohost = ((nohost) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = ((implicit) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (gang) {
    odsState.getOrAddProperties<Properties>().gang = gang;
  }
  if (gangDim) {
    odsState.getOrAddProperties<Properties>().gangDim = gangDim;
  }
  if (gangDimDeviceType) {
    odsState.getOrAddProperties<Properties>().gangDimDeviceType = gangDimDeviceType;
  }
}

void RoutineOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::llvm::StringRef sym_name, ::llvm::StringRef func_name, /*optional*/::mlir::ArrayAttr bindName, /*optional*/::mlir::ArrayAttr bindNameDeviceType, /*optional*/::mlir::ArrayAttr worker, /*optional*/::mlir::ArrayAttr vector, /*optional*/::mlir::ArrayAttr seq, /*optional*/bool nohost, /*optional*/bool implicit, /*optional*/::mlir::ArrayAttr gang, /*optional*/::mlir::ArrayAttr gangDim, /*optional*/::mlir::ArrayAttr gangDimDeviceType) {
  odsState.getOrAddProperties<Properties>().sym_name = odsBuilder.getStringAttr(sym_name);
  odsState.getOrAddProperties<Properties>().func_name = odsBuilder.getStringAttr(func_name);
  if (bindName) {
    odsState.getOrAddProperties<Properties>().bindName = bindName;
  }
  if (bindNameDeviceType) {
    odsState.getOrAddProperties<Properties>().bindNameDeviceType = bindNameDeviceType;
  }
  if (worker) {
    odsState.getOrAddProperties<Properties>().worker = worker;
  }
  if (vector) {
    odsState.getOrAddProperties<Properties>().vector = vector;
  }
  if (seq) {
    odsState.getOrAddProperties<Properties>().seq = seq;
  }
  if (nohost) {
    odsState.getOrAddProperties<Properties>().nohost = ((nohost) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = ((implicit) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (gang) {
    odsState.getOrAddProperties<Properties>().gang = gang;
  }
  if (gangDim) {
    odsState.getOrAddProperties<Properties>().gangDim = gangDim;
  }
  if (gangDimDeviceType) {
    odsState.getOrAddProperties<Properties>().gangDimDeviceType = gangDimDeviceType;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void RoutineOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<RoutineOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult RoutineOp::verifyInvariantsImpl() {
  auto tblgen_bindName = getProperties().bindName; (void)tblgen_bindName;
  auto tblgen_bindNameDeviceType = getProperties().bindNameDeviceType; (void)tblgen_bindNameDeviceType;
  auto tblgen_func_name = getProperties().func_name; (void)tblgen_func_name;
  if (!tblgen_func_name) return emitOpError("requires attribute 'func_name'");
  auto tblgen_gang = getProperties().gang; (void)tblgen_gang;
  auto tblgen_gangDim = getProperties().gangDim; (void)tblgen_gangDim;
  auto tblgen_gangDimDeviceType = getProperties().gangDimDeviceType; (void)tblgen_gangDimDeviceType;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_nohost = getProperties().nohost; (void)tblgen_nohost;
  auto tblgen_seq = getProperties().seq; (void)tblgen_seq;
  auto tblgen_sym_name = getProperties().sym_name; (void)tblgen_sym_name;
  if (!tblgen_sym_name) return emitOpError("requires attribute 'sym_name'");
  auto tblgen_vector = getProperties().vector; (void)tblgen_vector;
  auto tblgen_worker = getProperties().worker; (void)tblgen_worker;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_sym_name, "sym_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_func_name, "func_name")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps17(*this, tblgen_bindName, "bindName")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_bindNameDeviceType, "bindNameDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_worker, "worker")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_vector, "vector")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_seq, "seq")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_nohost, "nohost")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_gang, "gang")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps12(*this, tblgen_gangDim, "gangDim")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_gangDimDeviceType, "gangDimDeviceType")))
    return ::mlir::failure();
  return ::mlir::success();
}

::llvm::LogicalResult RoutineOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult RoutineOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::StringAttr sym_nameAttr;
  ::mlir::StringAttr func_nameAttr;
  ::mlir::ArrayAttr bindNameAttr;
  ::mlir::ArrayAttr bindNameDeviceTypeAttr;
  ::mlir::ArrayAttr gangAttr;
  ::mlir::ArrayAttr gangDimAttr;
  ::mlir::ArrayAttr gangDimDeviceTypeAttr;
  ::mlir::ArrayAttr workerAttr;
  ::mlir::ArrayAttr vectorAttr;
  ::mlir::ArrayAttr seqAttr;

  if (parser.parseSymbolName(sym_nameAttr))
    return ::mlir::failure();
  if (sym_nameAttr) result.getOrAddProperties<RoutineOp::Properties>().sym_name = sym_nameAttr;
  if (parser.parseKeyword("func"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  if (parser.parseSymbolName(func_nameAttr))
    return ::mlir::failure();
  if (func_nameAttr) result.getOrAddProperties<RoutineOp::Properties>().func_name = func_nameAttr;
  if (parser.parseRParen())
    return ::mlir::failure();
  bool bindClause = false;
  bool gangClause = false;
  bool workerClause = false;
  bool vectorClause = false;
  bool seqClause = false;
  bool nohostClause = false;
  bool implicitClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("bind"))) {

  if (bindClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bind` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  bindClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    auto odsResult = parseBindName(parser, bindNameAttr, bindNameDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (bindNameAttr)
      result.getOrAddProperties<RoutineOp::Properties>().bindName = bindNameAttr;
    if (bindNameDeviceTypeAttr)
      result.getOrAddProperties<RoutineOp::Properties>().bindNameDeviceType = bindNameDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("gang"))) {

  if (gangClause) {
    return parser.emitError(parser.getNameLoc())
          << "`gang` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  gangClause = true;
  {
    auto odsResult = parseRoutineGangClause(parser, gangAttr, gangDimAttr, gangDimDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (gangAttr)
      result.getOrAddProperties<RoutineOp::Properties>().gang = gangAttr;
    if (gangDimAttr)
      result.getOrAddProperties<RoutineOp::Properties>().gangDim = gangDimAttr;
    if (gangDimDeviceTypeAttr)
      result.getOrAddProperties<RoutineOp::Properties>().gangDimDeviceType = gangDimDeviceTypeAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("worker"))) {

  if (workerClause) {
    return parser.emitError(parser.getNameLoc())
          << "`worker` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  workerClause = true;
  {
    auto odsResult = parseDeviceTypeArrayAttr(parser, workerAttr);
    if (odsResult) return ::mlir::failure();
    if (workerAttr)
      result.getOrAddProperties<RoutineOp::Properties>().worker = workerAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("vector"))) {

  if (vectorClause) {
    return parser.emitError(parser.getNameLoc())
          << "`vector` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  vectorClause = true;
  {
    auto odsResult = parseDeviceTypeArrayAttr(parser, vectorAttr);
    if (odsResult) return ::mlir::failure();
    if (vectorAttr)
      result.getOrAddProperties<RoutineOp::Properties>().vector = vectorAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("seq"))) {

  if (seqClause) {
    return parser.emitError(parser.getNameLoc())
          << "`seq` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  seqClause = true;
  {
    auto odsResult = parseDeviceTypeArrayAttr(parser, seqAttr);
    if (odsResult) return ::mlir::failure();
    if (seqAttr)
      result.getOrAddProperties<RoutineOp::Properties>().seq = seqAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("nohost"))) {

  if (nohostClause) {
    return parser.emitError(parser.getNameLoc())
          << "`nohost` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  nohostClause = true;
    result.getOrAddProperties<RoutineOp::Properties>().nohost = parser.getBuilder().getUnitAttr();    } else if (succeeded(parser.parseOptionalKeyword("implicit"))) {

  if (implicitClause) {
    return parser.emitError(parser.getNameLoc())
          << "`implicit` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  implicitClause = true;
    result.getOrAddProperties<RoutineOp::Properties>().implicit = parser.getBuilder().getUnitAttr();    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void RoutineOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ';
  _odsPrinter.printSymbolName(getSymNameAttr().getValue());
  _odsPrinter << ' ' << "func";
  _odsPrinter << "(";
  _odsPrinter.printSymbolName(getFuncNameAttr().getValue());
  _odsPrinter << ")";
  if (false || (getBindNameAttr()) || (getBindNameDeviceTypeAttr())) {
  _odsPrinter << ' ' << "bind";
  _odsPrinter << "(";
  printBindName(_odsPrinter, *this, getBindNameAttr(), getBindNameDeviceTypeAttr());
  _odsPrinter << ")";
  }
  if (false || (getGangAttr()) || (getGangDimAttr()) || (getGangDimDeviceTypeAttr())) {
  _odsPrinter << ' ' << "gang";
  printRoutineGangClause(_odsPrinter, *this, getGangAttr(), getGangDimAttr(), getGangDimDeviceTypeAttr());
  }
  if (false || (getWorkerAttr())) {
  _odsPrinter << ' ' << "worker";
  _odsPrinter << ' ';
  printDeviceTypeArrayAttr(_odsPrinter, *this, getWorkerAttr());
  }
  if (false || (getVectorAttr())) {
  _odsPrinter << ' ' << "vector";
  _odsPrinter << ' ';
  printDeviceTypeArrayAttr(_odsPrinter, *this, getVectorAttr());
  }
  if (false || (getSeqAttr())) {
  _odsPrinter << ' ' << "seq";
  _odsPrinter << ' ';
  printDeviceTypeArrayAttr(_odsPrinter, *this, getSeqAttr());
  }
  if (false || ((getNohostAttr() && getNohostAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr)))) {
  _odsPrinter << ' ' << "nohost";
  }
  if (false || ((getImplicitAttr() && getImplicitAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr)))) {
  _odsPrinter << ' ' << "implicit";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("sym_name");
  elidedAttrs.push_back("func_name");
  elidedAttrs.push_back("bindName");
  elidedAttrs.push_back("bindNameDeviceType");
  elidedAttrs.push_back("gang");
  elidedAttrs.push_back("gangDim");
  elidedAttrs.push_back("gangDimDeviceType");
  elidedAttrs.push_back("worker");
  elidedAttrs.push_back("vector");
  elidedAttrs.push_back("seq");
  elidedAttrs.push_back("nohost");
  elidedAttrs.push_back("implicit");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getNohostAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("nohost");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::RoutineOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::SerialOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
SerialOpGenericAdaptorBase::SerialOpGenericAdaptorBase(SerialOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> SerialOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > SerialOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> SerialOpGenericAdaptorBase::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOpGenericAdaptorBase::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOpGenericAdaptorBase::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOpGenericAdaptorBase::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::UnitAttr SerialOpGenericAdaptorBase::getSelfAttrAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().selfAttr);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool SerialOpGenericAdaptorBase::getSelfAttr() {
  auto attr = getSelfAttrAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > SerialOpGenericAdaptorBase::getReductionRecipes() {
  auto attr = getReductionRecipesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOpGenericAdaptorBase::getPrivatizations() {
  auto attr = getPrivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOpGenericAdaptorBase::getFirstprivatizations() {
  auto attr = getFirstprivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::mlir::acc::ClauseDefaultValue> SerialOpGenericAdaptorBase::getDefaultAttr() {
  auto attr = getDefaultAttrAttr();
  return attr ? ::std::optional<::mlir::acc::ClauseDefaultValue>(attr.getValue()) : (::std::nullopt);
}

::mlir::UnitAttr SerialOpGenericAdaptorBase::getCombinedAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().combined);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool SerialOpGenericAdaptorBase::getCombined() {
  auto attr = getCombinedAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
SerialOpAdaptor::SerialOpAdaptor(SerialOp op) : SerialOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SerialOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_combined = getProperties().combined; (void)tblgen_combined;
  auto tblgen_defaultAttr = getProperties().defaultAttr; (void)tblgen_defaultAttr;
  auto tblgen_firstprivatizations = getProperties().firstprivatizations; (void)tblgen_firstprivatizations;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_privatizations = getProperties().privatizations; (void)tblgen_privatizations;
  auto tblgen_reductionRecipes = getProperties().reductionRecipes; (void)tblgen_reductionRecipes;
  auto tblgen_selfAttr = getProperties().selfAttr; (void)tblgen_selfAttr;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.serial' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.serial' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_waitOperandsSegments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_waitOperandsSegments))))
    return emitError(loc, "'acc.serial' op ""attribute 'waitOperandsSegments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_waitOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.serial' op ""attribute 'waitOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_hasWaitDevnum && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_hasWaitDevnum))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_hasWaitDevnum), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::BoolAttr>(attr))); }))))
    return emitError(loc, "'acc.serial' op ""attribute 'hasWaitDevnum' failed to satisfy constraint: 1-bit boolean array attribute");

  if (tblgen_waitOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.serial' op ""attribute 'waitOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_selfAttr && !((::llvm::isa<::mlir::UnitAttr>(tblgen_selfAttr))))
    return emitError(loc, "'acc.serial' op ""attribute 'selfAttr' failed to satisfy constraint: unit attribute");

  if (tblgen_reductionRecipes && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_reductionRecipes))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_reductionRecipes), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::SymbolRefAttr>(attr))); }))))
    return emitError(loc, "'acc.serial' op ""attribute 'reductionRecipes' failed to satisfy constraint: symbol ref array attribute");

  if (tblgen_privatizations && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_privatizations))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_privatizations), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::SymbolRefAttr>(attr))); }))))
    return emitError(loc, "'acc.serial' op ""attribute 'privatizations' failed to satisfy constraint: symbol ref array attribute");

  if (tblgen_firstprivatizations && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_firstprivatizations))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_firstprivatizations), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::SymbolRefAttr>(attr))); }))))
    return emitError(loc, "'acc.serial' op ""attribute 'firstprivatizations' failed to satisfy constraint: symbol ref array attribute");

  if (tblgen_defaultAttr && !((::llvm::isa<::mlir::acc::ClauseDefaultValueAttr>(tblgen_defaultAttr))))
    return emitError(loc, "'acc.serial' op ""attribute 'defaultAttr' failed to satisfy constraint: DefaultValue Clause");

  if (tblgen_combined && !((::llvm::isa<::mlir::UnitAttr>(tblgen_combined))))
    return emitError(loc, "'acc.serial' op ""attribute 'combined' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SerialOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange SerialOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange SerialOp::getWaitOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange SerialOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange SerialOp::getSelfCondMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange SerialOp::getReductionOperandsMutable() {
  auto range = getODSOperandIndexAndLength(4);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(4u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange SerialOp::getGangPrivateOperandsMutable() {
  auto range = getODSOperandIndexAndLength(5);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(5u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange SerialOp::getGangFirstPrivateOperandsMutable() {
  auto range = getODSOperandIndexAndLength(6);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(6u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange SerialOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(7);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(7u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult SerialOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.combined;
       auto attr = dict.get("combined");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `combined` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.defaultAttr;
       auto attr = dict.get("defaultAttr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `defaultAttr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.firstprivatizations;
       auto attr = dict.get("firstprivatizations");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `firstprivatizations` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.hasWaitDevnum;
       auto attr = dict.get("hasWaitDevnum");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `hasWaitDevnum` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.privatizations;
       auto attr = dict.get("privatizations");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `privatizations` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.reductionRecipes;
       auto attr = dict.get("reductionRecipes");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `reductionRecipes` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.selfAttr;
       auto attr = dict.get("selfAttr");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `selfAttr` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOnly;
       auto attr = dict.get("waitOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsDeviceType;
       auto attr = dict.get("waitOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsSegments;
       auto attr = dict.get("waitOperandsSegments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsSegments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute SerialOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.combined;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("combined",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.defaultAttr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("defaultAttr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.firstprivatizations;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("firstprivatizations",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.hasWaitDevnum;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("hasWaitDevnum",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.privatizations;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("privatizations",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.reductionRecipes;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("reductionRecipes",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.selfAttr;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("selfAttr",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsSegments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsSegments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SerialOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.combined.getAsOpaquePointer()), 
    llvm::hash_value(prop.defaultAttr.getAsOpaquePointer()), 
    llvm::hash_value(prop.firstprivatizations.getAsOpaquePointer()), 
    llvm::hash_value(prop.hasWaitDevnum.getAsOpaquePointer()), 
    llvm::hash_value(prop.privatizations.getAsOpaquePointer()), 
    llvm::hash_value(prop.reductionRecipes.getAsOpaquePointer()), 
    llvm::hash_value(prop.selfAttr.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsSegments.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> SerialOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "combined")
      return prop.combined;

    if (name == "defaultAttr")
      return prop.defaultAttr;

    if (name == "firstprivatizations")
      return prop.firstprivatizations;

    if (name == "hasWaitDevnum")
      return prop.hasWaitDevnum;

    if (name == "privatizations")
      return prop.privatizations;

    if (name == "reductionRecipes")
      return prop.reductionRecipes;

    if (name == "selfAttr")
      return prop.selfAttr;

    if (name == "waitOnly")
      return prop.waitOnly;

    if (name == "waitOperandsDeviceType")
      return prop.waitOperandsDeviceType;

    if (name == "waitOperandsSegments")
      return prop.waitOperandsSegments;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void SerialOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "combined") {
       prop.combined = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.combined)>>(value);
       return;
    }

    if (name == "defaultAttr") {
       prop.defaultAttr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.defaultAttr)>>(value);
       return;
    }

    if (name == "firstprivatizations") {
       prop.firstprivatizations = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.firstprivatizations)>>(value);
       return;
    }

    if (name == "hasWaitDevnum") {
       prop.hasWaitDevnum = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.hasWaitDevnum)>>(value);
       return;
    }

    if (name == "privatizations") {
       prop.privatizations = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.privatizations)>>(value);
       return;
    }

    if (name == "reductionRecipes") {
       prop.reductionRecipes = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.reductionRecipes)>>(value);
       return;
    }

    if (name == "selfAttr") {
       prop.selfAttr = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.selfAttr)>>(value);
       return;
    }

    if (name == "waitOnly") {
       prop.waitOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOnly)>>(value);
       return;
    }

    if (name == "waitOperandsDeviceType") {
       prop.waitOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsDeviceType)>>(value);
       return;
    }

    if (name == "waitOperandsSegments") {
       prop.waitOperandsSegments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsSegments)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void SerialOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.combined) attrs.append("combined", prop.combined);

    if (prop.defaultAttr) attrs.append("defaultAttr", prop.defaultAttr);

    if (prop.firstprivatizations) attrs.append("firstprivatizations", prop.firstprivatizations);

    if (prop.hasWaitDevnum) attrs.append("hasWaitDevnum", prop.hasWaitDevnum);

    if (prop.privatizations) attrs.append("privatizations", prop.privatizations);

    if (prop.reductionRecipes) attrs.append("reductionRecipes", prop.reductionRecipes);

    if (prop.selfAttr) attrs.append("selfAttr", prop.selfAttr);

    if (prop.waitOnly) attrs.append("waitOnly", prop.waitOnly);

    if (prop.waitOperandsDeviceType) attrs.append("waitOperandsDeviceType", prop.waitOperandsDeviceType);

    if (prop.waitOperandsSegments) attrs.append("waitOperandsSegments", prop.waitOperandsSegments);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult SerialOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getCombinedAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "combined", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDefaultAttrAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps8(attr, "defaultAttr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getFirstprivatizationsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(attr, "firstprivatizations", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getHasWaitDevnumAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(attr, "hasWaitDevnum", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getPrivatizationsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(attr, "privatizations", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getReductionRecipesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(attr, "reductionRecipes", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getSelfAttrAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "selfAttr", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(attr, "waitOperandsSegments", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult SerialOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.combined)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.defaultAttr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.firstprivatizations)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.hasWaitDevnum)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.privatizations)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.reductionRecipes)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.selfAttr)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsSegments)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void SerialOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.combined);

  writer.writeOptionalAttribute(prop.defaultAttr);

  writer.writeOptionalAttribute(prop.firstprivatizations);

  writer.writeOptionalAttribute(prop.hasWaitDevnum);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.privatizations);

  writer.writeOptionalAttribute(prop.reductionRecipes);

  writer.writeOptionalAttribute(prop.selfAttr);

  writer.writeOptionalAttribute(prop.waitOnly);

  writer.writeOptionalAttribute(prop.waitOperandsDeviceType);

  writer.writeOptionalAttribute(prop.waitOperandsSegments);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > SerialOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> SerialOp::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOp::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOp::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOp::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

bool SerialOp::getSelfAttr() {
  auto attr = getSelfAttrAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

::std::optional< ::mlir::ArrayAttr > SerialOp::getReductionRecipes() {
  auto attr = getReductionRecipesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOp::getPrivatizations() {
  auto attr = getPrivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > SerialOp::getFirstprivatizations() {
  auto attr = getFirstprivatizationsAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::mlir::acc::ClauseDefaultValue> SerialOp::getDefaultAttr() {
  auto attr = getDefaultAttrAttr();
  return attr ? ::std::optional<::mlir::acc::ClauseDefaultValue>(attr.getValue()) : (::std::nullopt);
}

bool SerialOp::getCombined() {
  auto attr = getCombinedAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void SerialOp::setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().waitOperandsSegments;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void SerialOp::setSelfAttr(bool attrValue) {
    auto &odsProp = getProperties().selfAttr;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void SerialOp::setDefaultAttr(::std::optional<::mlir::acc::ClauseDefaultValue> attrValue) {
    auto &odsProp = getProperties().defaultAttr;
    if (attrValue)
      odsProp = ::mlir::acc::ClauseDefaultValueAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void SerialOp::setCombined(bool attrValue) {
    auto &odsProp = getProperties().combined;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void SerialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/::mlir::UnitAttr combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(reductionOperands);
  odsState.addOperands(gangPrivateOperands);
  odsState.addOperands(gangFirstPrivateOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(reductionOperands.size()), static_cast<int32_t>(gangPrivateOperands.size()), static_cast<int32_t>(gangFirstPrivateOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = selfAttr;
  }
  if (reductionRecipes) {
    odsState.getOrAddProperties<Properties>().reductionRecipes = reductionRecipes;
  }
  if (privatizations) {
    odsState.getOrAddProperties<Properties>().privatizations = privatizations;
  }
  if (firstprivatizations) {
    odsState.getOrAddProperties<Properties>().firstprivatizations = firstprivatizations;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = combined;
  }
  (void)odsState.addRegion();
}

void SerialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/::mlir::UnitAttr selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/::mlir::UnitAttr combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(reductionOperands);
  odsState.addOperands(gangPrivateOperands);
  odsState.addOperands(gangFirstPrivateOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(reductionOperands.size()), static_cast<int32_t>(gangPrivateOperands.size()), static_cast<int32_t>(gangFirstPrivateOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = selfAttr;
  }
  if (reductionRecipes) {
    odsState.getOrAddProperties<Properties>().reductionRecipes = reductionRecipes;
  }
  if (privatizations) {
    odsState.getOrAddProperties<Properties>().privatizations = privatizations;
  }
  if (firstprivatizations) {
    odsState.getOrAddProperties<Properties>().firstprivatizations = firstprivatizations;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = combined;
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SerialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/bool combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(reductionOperands);
  odsState.addOperands(gangPrivateOperands);
  odsState.addOperands(gangFirstPrivateOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(reductionOperands.size()), static_cast<int32_t>(gangPrivateOperands.size()), static_cast<int32_t>(gangFirstPrivateOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = ((selfAttr) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (reductionRecipes) {
    odsState.getOrAddProperties<Properties>().reductionRecipes = reductionRecipes;
  }
  if (privatizations) {
    odsState.getOrAddProperties<Properties>().privatizations = privatizations;
  }
  if (firstprivatizations) {
    odsState.getOrAddProperties<Properties>().firstprivatizations = firstprivatizations;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = ((combined) ? odsBuilder.getUnitAttr() : nullptr);
  }
  (void)odsState.addRegion();
}

void SerialOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, /*optional*/::mlir::Value ifCond, /*optional*/::mlir::Value selfCond, /*optional*/bool selfAttr, ::mlir::ValueRange reductionOperands, /*optional*/::mlir::ArrayAttr reductionRecipes, ::mlir::ValueRange gangPrivateOperands, /*optional*/::mlir::ArrayAttr privatizations, ::mlir::ValueRange gangFirstPrivateOperands, /*optional*/::mlir::ArrayAttr firstprivatizations, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::acc::ClauseDefaultValueAttr defaultAttr, /*optional*/bool combined) {
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  if (ifCond)
    odsState.addOperands(ifCond);
  if (selfCond)
    odsState.addOperands(selfCond);
  odsState.addOperands(reductionOperands);
  odsState.addOperands(gangPrivateOperands);
  odsState.addOperands(gangFirstPrivateOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), (ifCond ? 1 : 0), (selfCond ? 1 : 0), static_cast<int32_t>(reductionOperands.size()), static_cast<int32_t>(gangPrivateOperands.size()), static_cast<int32_t>(gangFirstPrivateOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (selfAttr) {
    odsState.getOrAddProperties<Properties>().selfAttr = ((selfAttr) ? odsBuilder.getUnitAttr() : nullptr);
  }
  if (reductionRecipes) {
    odsState.getOrAddProperties<Properties>().reductionRecipes = reductionRecipes;
  }
  if (privatizations) {
    odsState.getOrAddProperties<Properties>().privatizations = privatizations;
  }
  if (firstprivatizations) {
    odsState.getOrAddProperties<Properties>().firstprivatizations = firstprivatizations;
  }
  if (defaultAttr) {
    odsState.getOrAddProperties<Properties>().defaultAttr = defaultAttr;
  }
  if (combined) {
    odsState.getOrAddProperties<Properties>().combined = ((combined) ? odsBuilder.getUnitAttr() : nullptr);
  }
  (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SerialOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  for (unsigned i = 0; i != 1; ++i)
    (void)odsState.addRegion();
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SerialOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult SerialOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_combined = getProperties().combined; (void)tblgen_combined;
  auto tblgen_defaultAttr = getProperties().defaultAttr; (void)tblgen_defaultAttr;
  auto tblgen_firstprivatizations = getProperties().firstprivatizations; (void)tblgen_firstprivatizations;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_privatizations = getProperties().privatizations; (void)tblgen_privatizations;
  auto tblgen_reductionRecipes = getProperties().reductionRecipes; (void)tblgen_reductionRecipes;
  auto tblgen_selfAttr = getProperties().selfAttr; (void)tblgen_selfAttr;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(*this, tblgen_waitOperandsSegments, "waitOperandsSegments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOperandsDeviceType, "waitOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(*this, tblgen_hasWaitDevnum, "hasWaitDevnum")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOnly, "waitOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_selfAttr, "selfAttr")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(*this, tblgen_reductionRecipes, "reductionRecipes")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(*this, tblgen_privatizations, "privatizations")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps14(*this, tblgen_firstprivatizations, "firstprivatizations")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps8(*this, tblgen_defaultAttr, "defaultAttr")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_combined, "combined")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    if (valueGroup2.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup2.size();
    }

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    if (valueGroup3.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup3.size();
    }

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup4 = getODSOperands(4);

    for (auto v : valueGroup4) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps11(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup5 = getODSOperands(5);

    for (auto v : valueGroup5) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup6 = getODSOperands(6);

    for (auto v : valueGroup6) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup7 = getODSOperands(7);

    for (auto v : valueGroup7) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;

    for (auto &region : ::llvm::MutableArrayRef((*this)->getRegion(0)))
      if (::mlir::failed(__mlir_ods_local_region_constraint_OpenACCOps2(*this, region, "region", index++)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::llvm::LogicalResult SerialOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult SerialOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> gangFirstPrivateOperandsOperands;
  ::llvm::SMLoc gangFirstPrivateOperandsOperandsLoc;
  (void)gangFirstPrivateOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> gangFirstPrivateOperandsTypes;
  ::mlir::ArrayAttr firstprivatizationsAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> gangPrivateOperandsOperands;
  ::llvm::SMLoc gangPrivateOperandsOperandsLoc;
  (void)gangPrivateOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> gangPrivateOperandsTypes;
  ::mlir::ArrayAttr privatizationsAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitOperandsOperands;
  ::llvm::SMLoc waitOperandsOperandsLoc;
  (void)waitOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitOperandsTypes;
  ::mlir::ArrayAttr waitOperandsDeviceTypeAttr;
  ::mlir::DenseI32ArrayAttr waitOperandsSegmentsAttr;
  ::mlir::ArrayAttr hasWaitDevnumAttr;
  ::mlir::ArrayAttr waitOnlyAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> selfCondOperands;
  ::llvm::SMLoc selfCondOperandsLoc;
  (void)selfCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> reductionOperandsOperands;
  ::llvm::SMLoc reductionOperandsOperandsLoc;
  (void)reductionOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> reductionOperandsTypes;
  ::mlir::ArrayAttr reductionRecipesAttr;
  std::unique_ptr<::mlir::Region> regionRegion = std::make_unique<::mlir::Region>();
  if (::mlir::succeeded(parser.parseOptionalKeyword("combined"))) {
    result.getOrAddProperties<SerialOp::Properties>().combined = parser.getBuilder().getUnitAttr();  if (parser.parseLParen())
    return ::mlir::failure();
  if (parser.parseKeyword("loop"))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  bool dataOperandsClause = false;
  bool asyncClause = false;
  bool firstprivateClause = false;
  bool privateClause = false;
  bool waitClause = false;
  bool selfClause = false;
  bool ifClause = false;
  bool reductionClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<SerialOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("firstprivate"))) {

  if (firstprivateClause) {
    return parser.emitError(parser.getNameLoc())
          << "`firstprivate` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  firstprivateClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    gangFirstPrivateOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseSymOperandList(parser, gangFirstPrivateOperandsOperands, gangFirstPrivateOperandsTypes, firstprivatizationsAttr);
    if (odsResult) return ::mlir::failure();
    if (firstprivatizationsAttr)
      result.getOrAddProperties<SerialOp::Properties>().firstprivatizations = firstprivatizationsAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("private"))) {

  if (privateClause) {
    return parser.emitError(parser.getNameLoc())
          << "`private` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  privateClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    gangPrivateOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseSymOperandList(parser, gangPrivateOperandsOperands, gangPrivateOperandsTypes, privatizationsAttr);
    if (odsResult) return ::mlir::failure();
    if (privatizationsAttr)
      result.getOrAddProperties<SerialOp::Properties>().privatizations = privatizationsAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("wait"))) {

  if (waitClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  waitClause = true;
  {
    waitOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseWaitClause(parser, waitOperandsOperands, waitOperandsTypes, waitOperandsDeviceTypeAttr, waitOperandsSegmentsAttr, hasWaitDevnumAttr, waitOnlyAttr);
    if (odsResult) return ::mlir::failure();
    if (waitOperandsDeviceTypeAttr)
      result.getOrAddProperties<SerialOp::Properties>().waitOperandsDeviceType = waitOperandsDeviceTypeAttr;
    if (waitOperandsSegmentsAttr)
      result.getOrAddProperties<SerialOp::Properties>().waitOperandsSegments = waitOperandsSegmentsAttr;
    if (hasWaitDevnumAttr)
      result.getOrAddProperties<SerialOp::Properties>().hasWaitDevnum = hasWaitDevnumAttr;
    if (waitOnlyAttr)
      result.getOrAddProperties<SerialOp::Properties>().waitOnly = waitOnlyAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("self"))) {

  if (selfClause) {
    return parser.emitError(parser.getNameLoc())
          << "`self` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  selfClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    selfCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      selfCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("reduction"))) {

  if (reductionClause) {
    return parser.emitError(parser.getNameLoc())
          << "`reduction` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  reductionClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    reductionOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseSymOperandList(parser, reductionOperandsOperands, reductionOperandsTypes, reductionRecipesAttr);
    if (odsResult) return ::mlir::failure();
    if (reductionRecipesAttr)
      result.getOrAddProperties<SerialOp::Properties>().reductionRecipes = reductionRecipesAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}

  if (parser.parseRegion(*regionRegion))
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
  result.addRegion(std::move(regionRegion));
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(asyncOperandsOperands.size()), static_cast<int32_t>(waitOperandsOperands.size()), static_cast<int32_t>(ifCondOperands.size()), static_cast<int32_t>(selfCondOperands.size()), static_cast<int32_t>(reductionOperandsOperands.size()), static_cast<int32_t>(gangPrivateOperandsOperands.size()), static_cast<int32_t>(gangFirstPrivateOperandsOperands.size()), static_cast<int32_t>(dataClauseOperandsOperands.size())}), result.getOrAddProperties<SerialOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitOperandsOperands, waitOperandsTypes, waitOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(selfCondOperands, odsBuildableType0, selfCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(reductionOperandsOperands, reductionOperandsTypes, reductionOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(gangPrivateOperandsOperands, gangPrivateOperandsTypes, gangPrivateOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(gangFirstPrivateOperandsOperands, gangFirstPrivateOperandsTypes, gangFirstPrivateOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SerialOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if ((getCombinedAttr() && getCombinedAttr() != ((false) ? ::mlir::OpBuilder((*this)->getContext()).getUnitAttr() : nullptr))) {
    _odsPrinter << ' ' << "combined";
    _odsPrinter << "(";
    _odsPrinter << "loop";
    _odsPrinter << ")";
  }
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  if (false || getGangFirstPrivateOperands().size() || (getFirstprivatizationsAttr())) {
  _odsPrinter << ' ' << "firstprivate";
  _odsPrinter << "(";
  printSymOperandList(_odsPrinter, *this, getGangFirstPrivateOperands(), getGangFirstPrivateOperands().getTypes(), getFirstprivatizationsAttr());
  _odsPrinter << ")";
  }
  if (false || getGangPrivateOperands().size() || (getPrivatizationsAttr())) {
  _odsPrinter << ' ' << "private";
  _odsPrinter << "(";
  printSymOperandList(_odsPrinter, *this, getGangPrivateOperands(), getGangPrivateOperands().getTypes(), getPrivatizationsAttr());
  _odsPrinter << ")";
  }
  if (false || getWaitOperands().size() || (getWaitOperandsDeviceTypeAttr()) || (getWaitOperandsSegmentsAttr()) || (getHasWaitDevnumAttr()) || (getWaitOnlyAttr())) {
  _odsPrinter << ' ' << "wait";
  printWaitClause(_odsPrinter, *this, getWaitOperands(), getWaitOperands().getTypes(), getWaitOperandsDeviceTypeAttr(), getWaitOperandsSegmentsAttr(), getHasWaitDevnumAttr(), getWaitOnlyAttr());
  }
  if (false || getSelfCond()) {
  _odsPrinter << ' ' << "self";
  _odsPrinter << "(";
  if (::mlir::Value value = getSelfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getReductionOperands().size() || (getReductionRecipesAttr())) {
  _odsPrinter << ' ' << "reduction";
  _odsPrinter << "(";
  printSymOperandList(_odsPrinter, *this, getReductionOperands(), getReductionOperands().getTypes(), getReductionRecipesAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ';
  _odsPrinter.printRegion(getRegion());
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("combined");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  elidedAttrs.push_back("firstprivatizations");
  elidedAttrs.push_back("privatizations");
  elidedAttrs.push_back("waitOperandsDeviceType");
  elidedAttrs.push_back("waitOperandsSegments");
  elidedAttrs.push_back("hasWaitDevnum");
  elidedAttrs.push_back("waitOnly");
  elidedAttrs.push_back("reductionRecipes");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getSelfAttrAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("selfAttr");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getCombinedAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("combined");
  }
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void SerialOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::SerialOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::SetOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
SetOpGenericAdaptorBase::SetOpGenericAdaptorBase(SetOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> SetOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional<::mlir::acc::DeviceType> SetOpGenericAdaptorBase::getDeviceType() {
  auto attr = getDeviceTypeAttr();
  return attr ? ::std::optional<::mlir::acc::DeviceType>(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
SetOpAdaptor::SetOpAdaptor(SetOp op) : SetOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult SetOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_device_type = getProperties().device_type; (void)tblgen_device_type;

  if (tblgen_device_type && !((::llvm::isa<::mlir::acc::DeviceTypeAttr>(tblgen_device_type))))
    return emitError(loc, "'acc.set' op ""attribute 'device_type' failed to satisfy constraint: built-in device type supported by OpenACC");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> SetOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange SetOp::getDefaultAsyncMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange SetOp::getDeviceNumMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange SetOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult SetOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.device_type;
       auto attr = dict.get("device_type");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `device_type` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute SetOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.device_type;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("device_type",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code SetOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.device_type.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> SetOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "device_type")
      return prop.device_type;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void SetOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "device_type") {
       prop.device_type = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.device_type)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void SetOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.device_type) attrs.append("device_type", prop.device_type);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult SetOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps18(attr, "device_type", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult SetOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.device_type)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void SetOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.device_type);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional<::mlir::acc::DeviceType> SetOp::getDeviceType() {
  auto attr = getDeviceTypeAttr();
  return attr ? ::std::optional<::mlir::acc::DeviceType>(attr.getValue()) : (::std::nullopt);
}

void SetOp::setDeviceType(::std::optional<::mlir::acc::DeviceType> attrValue) {
    auto &odsProp = getProperties().device_type;
    if (attrValue)
      odsProp = ::mlir::acc::DeviceTypeAttr::get(::mlir::Builder((*this)->getContext()).getContext(), *attrValue);
    else
      odsProp = nullptr;
}

void SetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::acc::DeviceTypeAttr device_type, /*optional*/::mlir::Value defaultAsync, /*optional*/::mlir::Value deviceNum, /*optional*/::mlir::Value ifCond) {
  if (defaultAsync)
    odsState.addOperands(defaultAsync);
  if (deviceNum)
    odsState.addOperands(deviceNum);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(defaultAsync ? 1 : 0), (deviceNum ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (device_type) {
    odsState.getOrAddProperties<Properties>().device_type = device_type;
  }
}

void SetOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::acc::DeviceTypeAttr device_type, /*optional*/::mlir::Value defaultAsync, /*optional*/::mlir::Value deviceNum, /*optional*/::mlir::Value ifCond) {
  if (defaultAsync)
    odsState.addOperands(defaultAsync);
  if (deviceNum)
    odsState.addOperands(deviceNum);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(defaultAsync ? 1 : 0), (deviceNum ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (device_type) {
    odsState.getOrAddProperties<Properties>().device_type = device_type;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void SetOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<SetOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult SetOp::verifyInvariantsImpl() {
  auto tblgen_device_type = getProperties().device_type; (void)tblgen_device_type;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps18(*this, tblgen_device_type, "device_type")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    if (valueGroup2.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup2.size();
    }

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult SetOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult SetOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> defaultAsyncOperands;
  ::llvm::SMLoc defaultAsyncOperandsLoc;
  (void)defaultAsyncOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> defaultAsyncTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> deviceNumOperands;
  ::llvm::SMLoc deviceNumOperandsLoc;
  (void)deviceNumOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> deviceNumTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  bool default_asyncClause = false;
  bool device_numClause = false;
  bool ifClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("default_async"))) {

  if (default_asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`default_async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  default_asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    defaultAsyncOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      defaultAsyncOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      defaultAsyncTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("device_num"))) {

  if (device_numClause) {
    return parser.emitError(parser.getNameLoc())
          << "`device_num` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  device_numClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    deviceNumOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      deviceNumOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      deviceNumTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(defaultAsyncOperands.size()), static_cast<int32_t>(deviceNumOperands.size()), static_cast<int32_t>(ifCondOperands.size())}), result.getOrAddProperties<SetOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(defaultAsyncOperands, defaultAsyncTypes, defaultAsyncOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(deviceNumOperands, deviceNumTypes, deviceNumOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void SetOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getDefaultAsync()) {
  _odsPrinter << ' ' << "default_async";
  _odsPrinter << "(";
  if (::mlir::Value value = getDefaultAsync())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getDefaultAsync() ? ::llvm::ArrayRef<::mlir::Type>(getDefaultAsync().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getDeviceNum()) {
  _odsPrinter << ' ' << "device_num";
  _odsPrinter << "(";
  if (::mlir::Value value = getDeviceNum())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getDeviceNum() ? ::llvm::ArrayRef<::mlir::Type>(getDeviceNum().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void SetOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::SetOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::ShutdownOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
ShutdownOpGenericAdaptorBase::ShutdownOpGenericAdaptorBase(ShutdownOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> ShutdownOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > ShutdownOpGenericAdaptorBase::getDeviceTypes() {
  auto attr = getDeviceTypesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

} // namespace detail
ShutdownOpAdaptor::ShutdownOpAdaptor(ShutdownOp op) : ShutdownOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult ShutdownOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_device_types = getProperties().device_types; (void)tblgen_device_types;

  if (tblgen_device_types && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_device_types))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_device_types), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.shutdown' op ""attribute 'device_types' failed to satisfy constraint: Device type attributes");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> ShutdownOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange ShutdownOp::getDeviceNumOperandMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange ShutdownOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult ShutdownOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.device_types;
       auto attr = dict.get("device_types");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `device_types` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute ShutdownOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.device_types;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("device_types",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code ShutdownOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.device_types.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> ShutdownOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "device_types")
      return prop.device_types;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void ShutdownOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "device_types") {
       prop.device_types = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.device_types)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void ShutdownOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.device_types) attrs.append("device_types", prop.device_types);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult ShutdownOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getDeviceTypesAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps10(attr, "device_types", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult ShutdownOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.device_types)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void ShutdownOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.device_types);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > ShutdownOp::getDeviceTypes() {
  auto attr = getDeviceTypesAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

void ShutdownOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::ArrayAttr device_types, /*optional*/::mlir::Value deviceNumOperand, /*optional*/::mlir::Value ifCond) {
  if (deviceNumOperand)
    odsState.addOperands(deviceNumOperand);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(deviceNumOperand ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (device_types) {
    odsState.getOrAddProperties<Properties>().device_types = device_types;
  }
}

void ShutdownOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::ArrayAttr device_types, /*optional*/::mlir::Value deviceNumOperand, /*optional*/::mlir::Value ifCond) {
  if (deviceNumOperand)
    odsState.addOperands(deviceNumOperand);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(deviceNumOperand ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (device_types) {
    odsState.getOrAddProperties<Properties>().device_types = device_types;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void ShutdownOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<ShutdownOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult ShutdownOp::verifyInvariantsImpl() {
  auto tblgen_device_types = getProperties().device_types; (void)tblgen_device_types;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps10(*this, tblgen_device_types, "device_types")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult ShutdownOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult ShutdownOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> deviceNumOperandOperands;
  ::llvm::SMLoc deviceNumOperandOperandsLoc;
  (void)deviceNumOperandOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> deviceNumOperandTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  bool device_numClause = false;
  bool ifClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("device_num"))) {

  if (device_numClause) {
    return parser.emitError(parser.getNameLoc())
          << "`device_num` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  device_numClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    deviceNumOperandOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      deviceNumOperandOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      deviceNumOperandTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(deviceNumOperandOperands.size()), static_cast<int32_t>(ifCondOperands.size())}), result.getOrAddProperties<ShutdownOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(deviceNumOperandOperands, deviceNumOperandTypes, deviceNumOperandOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void ShutdownOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getDeviceNumOperand()) {
  _odsPrinter << ' ' << "device_num";
  _odsPrinter << "(";
  if (::mlir::Value value = getDeviceNumOperand())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getDeviceNumOperand() ? ::llvm::ArrayRef<::mlir::Type>(getDeviceNumOperand().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::ShutdownOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::TerminatorOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
} // namespace detail
TerminatorOpAdaptor::TerminatorOpAdaptor(TerminatorOp op) : TerminatorOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult TerminatorOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

void TerminatorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
}

void TerminatorOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes) {
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void TerminatorOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() == 0u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult TerminatorOp::verifyInvariantsImpl() {
  return ::mlir::success();
}

::llvm::LogicalResult TerminatorOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult TerminatorOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void TerminatorOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void TerminatorOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::TerminatorOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::UpdateDeviceOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
UpdateDeviceOpGenericAdaptorBase::UpdateDeviceOpGenericAdaptorBase(UpdateDeviceOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> UpdateDeviceOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > UpdateDeviceOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateDeviceOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr UpdateDeviceOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause UpdateDeviceOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr UpdateDeviceOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool UpdateDeviceOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr UpdateDeviceOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool UpdateDeviceOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > UpdateDeviceOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
UpdateDeviceOpAdaptor::UpdateDeviceOpAdaptor(UpdateDeviceOp op) : UpdateDeviceOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UpdateDeviceOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.update_device' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.update_device' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.update_device' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.update_device' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.update_device' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.update_device' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UpdateDeviceOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange UpdateDeviceOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange UpdateDeviceOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange UpdateDeviceOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult UpdateDeviceOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute UpdateDeviceOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code UpdateDeviceOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> UpdateDeviceOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void UpdateDeviceOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void UpdateDeviceOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult UpdateDeviceOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult UpdateDeviceOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void UpdateDeviceOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > UpdateDeviceOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateDeviceOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause UpdateDeviceOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool UpdateDeviceOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool UpdateDeviceOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > UpdateDeviceOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void UpdateDeviceOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void UpdateDeviceOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void UpdateDeviceOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void UpdateDeviceOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void UpdateDeviceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void UpdateDeviceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UpdateDeviceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void UpdateDeviceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UpdateDeviceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<UpdateDeviceOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void UpdateDeviceOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_update_device);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult UpdateDeviceOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UpdateDeviceOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult UpdateDeviceOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<UpdateDeviceOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<UpdateDeviceOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UpdateDeviceOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_update_device)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void UpdateDeviceOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
  {
    auto valueRange = getODSResultIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Write::get(), getOperation()->getOpResult(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::UpdateDeviceOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::UpdateHostOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
UpdateHostOpGenericAdaptorBase::UpdateHostOpGenericAdaptorBase(UpdateHostOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> UpdateHostOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > UpdateHostOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateHostOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr UpdateHostOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause UpdateHostOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr UpdateHostOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool UpdateHostOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr UpdateHostOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool UpdateHostOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > UpdateHostOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
UpdateHostOpAdaptor::UpdateHostOpAdaptor(UpdateHostOp op) : UpdateHostOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UpdateHostOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.update_host' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.update_host' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.update_host' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.update_host' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.update_host' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.update_host' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UpdateHostOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange UpdateHostOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange UpdateHostOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult UpdateHostOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute UpdateHostOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code UpdateHostOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> UpdateHostOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void UpdateHostOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void UpdateHostOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult UpdateHostOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult UpdateHostOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void UpdateHostOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > UpdateHostOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateHostOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause UpdateHostOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool UpdateHostOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool UpdateHostOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > UpdateHostOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void UpdateHostOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void UpdateHostOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void UpdateHostOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void UpdateHostOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void UpdateHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(varPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
}

void UpdateHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(varPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UpdateHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(varPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
}

void UpdateHostOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value accPtr, ::mlir::Value varPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(accPtr);
  odsState.addOperands(varPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UpdateHostOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 2u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<UpdateHostOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void UpdateHostOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_update_host);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult UpdateHostOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UpdateHostOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult UpdateHostOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand accPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> accPtrOperands(&accPtrRawOperand, 1);  ::llvm::SMLoc accPtrOperandsLoc;
  (void)accPtrOperandsLoc;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  if (parser.parseKeyword("accPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  accPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(accPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  if (::mlir::succeeded(parser.parseOptionalKeyword("bounds"))) {
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (::mlir::succeeded(parser.parseOptionalKeyword("async"))) {
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<UpdateHostOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  if (parser.parseKeyword("to"))
    return ::mlir::failure();
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, 1, static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<UpdateHostOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  if (parser.resolveOperands(accPtrOperands, accPtrTypes, accPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UpdateHostOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "accPtr";
  _odsPrinter << "(";
  _odsPrinter << getAccPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (!getBounds().empty()) {
    _odsPrinter << ' ' << "bounds";
    _odsPrinter << "(";
    _odsPrinter << getBounds();
    _odsPrinter << ")";
  }
  if (((!getAsyncOperands().empty()) || (!getAsyncOperands().empty()) || (getAsyncOperandsDeviceTypeAttr()))) {
    _odsPrinter << ' ' << "async";
    _odsPrinter << "(";
    printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
    _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "to";
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_update_host)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void UpdateHostOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
  {
    auto valueRange = getODSOperandIndexAndLength(0);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Read::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
  {
    auto valueRange = getODSOperandIndexAndLength(1);
    for (unsigned idx = valueRange.first; idx < valueRange.first + valueRange.second; idx++) {
      effects.emplace_back(::mlir::MemoryEffects::Write::get(), &getOperation()->getOpOperand(idx), 0, false, ::mlir::SideEffects::DefaultResource::get());
    }
  }
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::UpdateHostOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::UpdateOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
UpdateOpGenericAdaptorBase::UpdateOpGenericAdaptorBase(UpdateOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> UpdateOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > UpdateOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateOpGenericAdaptorBase::getAsync() {
  auto attr = getAsyncAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> UpdateOpGenericAdaptorBase::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateOpGenericAdaptorBase::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateOpGenericAdaptorBase::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateOpGenericAdaptorBase::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::UnitAttr UpdateOpGenericAdaptorBase::getIfPresentAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().ifPresent);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool UpdateOpGenericAdaptorBase::getIfPresent() {
  auto attr = getIfPresentAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
UpdateOpAdaptor::UpdateOpAdaptor(UpdateOp op) : UpdateOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UpdateOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_async = getProperties().async; (void)tblgen_async;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_ifPresent = getProperties().ifPresent; (void)tblgen_ifPresent;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.update' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_async && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_async))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_async), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.update' op ""attribute 'async' failed to satisfy constraint: device type array attribute");

  if (tblgen_waitOperandsSegments && !((::llvm::isa<::mlir::DenseI32ArrayAttr>(tblgen_waitOperandsSegments))))
    return emitError(loc, "'acc.update' op ""attribute 'waitOperandsSegments' failed to satisfy constraint: i32 dense array attribute");

  if (tblgen_waitOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.update' op ""attribute 'waitOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_hasWaitDevnum && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_hasWaitDevnum))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_hasWaitDevnum), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::BoolAttr>(attr))); }))))
    return emitError(loc, "'acc.update' op ""attribute 'hasWaitDevnum' failed to satisfy constraint: 1-bit boolean array attribute");

  if (tblgen_waitOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_waitOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_waitOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.update' op ""attribute 'waitOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_ifPresent && !((::llvm::isa<::mlir::UnitAttr>(tblgen_ifPresent))))
    return emitError(loc, "'acc.update' op ""attribute 'ifPresent' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UpdateOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange UpdateOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange UpdateOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange UpdateOp::getWaitOperandsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange UpdateOp::getDataClauseOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult UpdateOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.async;
       auto attr = dict.get("async");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `async` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.hasWaitDevnum;
       auto attr = dict.get("hasWaitDevnum");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `hasWaitDevnum` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.ifPresent;
       auto attr = dict.get("ifPresent");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `ifPresent` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOnly;
       auto attr = dict.get("waitOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsDeviceType;
       auto attr = dict.get("waitOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.waitOperandsSegments;
       auto attr = dict.get("waitOperandsSegments");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `waitOperandsSegments` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute UpdateOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.async;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("async",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.hasWaitDevnum;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("hasWaitDevnum",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.ifPresent;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("ifPresent",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.waitOperandsSegments;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("waitOperandsSegments",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code UpdateOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.async.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.hasWaitDevnum.getAsOpaquePointer()), 
    llvm::hash_value(prop.ifPresent.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.waitOperandsSegments.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> UpdateOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "async")
      return prop.async;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "hasWaitDevnum")
      return prop.hasWaitDevnum;

    if (name == "ifPresent")
      return prop.ifPresent;

    if (name == "waitOnly")
      return prop.waitOnly;

    if (name == "waitOperandsDeviceType")
      return prop.waitOperandsDeviceType;

    if (name == "waitOperandsSegments")
      return prop.waitOperandsSegments;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void UpdateOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "async") {
       prop.async = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.async)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "hasWaitDevnum") {
       prop.hasWaitDevnum = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.hasWaitDevnum)>>(value);
       return;
    }

    if (name == "ifPresent") {
       prop.ifPresent = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.ifPresent)>>(value);
       return;
    }

    if (name == "waitOnly") {
       prop.waitOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOnly)>>(value);
       return;
    }

    if (name == "waitOperandsDeviceType") {
       prop.waitOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsDeviceType)>>(value);
       return;
    }

    if (name == "waitOperandsSegments") {
       prop.waitOperandsSegments = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.waitOperandsSegments)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void UpdateOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.async) attrs.append("async", prop.async);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.hasWaitDevnum) attrs.append("hasWaitDevnum", prop.hasWaitDevnum);

    if (prop.ifPresent) attrs.append("ifPresent", prop.ifPresent);

    if (prop.waitOnly) attrs.append("waitOnly", prop.waitOnly);

    if (prop.waitOperandsDeviceType) attrs.append("waitOperandsDeviceType", prop.waitOperandsDeviceType);

    if (prop.waitOperandsSegments) attrs.append("waitOperandsSegments", prop.waitOperandsSegments);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult UpdateOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "async", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getHasWaitDevnumAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(attr, "hasWaitDevnum", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getIfPresentAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "ifPresent", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "waitOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getWaitOperandsSegmentsAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(attr, "waitOperandsSegments", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult UpdateOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.async)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.hasWaitDevnum)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.ifPresent)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.waitOperandsSegments)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void UpdateOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.async);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.hasWaitDevnum);

  writer.writeOptionalAttribute(prop.ifPresent);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.waitOnly);

  writer.writeOptionalAttribute(prop.waitOperandsDeviceType);

  writer.writeOptionalAttribute(prop.waitOperandsSegments);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > UpdateOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateOp::getAsync() {
  auto attr = getAsyncAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional<::llvm::ArrayRef<int32_t>> UpdateOp::getWaitOperandsSegments() {
  auto attr = getWaitOperandsSegmentsAttr();
  return attr ? ::std::optional<::llvm::ArrayRef<int32_t>>(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateOp::getWaitOperandsDeviceType() {
  auto attr = getWaitOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateOp::getHasWaitDevnum() {
  auto attr = getHasWaitDevnumAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UpdateOp::getWaitOnly() {
  auto attr = getWaitOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

bool UpdateOp::getIfPresent() {
  auto attr = getIfPresentAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void UpdateOp::setWaitOperandsSegments(::std::optional<::llvm::ArrayRef<int32_t>> attrValue) {
    auto &odsProp = getProperties().waitOperandsSegments;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getDenseI32ArrayAttr(*attrValue);
    else
      odsProp = nullptr;
}

void UpdateOp::setIfPresent(bool attrValue) {
    auto &odsProp = getProperties().ifPresent;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void UpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr async, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr ifPresent) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (ifPresent) {
    odsState.getOrAddProperties<Properties>().ifPresent = ifPresent;
  }
}

void UpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr async, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/::mlir::UnitAttr ifPresent) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (ifPresent) {
    odsState.getOrAddProperties<Properties>().ifPresent = ifPresent;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr async, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/bool ifPresent) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (ifPresent) {
    odsState.getOrAddProperties<Properties>().ifPresent = ((ifPresent) ? odsBuilder.getUnitAttr() : nullptr);
  }
}

void UpdateOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, /*optional*/::mlir::Value ifCond, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr async, ::mlir::ValueRange waitOperands, /*optional*/::mlir::DenseI32ArrayAttr waitOperandsSegments, /*optional*/::mlir::ArrayAttr waitOperandsDeviceType, /*optional*/::mlir::ArrayAttr hasWaitDevnum, /*optional*/::mlir::ArrayAttr waitOnly, ::mlir::ValueRange dataClauseOperands, /*optional*/bool ifPresent) {
  if (ifCond)
    odsState.addOperands(ifCond);
  odsState.addOperands(asyncOperands);
  odsState.addOperands(waitOperands);
  odsState.addOperands(dataClauseOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({(ifCond ? 1 : 0), static_cast<int32_t>(asyncOperands.size()), static_cast<int32_t>(waitOperands.size()), static_cast<int32_t>(dataClauseOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
  if (waitOperandsSegments) {
    odsState.getOrAddProperties<Properties>().waitOperandsSegments = waitOperandsSegments;
  }
  if (waitOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().waitOperandsDeviceType = waitOperandsDeviceType;
  }
  if (hasWaitDevnum) {
    odsState.getOrAddProperties<Properties>().hasWaitDevnum = hasWaitDevnum;
  }
  if (waitOnly) {
    odsState.getOrAddProperties<Properties>().waitOnly = waitOnly;
  }
  if (ifPresent) {
    odsState.getOrAddProperties<Properties>().ifPresent = ((ifPresent) ? odsBuilder.getUnitAttr() : nullptr);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UpdateOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<UpdateOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult UpdateOp::verifyInvariantsImpl() {
  auto tblgen_async = getProperties().async; (void)tblgen_async;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_hasWaitDevnum = getProperties().hasWaitDevnum; (void)tblgen_hasWaitDevnum;
  auto tblgen_ifPresent = getProperties().ifPresent; (void)tblgen_ifPresent;
  auto tblgen_waitOnly = getProperties().waitOnly; (void)tblgen_waitOnly;
  auto tblgen_waitOperandsDeviceType = getProperties().waitOperandsDeviceType; (void)tblgen_waitOperandsDeviceType;
  auto tblgen_waitOperandsSegments = getProperties().waitOperandsSegments; (void)tblgen_waitOperandsSegments;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_async, "async")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps6(*this, tblgen_waitOperandsSegments, "waitOperandsSegments")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOperandsDeviceType, "waitOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps7(*this, tblgen_hasWaitDevnum, "hasWaitDevnum")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_waitOnly, "waitOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_ifPresent, "ifPresent")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    if (valueGroup0.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup0.size();
    }

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps9(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UpdateOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult UpdateOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::ArrayAttr asyncAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitOperandsOperands;
  ::llvm::SMLoc waitOperandsOperandsLoc;
  (void)waitOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitOperandsTypes;
  ::mlir::ArrayAttr waitOperandsDeviceTypeAttr;
  ::mlir::DenseI32ArrayAttr waitOperandsSegmentsAttr;
  ::mlir::ArrayAttr hasWaitDevnumAttr;
  ::mlir::ArrayAttr waitOnlyAttr;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> dataClauseOperandsOperands;
  ::llvm::SMLoc dataClauseOperandsOperandsLoc;
  (void)dataClauseOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> dataClauseOperandsTypes;
  bool ifClause = false;
  bool asyncClause = false;
  bool waitClause = false;
  bool dataOperandsClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperandsWithKeywordOnly(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr, asyncAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<UpdateOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
    if (asyncAttr)
      result.getOrAddProperties<UpdateOp::Properties>().async = asyncAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("wait"))) {

  if (waitClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  waitClause = true;
  {
    waitOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseWaitClause(parser, waitOperandsOperands, waitOperandsTypes, waitOperandsDeviceTypeAttr, waitOperandsSegmentsAttr, hasWaitDevnumAttr, waitOnlyAttr);
    if (odsResult) return ::mlir::failure();
    if (waitOperandsDeviceTypeAttr)
      result.getOrAddProperties<UpdateOp::Properties>().waitOperandsDeviceType = waitOperandsDeviceTypeAttr;
    if (waitOperandsSegmentsAttr)
      result.getOrAddProperties<UpdateOp::Properties>().waitOperandsSegments = waitOperandsSegmentsAttr;
    if (hasWaitDevnumAttr)
      result.getOrAddProperties<UpdateOp::Properties>().hasWaitDevnum = hasWaitDevnumAttr;
    if (waitOnlyAttr)
      result.getOrAddProperties<UpdateOp::Properties>().waitOnly = waitOnlyAttr;
  }
    } else if (succeeded(parser.parseOptionalKeyword("dataOperands"))) {

  if (dataOperandsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`dataOperands` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  dataOperandsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  dataClauseOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(dataClauseOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(dataClauseOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(ifCondOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size()), static_cast<int32_t>(waitOperandsOperands.size()), static_cast<int32_t>(dataClauseOperandsOperands.size())}), result.getOrAddProperties<UpdateOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitOperandsOperands, waitOperandsTypes, waitOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(dataClauseOperandsOperands, dataClauseOperandsTypes, dataClauseOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UpdateOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr()) || (getAsyncAttr())) {
  _odsPrinter << ' ' << "async";
  printDeviceTypeOperandsWithKeywordOnly(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr(), getAsyncAttr());
  }
  if (false || getWaitOperands().size() || (getWaitOperandsDeviceTypeAttr()) || (getWaitOperandsSegmentsAttr()) || (getHasWaitDevnumAttr()) || (getWaitOnlyAttr())) {
  _odsPrinter << ' ' << "wait";
  printWaitClause(_odsPrinter, *this, getWaitOperands(), getWaitOperands().getTypes(), getWaitOperandsDeviceTypeAttr(), getWaitOperandsSegmentsAttr(), getHasWaitDevnumAttr(), getWaitOnlyAttr());
  }
  if (false || getDataClauseOperands().size()) {
  _odsPrinter << ' ' << "dataOperands";
  _odsPrinter << "(";
  _odsPrinter << getDataClauseOperands();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << getDataClauseOperands().getTypes();
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  elidedAttrs.push_back("async");
  elidedAttrs.push_back("waitOperandsDeviceType");
  elidedAttrs.push_back("waitOperandsSegments");
  elidedAttrs.push_back("hasWaitDevnum");
  elidedAttrs.push_back("waitOnly");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getIfPresentAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("ifPresent");
  }
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

void UpdateOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Write::get(), 0, false, ::mlir::acc::ConstructResource::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::UpdateOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::UseDeviceOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
UseDeviceOpGenericAdaptorBase::UseDeviceOpGenericAdaptorBase(UseDeviceOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> UseDeviceOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::std::optional< ::mlir::ArrayAttr > UseDeviceOpGenericAdaptorBase::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UseDeviceOpGenericAdaptorBase::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClauseAttr UseDeviceOpGenericAdaptorBase::getDataClauseAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::acc::DataClauseAttr>(getProperties().dataClause);
  return attr;
}

::mlir::acc::DataClause UseDeviceOpGenericAdaptorBase::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

::mlir::BoolAttr UseDeviceOpGenericAdaptorBase::getStructuredAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().structured);
  return attr;
}

bool UseDeviceOpGenericAdaptorBase::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

::mlir::BoolAttr UseDeviceOpGenericAdaptorBase::getImplicitAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::BoolAttr>(getProperties().implicit);
  return attr;
}

bool UseDeviceOpGenericAdaptorBase::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > UseDeviceOpGenericAdaptorBase::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

} // namespace detail
UseDeviceOpAdaptor::UseDeviceOpAdaptor(UseDeviceOp op) : UseDeviceOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult UseDeviceOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (tblgen_asyncOperandsDeviceType && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOperandsDeviceType), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.use_device' op ""attribute 'asyncOperandsDeviceType' failed to satisfy constraint: device type array attribute");

  if (tblgen_asyncOnly && !(((::llvm::isa<::mlir::ArrayAttr>(tblgen_asyncOnly))) && (::llvm::all_of(::llvm::cast<::mlir::ArrayAttr>(tblgen_asyncOnly), [&](::mlir::Attribute attr) { return attr && ((::llvm::isa<::mlir::acc::DeviceTypeAttr>(attr))); }))))
    return emitError(loc, "'acc.use_device' op ""attribute 'asyncOnly' failed to satisfy constraint: device type array attribute");

  if (tblgen_dataClause && !((::llvm::isa<::mlir::acc::DataClauseAttr>(tblgen_dataClause))))
    return emitError(loc, "'acc.use_device' op ""attribute 'dataClause' failed to satisfy constraint: data clauses supported by OpenACC");

  if (tblgen_structured && !((::llvm::isa<::mlir::BoolAttr>(tblgen_structured))))
    return emitError(loc, "'acc.use_device' op ""attribute 'structured' failed to satisfy constraint: bool attribute");

  if (tblgen_implicit && !((::llvm::isa<::mlir::BoolAttr>(tblgen_implicit))))
    return emitError(loc, "'acc.use_device' op ""attribute 'implicit' failed to satisfy constraint: bool attribute");

  if (tblgen_name && !((::llvm::isa<::mlir::StringAttr>(tblgen_name))))
    return emitError(loc, "'acc.use_device' op ""attribute 'name' failed to satisfy constraint: string attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> UseDeviceOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange UseDeviceOp::getVarPtrPtrMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange UseDeviceOp::getBoundsMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange UseDeviceOp::getAsyncOperandsMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult UseDeviceOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.asyncOnly;
       auto attr = dict.get("asyncOnly");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOnly` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.asyncOperandsDeviceType;
       auto attr = dict.get("asyncOperandsDeviceType");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `asyncOperandsDeviceType` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.dataClause;
       auto attr = dict.get("dataClause");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `dataClause` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.implicit;
       auto attr = dict.get("implicit");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `implicit` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.name;
       auto attr = dict.get("name");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `name` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }

  {
    auto &propStorage = prop.structured;
       auto attr = dict.get("structured");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `structured` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute UseDeviceOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.asyncOnly;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOnly",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.asyncOperandsDeviceType;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("asyncOperandsDeviceType",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.dataClause;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("dataClause",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.implicit;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("implicit",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.name;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("name",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.structured;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("structured",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code UseDeviceOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.asyncOnly.getAsOpaquePointer()), 
    llvm::hash_value(prop.asyncOperandsDeviceType.getAsOpaquePointer()), 
    llvm::hash_value(prop.dataClause.getAsOpaquePointer()), 
    llvm::hash_value(prop.implicit.getAsOpaquePointer()), 
    llvm::hash_value(prop.name.getAsOpaquePointer()), 
    llvm::hash_value(prop.structured.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> UseDeviceOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "asyncOnly")
      return prop.asyncOnly;

    if (name == "asyncOperandsDeviceType")
      return prop.asyncOperandsDeviceType;

    if (name == "dataClause")
      return prop.dataClause;

    if (name == "implicit")
      return prop.implicit;

    if (name == "name")
      return prop.name;

    if (name == "structured")
      return prop.structured;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void UseDeviceOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "asyncOnly") {
       prop.asyncOnly = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOnly)>>(value);
       return;
    }

    if (name == "asyncOperandsDeviceType") {
       prop.asyncOperandsDeviceType = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.asyncOperandsDeviceType)>>(value);
       return;
    }

    if (name == "dataClause") {
       prop.dataClause = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.dataClause)>>(value);
       return;
    }

    if (name == "implicit") {
       prop.implicit = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.implicit)>>(value);
       return;
    }

    if (name == "name") {
       prop.name = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.name)>>(value);
       return;
    }

    if (name == "structured") {
       prop.structured = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.structured)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void UseDeviceOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.asyncOnly) attrs.append("asyncOnly", prop.asyncOnly);

    if (prop.asyncOperandsDeviceType) attrs.append("asyncOperandsDeviceType", prop.asyncOperandsDeviceType);

    if (prop.dataClause) attrs.append("dataClause", prop.dataClause);

    if (prop.implicit) attrs.append("implicit", prop.implicit);

    if (prop.name) attrs.append("name", prop.name);

    if (prop.structured) attrs.append("structured", prop.structured);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult UseDeviceOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncOnlyAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOnly", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getAsyncOperandsDeviceTypeAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(attr, "asyncOperandsDeviceType", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getDataClauseAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(attr, "dataClause", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getImplicitAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "implicit", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getNameAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(attr, "name", emitError)))
        return ::mlir::failure();
    }

    {
      ::mlir::Attribute attr = attrs.get(getStructuredAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(attr, "structured", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult UseDeviceOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOnly)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.asyncOperandsDeviceType)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.dataClause)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.implicit)))
    return ::mlir::failure();

  if (::mlir::failed(reader.readOptionalAttribute(prop.name)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  if (::mlir::failed(reader.readOptionalAttribute(prop.structured)))
    return ::mlir::failure();

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void UseDeviceOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.asyncOnly);

  writer.writeOptionalAttribute(prop.asyncOperandsDeviceType);

  writer.writeOptionalAttribute(prop.dataClause);

  writer.writeOptionalAttribute(prop.implicit);

  writer.writeOptionalAttribute(prop.name);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  writer.writeOptionalAttribute(prop.structured);

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

::std::optional< ::mlir::ArrayAttr > UseDeviceOp::getAsyncOperandsDeviceType() {
  auto attr = getAsyncOperandsDeviceTypeAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::std::optional< ::mlir::ArrayAttr > UseDeviceOp::getAsyncOnly() {
  auto attr = getAsyncOnlyAttr();
  return attr ? ::std::optional< ::mlir::ArrayAttr >(attr) : (::std::nullopt);
}

::mlir::acc::DataClause UseDeviceOp::getDataClause() {
  auto attr = getDataClauseAttr();
  return attr.getValue();
}

bool UseDeviceOp::getStructured() {
  auto attr = getStructuredAttr();
  return attr.getValue();
}

bool UseDeviceOp::getImplicit() {
  auto attr = getImplicitAttr();
  return attr.getValue();
}

::std::optional< ::llvm::StringRef > UseDeviceOp::getName() {
  auto attr = getNameAttr();
  return attr ? ::std::optional< ::llvm::StringRef >(attr.getValue()) : (::std::nullopt);
}

void UseDeviceOp::setDataClause(::mlir::acc::DataClause attrValue) {
  getProperties().dataClause = ::mlir::acc::DataClauseAttr::get(::mlir::Builder((*this)->getContext()).getContext(), attrValue);
}

void UseDeviceOp::setStructured(bool attrValue) {
  getProperties().structured = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void UseDeviceOp::setImplicit(bool attrValue) {
  getProperties().implicit = ::mlir::Builder((*this)->getContext()).getBoolAttr(attrValue);
}

void UseDeviceOp::setName(::std::optional<::llvm::StringRef> attrValue) {
    auto &odsProp = getProperties().name;
    if (attrValue)
      odsProp = ::mlir::Builder((*this)->getContext()).getStringAttr(*attrValue);
    else
      odsProp = nullptr;
}

void UseDeviceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void UseDeviceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClauseAttr dataClause, ::mlir::BoolAttr structured, ::mlir::BoolAttr implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  if (dataClause) {
    odsState.getOrAddProperties<Properties>().dataClause = dataClause;
  }
  if (structured) {
    odsState.getOrAddProperties<Properties>().structured = structured;
  }
  if (implicit) {
    odsState.getOrAddProperties<Properties>().implicit = implicit;
  }
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UseDeviceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type accPtr, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  odsState.addTypes(accPtr);
}

void UseDeviceOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value varPtr, /*optional*/::mlir::Value varPtrPtr, ::mlir::ValueRange bounds, ::mlir::ValueRange asyncOperands, /*optional*/::mlir::ArrayAttr asyncOperandsDeviceType, /*optional*/::mlir::ArrayAttr asyncOnly, ::mlir::acc::DataClause dataClause, bool structured, bool implicit, /*optional*/::mlir::StringAttr name) {
  odsState.addOperands(varPtr);
  if (varPtrPtr)
    odsState.addOperands(varPtrPtr);
  odsState.addOperands(bounds);
  odsState.addOperands(asyncOperands);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({1, (varPtrPtr ? 1 : 0), static_cast<int32_t>(bounds.size()), static_cast<int32_t>(asyncOperands.size())}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (asyncOperandsDeviceType) {
    odsState.getOrAddProperties<Properties>().asyncOperandsDeviceType = asyncOperandsDeviceType;
  }
  if (asyncOnly) {
    odsState.getOrAddProperties<Properties>().asyncOnly = asyncOnly;
  }
  odsState.getOrAddProperties<Properties>().dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), dataClause);
  odsState.getOrAddProperties<Properties>().structured = odsBuilder.getBoolAttr(structured);
  odsState.getOrAddProperties<Properties>().implicit = odsBuilder.getBoolAttr(implicit);
  if (name) {
    odsState.getOrAddProperties<Properties>().name = name;
  }
  assert(resultTypes.size() == 1u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void UseDeviceOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  assert(operands.size() >= 1u && "mismatched number of parameters");
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 1u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<UseDeviceOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

void UseDeviceOp::populateDefaultProperties(::mlir::OperationName opName, Properties &properties) {
  ::mlir::Builder odsBuilder(opName.getContext());
  if (!properties.dataClause)
    properties.dataClause = ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_use_device);
  if (!properties.structured)
    properties.structured = odsBuilder.getBoolAttr(true);
  if (!properties.implicit)
    properties.implicit = odsBuilder.getBoolAttr(false);
}

::llvm::LogicalResult UseDeviceOp::verifyInvariantsImpl() {
  auto tblgen_asyncOnly = getProperties().asyncOnly; (void)tblgen_asyncOnly;
  auto tblgen_asyncOperandsDeviceType = getProperties().asyncOperandsDeviceType; (void)tblgen_asyncOperandsDeviceType;
  auto tblgen_dataClause = getProperties().dataClause; (void)tblgen_dataClause;
  auto tblgen_implicit = getProperties().implicit; (void)tblgen_implicit;
  auto tblgen_name = getProperties().name; (void)tblgen_name;
  auto tblgen_structured = getProperties().structured; (void)tblgen_structured;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOperandsDeviceType, "asyncOperandsDeviceType")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps2(*this, tblgen_asyncOnly, "asyncOnly")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps3(*this, tblgen_dataClause, "dataClause")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_structured, "structured")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps4(*this, tblgen_implicit, "implicit")))
    return ::mlir::failure();

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps5(*this, tblgen_name, "name")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps4(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSResults(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps3(*this, v.getType(), "result", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult UseDeviceOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult UseDeviceOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::mlir::OpAsmParser::UnresolvedOperand varPtrRawOperand{};
  ::llvm::ArrayRef<::mlir::OpAsmParser::UnresolvedOperand> varPtrOperands(&varPtrRawOperand, 1);  ::llvm::SMLoc varPtrOperandsLoc;
  (void)varPtrOperandsLoc;
  ::mlir::Type varPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> varPtrTypes(&varPtrRawType, 1);
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> varPtrPtrOperands;
  ::llvm::SMLoc varPtrPtrOperandsLoc;
  (void)varPtrPtrOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> varPtrPtrTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> boundsOperands;
  ::llvm::SMLoc boundsOperandsLoc;
  (void)boundsOperandsLoc;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandsOperands;
  ::llvm::SMLoc asyncOperandsOperandsLoc;
  (void)asyncOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandsTypes;
  ::mlir::ArrayAttr asyncOperandsDeviceTypeAttr;
  ::mlir::Type accPtrRawType{};
  ::llvm::ArrayRef<::mlir::Type> accPtrTypes(&accPtrRawType, 1);
  if (parser.parseKeyword("varPtr"))
    return ::mlir::failure();
  if (parser.parseLParen())
    return ::mlir::failure();

  varPtrOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperand(varPtrRawOperand))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    varPtrRawType = type;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
  bool varPtrPtrClause = false;
  bool boundsClause = false;
  bool asyncClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("varPtrPtr"))) {

  if (varPtrPtrClause) {
    return parser.emitError(parser.getNameLoc())
          << "`varPtrPtr` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  varPtrPtrClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    varPtrPtrOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      varPtrPtrTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("bounds"))) {

  if (boundsClause) {
    return parser.emitError(parser.getNameLoc())
          << "`bounds` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  boundsClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  boundsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(boundsOperands))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();
  {
    asyncOperandsOperandsLoc = parser.getCurrentLocation();
    auto odsResult = parseDeviceTypeOperands(parser, asyncOperandsOperands, asyncOperandsTypes, asyncOperandsDeviceTypeAttr);
    if (odsResult) return ::mlir::failure();
    if (asyncOperandsDeviceTypeAttr)
      result.getOrAddProperties<UseDeviceOp::Properties>().asyncOperandsDeviceType = asyncOperandsDeviceTypeAttr;
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  if (parser.parseArrow())
    return ::mlir::failure();

  {
    ::mlir::acc::PointerLikeType type;
    if (parser.parseCustomTypeWithFallback(type))
      return ::mlir::failure();
    accPtrRawType = type;
  }
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({1, static_cast<int32_t>(varPtrPtrOperands.size()), static_cast<int32_t>(boundsOperands.size()), static_cast<int32_t>(asyncOperandsOperands.size())}), result.getOrAddProperties<UseDeviceOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getType<::mlir::acc::DataBoundsType>();
  result.addTypes(accPtrTypes);
  if (parser.resolveOperands(varPtrOperands, varPtrTypes, varPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(varPtrPtrOperands, varPtrPtrTypes, varPtrPtrOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(boundsOperands, odsBuildableType0, boundsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandsOperands, asyncOperandsTypes, asyncOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void UseDeviceOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  _odsPrinter << ' ' << "varPtr";
  _odsPrinter << "(";
  _odsPrinter << getVarPtr();
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  {
    auto type = getVarPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  _odsPrinter << ")";
  if (false || getVarPtrPtr()) {
  _odsPrinter << ' ' << "varPtrPtr";
  _odsPrinter << "(";
  if (::mlir::Value value = getVarPtrPtr())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getVarPtrPtr() ? ::llvm::ArrayRef<::mlir::Type>(getVarPtrPtr().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getBounds().size()) {
  _odsPrinter << ' ' << "bounds";
  _odsPrinter << "(";
  _odsPrinter << getBounds();
  _odsPrinter << ")";
  }
  if (false || getAsyncOperands().size() || (getAsyncOperandsDeviceTypeAttr())) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  printDeviceTypeOperands(_odsPrinter, *this, getAsyncOperands(), getAsyncOperands().getTypes(), getAsyncOperandsDeviceTypeAttr());
  _odsPrinter << ")";
  }
  _odsPrinter << ' ' << "->";
  _odsPrinter << ' ';
  {
    auto type = getAccPtr().getType();
    if (auto validType = ::llvm::dyn_cast<::mlir::acc::PointerLikeType>(type))
      _odsPrinter.printStrippedAttrOrType(validType);
   else
     _odsPrinter << type;
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  elidedAttrs.push_back("asyncOperandsDeviceType");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getDataClauseAttr();
     if(attr && (attr == ::mlir::acc::DataClauseAttr::get(odsBuilder.getContext(), mlir::acc::DataClause::acc_use_device)))
       elidedAttrs.push_back("dataClause");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getStructuredAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(true)))
       elidedAttrs.push_back("structured");
  }
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getImplicitAttr();
     if(attr && (attr == odsBuilder.getBoolAttr(false)))
       elidedAttrs.push_back("implicit");
  }
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
}

void UseDeviceOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::RuntimeCounters::get());
  effects.emplace_back(::mlir::MemoryEffects::Read::get(), 0, false, ::mlir::acc::CurrentDeviceIdResource::get());
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::UseDeviceOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::WaitOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
WaitOpGenericAdaptorBase::WaitOpGenericAdaptorBase(WaitOp op) : odsAttrs(op->getRawDictionaryAttrs()), odsOpName(op->getName()), properties(op.getProperties()), odsRegions(op->getRegions()) {}

std::pair<unsigned, unsigned> WaitOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::UnitAttr WaitOpGenericAdaptorBase::getAsyncAttr() {
  auto attr = ::llvm::dyn_cast_or_null<::mlir::UnitAttr>(getProperties().async);
  if (!attr)
    attr = ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr);
  return attr;
}

bool WaitOpGenericAdaptorBase::getAsync() {
  auto attr = getAsyncAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder(odsAttrs.getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

} // namespace detail
WaitOpAdaptor::WaitOpAdaptor(WaitOp op) : WaitOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult WaitOpAdaptor::verify(::mlir::Location loc) {
  auto tblgen_async = getProperties().async; (void)tblgen_async;

  if (tblgen_async && !((::llvm::isa<::mlir::UnitAttr>(tblgen_async))))
    return emitError(loc, "'acc.wait' op ""attribute 'async' failed to satisfy constraint: unit attribute");
  return ::mlir::success();
}

std::pair<unsigned, unsigned> WaitOp::getODSOperandIndexAndLength(unsigned index) {
  ::llvm::ArrayRef<int32_t> sizeAttr = getProperties().operandSegmentSizes;

  unsigned start = 0;
  for (unsigned i = 0; i < index; ++i)
    start += sizeAttr[i];
  return {start, sizeAttr[index]};
}

::mlir::MutableOperandRange WaitOp::getWaitOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(0u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange WaitOp::getAsyncOperandMutable() {
  auto range = getODSOperandIndexAndLength(1);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(1u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange WaitOp::getWaitDevnumMutable() {
  auto range = getODSOperandIndexAndLength(2);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(2u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::mlir::MutableOperandRange WaitOp::getIfCondMutable() {
  auto range = getODSOperandIndexAndLength(3);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second, ::mlir::MutableOperandRange::OperandSegment(3u, {getOperandSegmentSizesAttrName(), ::mlir::DenseI32ArrayAttr::get(getContext(), getProperties().operandSegmentSizes)}));
  return mutableRange;
}

::llvm::LogicalResult WaitOp::setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
  ::mlir::DictionaryAttr dict = ::llvm::dyn_cast<::mlir::DictionaryAttr>(attr);
  if (!dict) {
    emitError() << "expected DictionaryAttr to set properties";
    return ::mlir::failure();
  }

  {
    auto &propStorage = prop.async;
       auto attr = dict.get("async");
    if (attr) {
      auto convertedAttr = ::llvm::dyn_cast<std::remove_reference_t<decltype(propStorage)>>(attr);
      if (convertedAttr) {
        propStorage = convertedAttr;
      } else {
        emitError() << "Invalid attribute `async` in property conversion: " << attr;
        return ::mlir::failure();
      }
    }
  }
{

      auto setFromAttr = [] (auto &propStorage, ::mlir::Attribute propAttr,
               ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) -> ::mlir::LogicalResult {
        return convertFromAttribute(propStorage, propAttr, emitError);
      };
         auto attr = dict.get("operandSegmentSizes");   if (!attr) attr = dict.get("operand_segment_sizes");;
;
      if (attr && ::mlir::failed(setFromAttr(prop.operandSegmentSizes, attr, emitError)))
        return ::mlir::failure();
  }
  return ::mlir::success();
}

::mlir::Attribute WaitOp::getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop) {
    ::mlir::SmallVector<::mlir::NamedAttribute> attrs;
    ::mlir::Builder odsBuilder{ctx};

    {
      const auto &propStorage = prop.async;
      if (propStorage)
        attrs.push_back(odsBuilder.getNamedAttr("async",
                                       propStorage));
    }

    {
      const auto &propStorage = prop.operandSegmentSizes;
      auto attr = [&]() -> ::mlir::Attribute {
        return ::mlir::DenseI32ArrayAttr::get(ctx, propStorage);
      }();
      attrs.push_back(odsBuilder.getNamedAttr("operandSegmentSizes", attr));
    }

  if (!attrs.empty())
    return odsBuilder.getDictionaryAttr(attrs);
  return {};
}

llvm::hash_code WaitOp::computePropertiesHash(const Properties &prop) {
  auto hash_operandSegmentSizes = [] (const auto &propStorage) -> llvm::hash_code {
    return ::llvm::hash_combine_range(std::begin(propStorage), std::end(propStorage));;
  };
  return llvm::hash_combine(
    llvm::hash_value(prop.async.getAsOpaquePointer()), 
    hash_operandSegmentSizes(prop.operandSegmentSizes));
}

std::optional<mlir::Attribute> WaitOp::getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name) {
    if (name == "async")
      return prop.async;
    if (name == "operand_segment_sizes" || name == "operandSegmentSizes") return [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }();
  return std::nullopt;
}

void WaitOp::setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value) {
    if (name == "async") {
       prop.async = ::llvm::dyn_cast_or_null<std::remove_reference_t<decltype(prop.async)>>(value);
       return;
    }
        if (name == "operand_segment_sizes" || name == "operandSegmentSizes") {
       auto arrAttr = ::llvm::dyn_cast_or_null<::mlir::DenseI32ArrayAttr>(value);
       if (!arrAttr) return;
       if (arrAttr.size() != sizeof(prop.operandSegmentSizes) / sizeof(int32_t))
         return;
       llvm::copy(arrAttr.asArrayRef(), prop.operandSegmentSizes.begin());
       return;
    }
}

void WaitOp::populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs) {
    if (prop.async) attrs.append("async", prop.async);
  attrs.append("operandSegmentSizes", [&]() -> ::mlir::Attribute { return ::mlir::DenseI32ArrayAttr::get(ctx, prop.operandSegmentSizes); }());
}

::llvm::LogicalResult WaitOp::verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError) {
    {
      ::mlir::Attribute attr = attrs.get(getAsyncAttrName(opName));
      if (attr && ::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(attr, "async", emitError)))
        return ::mlir::failure();
    }
    return ::mlir::success();
}

::llvm::LogicalResult WaitOp::readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state) {
  auto &prop = state.getOrAddProperties<Properties>(); (void)prop;
  if (::mlir::failed(reader.readOptionalAttribute(prop.async)))
    return ::mlir::failure();

  if (reader.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
    auto &propStorage = prop.operandSegmentSizes;
    ::mlir::DenseI32ArrayAttr attr;
    if (::mlir::failed(reader.readAttribute(attr))) return ::mlir::failure();
    if (attr.size() > static_cast<int64_t>(sizeof(propStorage) / sizeof(int32_t))) {
      reader.emitError("size mismatch for operand/result_segment_size");
      return ::mlir::failure();
    }
    ::llvm::copy(::llvm::ArrayRef<int32_t>(attr), propStorage.begin());
  }

  {
    auto &propStorage = prop.operandSegmentSizes;
    auto readProp = [&]() {

  if (reader.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    return reader.readSparseArray(::llvm::MutableArrayRef(propStorage));
;
      return ::mlir::success();
    };
    if (::mlir::failed(readProp()))
      return ::mlir::failure();
  }
  return ::mlir::success();
}

void WaitOp::writeProperties(::mlir::DialectBytecodeWriter &writer) {
  auto &prop = getProperties(); (void)prop;

  writer.writeOptionalAttribute(prop.async);

if (writer.getBytecodeVersion() < /*kNativePropertiesODSSegmentSize=*/6) {
  auto &propStorage = prop.operandSegmentSizes;
  writer.writeAttribute(::mlir::DenseI32ArrayAttr::get(this->getContext(), propStorage));
}

  {
    auto &propStorage = prop.operandSegmentSizes;

  if (writer.getBytecodeVersion() >= /*kNativePropertiesODSSegmentSize=*/6)
    writer.writeSparseArray(::llvm::ArrayRef(propStorage));
;
  }
}

bool WaitOp::getAsync() {
  auto attr = getAsyncAttr();
    if (!attr)
      return ((false) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr) != nullptr;
  return attr != nullptr;
}

void WaitOp::setAsync(bool attrValue) {
    auto &odsProp = getProperties().async;
    if (attrValue)
      odsProp = ((attrValue) ? ::mlir::Builder((*this)->getContext()).getUnitAttr() : nullptr);
    else
      odsProp = nullptr;
}

void WaitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange waitOperands, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::Value waitDevnum, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value ifCond) {
  odsState.addOperands(waitOperands);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(waitOperands.size()), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
}

void WaitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange waitOperands, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::Value waitDevnum, /*optional*/::mlir::UnitAttr async, /*optional*/::mlir::Value ifCond) {
  odsState.addOperands(waitOperands);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(waitOperands.size()), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = async;
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WaitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange waitOperands, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::Value waitDevnum, /*optional*/bool async, /*optional*/::mlir::Value ifCond) {
  odsState.addOperands(waitOperands);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(waitOperands.size()), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = ((async) ? odsBuilder.getUnitAttr() : nullptr);
  }
}

void WaitOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange waitOperands, /*optional*/::mlir::Value asyncOperand, /*optional*/::mlir::Value waitDevnum, /*optional*/bool async, /*optional*/::mlir::Value ifCond) {
  odsState.addOperands(waitOperands);
  if (asyncOperand)
    odsState.addOperands(asyncOperand);
  if (waitDevnum)
    odsState.addOperands(waitDevnum);
  if (ifCond)
    odsState.addOperands(ifCond);
  ::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(waitOperands.size()), (asyncOperand ? 1 : 0), (waitDevnum ? 1 : 0), (ifCond ? 1 : 0)}), odsState.getOrAddProperties<Properties>().operandSegmentSizes.begin());
  if (async) {
    odsState.getOrAddProperties<Properties>().async = ((async) ? odsBuilder.getUnitAttr() : nullptr);
  }
  assert(resultTypes.size() == 0u && "mismatched number of results");
  odsState.addTypes(resultTypes);
}

void WaitOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);

  if (!attributes.empty()) {
    ::mlir::OpaqueProperties properties =
      &odsState.getOrAddProperties<WaitOp::Properties>();
    std::optional<::mlir::RegisteredOperationName> info =
      odsState.name.getRegisteredInfo();
    if (failed(info->setOpPropertiesFromAttribute(odsState.name, properties,
        odsState.attributes.getDictionary(odsState.getContext()), nullptr)))
      ::llvm::report_fatal_error("Property conversion failed.");
  }
}

::llvm::LogicalResult WaitOp::verifyInvariantsImpl() {
  auto tblgen_async = getProperties().async; (void)tblgen_async;

  if (::mlir::failed(__mlir_ods_local_attr_constraint_OpenACCOps9(*this, tblgen_async, "async")))
    return ::mlir::failure();
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps5(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup1 = getODSOperands(1);

    if (valueGroup1.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup1.size();
    }

    for (auto v : valueGroup1) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup2 = getODSOperands(2);

    if (valueGroup2.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup2.size();
    }

    for (auto v : valueGroup2) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps6(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
    auto valueGroup3 = getODSOperands(3);

    if (valueGroup3.size() > 1) {
      return emitOpError("operand group starting at #") << index
          << " requires 0 or 1 element, but found " << valueGroup3.size();
    }

    for (auto v : valueGroup3) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps8(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult WaitOp::verifyInvariants() {
  if(::mlir::succeeded(verifyInvariantsImpl()) && ::mlir::succeeded(verify()))
    return ::mlir::success();
  return ::mlir::failure();
}

::mlir::ParseResult WaitOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitOperandsOperands;
  ::llvm::SMLoc waitOperandsOperandsLoc;
  (void)waitOperandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitOperandsTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> asyncOperandOperands;
  ::llvm::SMLoc asyncOperandOperandsLoc;
  (void)asyncOperandOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> asyncOperandTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> waitDevnumOperands;
  ::llvm::SMLoc waitDevnumOperandsLoc;
  (void)waitDevnumOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> waitDevnumTypes;
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> ifCondOperands;
  ::llvm::SMLoc ifCondOperandsLoc;
  (void)ifCondOperandsLoc;
  if (::mlir::succeeded(parser.parseOptionalLParen())) {

  waitOperandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(waitOperandsOperands))
    return ::mlir::failure();
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(waitOperandsTypes))
    return ::mlir::failure();
  if (parser.parseRParen())
    return ::mlir::failure();
  }
  bool asyncClause = false;
  bool wait_devnumClause = false;
  bool ifClause = false;
  while(true) {
if (succeeded(parser.parseOptionalKeyword("async"))) {

  if (asyncClause) {
    return parser.emitError(parser.getNameLoc())
          << "`async` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  asyncClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    asyncOperandOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      asyncOperandOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      asyncOperandTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("wait_devnum"))) {

  if (wait_devnumClause) {
    return parser.emitError(parser.getNameLoc())
          << "`wait_devnum` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  wait_devnumClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    waitDevnumOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      waitDevnumOperands.push_back(operand);
    }
  }
  if (parser.parseColon())
    return ::mlir::failure();

  {
    ::mlir::Type optionalType;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalType(optionalType);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      waitDevnumTypes.push_back(optionalType);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else if (succeeded(parser.parseOptionalKeyword("if"))) {

  if (ifClause) {
    return parser.emitError(parser.getNameLoc())
          << "`if` clause can appear at most once in the expansion of the "
             "oilist directive";
  }
  ifClause = true;
  if (parser.parseLParen())
    return ::mlir::failure();

  {
    ifCondOperandsLoc = parser.getCurrentLocation();
    ::mlir::OpAsmParser::UnresolvedOperand operand;
    ::mlir::OptionalParseResult parseResult =
                                    parser.parseOptionalOperand(operand);
    if (parseResult.has_value()) {
      if (failed(*parseResult))
        return ::mlir::failure();
      ifCondOperands.push_back(operand);
    }
  }
  if (parser.parseRParen())
    return ::mlir::failure();
    } else  {
    break;
  }
}
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDictWithKeyword(result.attributes))
      return ::mlir::failure();
    if (failed(verifyInherentAttrs(result.name, result.attributes, [&]() {
        return parser.emitError(loc) << "'" << result.name.getStringRef() << "' op ";
      })))
      return ::mlir::failure();
  }
::llvm::copy(::llvm::ArrayRef<int32_t>({static_cast<int32_t>(waitOperandsOperands.size()), static_cast<int32_t>(asyncOperandOperands.size()), static_cast<int32_t>(waitDevnumOperands.size()), static_cast<int32_t>(ifCondOperands.size())}), result.getOrAddProperties<WaitOp::Properties>().operandSegmentSizes.begin());
  ::mlir::Type odsBuildableType0 = parser.getBuilder().getIntegerType(1);
  if (parser.resolveOperands(waitOperandsOperands, waitOperandsTypes, waitOperandsOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(asyncOperandOperands, asyncOperandTypes, asyncOperandOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(waitDevnumOperands, waitDevnumTypes, waitDevnumOperandsLoc, result.operands))
    return ::mlir::failure();
  if (parser.resolveOperands(ifCondOperands, odsBuildableType0, ifCondOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void WaitOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  if (!getWaitOperands().empty()) {
    _odsPrinter << "(";
    _odsPrinter << getWaitOperands();
    _odsPrinter << ' ' << ":";
    _odsPrinter << ' ';
    _odsPrinter << getWaitOperands().getTypes();
    _odsPrinter << ")";
  }
  if (false || getAsyncOperand()) {
  _odsPrinter << ' ' << "async";
  _odsPrinter << "(";
  if (::mlir::Value value = getAsyncOperand())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getAsyncOperand() ? ::llvm::ArrayRef<::mlir::Type>(getAsyncOperand().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getWaitDevnum()) {
  _odsPrinter << ' ' << "wait_devnum";
  _odsPrinter << "(";
  if (::mlir::Value value = getWaitDevnum())
    _odsPrinter << value;
  _odsPrinter << ' ' << ":";
  _odsPrinter << ' ';
  _odsPrinter << (getWaitDevnum() ? ::llvm::ArrayRef<::mlir::Type>(getWaitDevnum().getType()) : ::llvm::ArrayRef<::mlir::Type>());
  _odsPrinter << ")";
  }
  if (false || getIfCond()) {
  _odsPrinter << ' ' << "if";
  _odsPrinter << "(";
  if (::mlir::Value value = getIfCond())
    _odsPrinter << value;
  _odsPrinter << ")";
  }
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  elidedAttrs.push_back("operandSegmentSizes");
  {
     ::mlir::Builder odsBuilder(getContext());
     ::mlir::Attribute attr = getAsyncAttr();
     if(attr && (attr == ((false) ? odsBuilder.getUnitAttr() : nullptr)))
       elidedAttrs.push_back("async");
  }
  _odsPrinter.printOptionalAttrDictWithKeyword((*this)->getAttrs(), elidedAttrs);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::WaitOp)

namespace mlir {
namespace acc {

//===----------------------------------------------------------------------===//
// ::mlir::acc::YieldOp definitions
//===----------------------------------------------------------------------===//

namespace detail {
std::pair<unsigned, unsigned> YieldOpGenericAdaptorBase::getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (odsOperandsSize - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

} // namespace detail
YieldOpAdaptor::YieldOpAdaptor(YieldOp op) : YieldOpGenericAdaptor(op->getOperands(), op) {}

::llvm::LogicalResult YieldOpAdaptor::verify(::mlir::Location loc) {
  return ::mlir::success();
}

std::pair<unsigned, unsigned> YieldOp::getODSOperandIndexAndLength(unsigned index) {
  bool isVariadic[] = {true};
  int prevVariadicCount = 0;
  for (unsigned i = 0; i < index; ++i)
    if (isVariadic[i]) ++prevVariadicCount;

  // Calculate how many dynamic values a static variadic operand corresponds to.
  // This assumes all static variadic operands have the same dynamic value count.
  int variadicSize = (getOperation()->getNumOperands() - 0) / 1;
  // `index` passed in as the parameter is the static index which counts each
  // operand (variadic or not) as size 1. So here for each previous static variadic
  // operand, we need to offset by (variadicSize - 1) to get where the dynamic
  // value pack for this static operand starts.
  int start = index + (variadicSize - 1) * prevVariadicCount;
  int size = isVariadic[index] ? variadicSize : 1;
  return {start, size};
}

::mlir::MutableOperandRange YieldOp::getOperandsMutable() {
  auto range = getODSOperandIndexAndLength(0);
  auto mutableRange = ::mlir::MutableOperandRange(getOperation(), range.first, range.second);
  return mutableRange;
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState) {
 /* nothing to do */ 
}

void YieldOp::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands) {
  odsState.addOperands(operands);
}

void YieldOp::build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes) {
  odsState.addOperands(operands);
  odsState.addAttributes(attributes);
  assert(resultTypes.size() == 0u && "mismatched number of return types");
  odsState.addTypes(resultTypes);
}

::llvm::LogicalResult YieldOp::verifyInvariantsImpl() {
  {
    unsigned index = 0; (void)index;
    auto valueGroup0 = getODSOperands(0);

    for (auto v : valueGroup0) {
      if (::mlir::failed(__mlir_ods_local_type_constraint_OpenACCOps11(*this, v.getType(), "operand", index++)))
        return ::mlir::failure();
    }
  }
  return ::mlir::success();
}

::llvm::LogicalResult YieldOp::verifyInvariants() {
  return verifyInvariantsImpl();
}

::mlir::ParseResult YieldOp::parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result) {
  ::llvm::SmallVector<::mlir::OpAsmParser::UnresolvedOperand, 4> operandsOperands;
  ::llvm::SMLoc operandsOperandsLoc;
  (void)operandsOperandsLoc;
  ::llvm::SmallVector<::mlir::Type, 1> operandsTypes;
  {
    auto loc = parser.getCurrentLocation();(void)loc;
    if (parser.parseOptionalAttrDict(result.attributes))
      return ::mlir::failure();
  }

  operandsOperandsLoc = parser.getCurrentLocation();
  if (parser.parseOperandList(operandsOperands))
    return ::mlir::failure();
  if (!operandsOperands.empty()) {
  if (parser.parseColon())
    return ::mlir::failure();

  if (parser.parseTypeList(operandsTypes))
    return ::mlir::failure();
  }
  if (parser.resolveOperands(operandsOperands, operandsTypes, operandsOperandsLoc, result.operands))
    return ::mlir::failure();
  return ::mlir::success();
}

void YieldOp::print(::mlir::OpAsmPrinter &_odsPrinter) {
  ::llvm::SmallVector<::llvm::StringRef, 2> elidedAttrs;
  _odsPrinter.printOptionalAttrDict((*this)->getAttrs(), elidedAttrs);
  if (!getOperands().empty()) {
    _odsPrinter << ' ';
    _odsPrinter << getOperands();
    _odsPrinter << ' ' << ":";
    _odsPrinter << ' ';
    _odsPrinter << getOperands().getTypes();
  }
}

void YieldOp::getEffects(::llvm::SmallVectorImpl<::mlir::SideEffects::EffectInstance<::mlir::MemoryEffects::Effect>> &effects) {
}

::mlir::MutableOperandRange YieldOp::getMutableSuccessorOperands(
  ::mlir::RegionBranchPoint point) {
  return ::mlir::MutableOperandRange(*this);
}

} // namespace acc
} // namespace mlir
MLIR_DEFINE_EXPLICIT_TYPE_ID(::mlir::acc::YieldOp)


#endif  // GET_OP_CLASSES

